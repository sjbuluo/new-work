********** PHP ********************
### 初识PHP
## 概述
PHP语法结构简单，易于入门，很多功能只需要一个函数即可
# 什么是PHP
是一种服务器端、跨平台、HTML嵌入式的脚本语言，独特的语法混合了C语言、Java语言和Perl语言的特点，广泛应用的开源式的多用途脚本语言，尤其适合Web开发
# PHP的优势
1.安全性高
2.跨平台性
3.支持广泛的数据库
4.易学性
5.执行速度快
6.免费
7.模板化
8.支持面向对象与过程
9.内嵌Zend加速引擎


### PHP语言基础
## PHP标记风格
XML风格
<?
/*
 PHP代码
*/
?>
脚本风格
<script language="php">
/* 
PHP代码
*/
</script>
简短风格
<? /*PHP代码*/ ?>
ASP风格
<%
/*
PHP代码
*/
%>
## PHP注释的应用
单行注释 //
多行注释 /**/
文档注释 /****/
#风格的注释 # 
## PHP的数据类型
PHP支持8种原始类型，包括4种标量类型，即boolean、integer、fload/double和string，2种符合类型，即array和object，2种特殊类型resource和null
# 标量数据类型
标量数据类型是数据结构汇总最基本的单元，只能存储一个数据。
boolean 		最简单的类型，只有两个值true/false
string			字符串就是连续的字符序列，可以是计算机所能表示的一切字符的集合
integer			整数数据类型只能包含整数，可以是正数和负数
float			浮点数据类型用于存储数字，和整型不同的是有小数位
1.boolean
$param = true;
除了false之外，还有0、0.0、"0"、空白字符串""、只声明未赋值的数组等
2.string
连续的字符序列，由数字、字母和符号组成。字符串中的每个字符只占用一个字节。PHP中有3种定义字符串的方式，单引号、双引号和定界符(<<<)
*
注意
对非转义字符使用\，在输出时将输出\
在定义简单的字符时，应该使用单引号，双引号PHP将花费一定时间来处理字符串的转义和变量解析。
*
$string = <<<str 
	字符串
	可以多行
str // str表示标识符 指定开始和结束 结束时必须另起一行并且不能包含空格
3.integer
32位系统中 范围为-2^31 ~ 2^31-1
可以用二进制、八进制、十进制和十六进制。八进制需要0前缀，十六进制需要0x前缀
如果超出了integer类型的范围，则会获得float类型
4.float
可以存储数字，也可以存储小数，提供的精度比整数大的多。在32位系统中，有效的范围是1.7E+308(PHP4.0版本之前是double)
两种书写方式
标准格式
3.1415
科学计数法
3.58E1
849.72E-3
浮点型的数值只是一个近似值，尽量避免浮点整数型之间的比较大小，这样的结果往往是不准确的
# 符合数据类型
array 			一组类型相同的变量的集合
object			对象是类的实例，使用new命令来创建
1.array
一组数据的集合，形成一个可操作的整体。
每个数据成为一个元素，包括索引和键值两个部分，元素的索引可以由数字或字符串支持。值则可以是多种数据类型
定义数组的语法格式
$array = array(value1, value2....);
$array[key] = value;
$array = array(key1 => value1, key2 => value2, ...);
声明之后可以自由更改，只要给数组赋值就会自动增长。
2.object
之后详解
# 特殊数据类型
resource			资源是一种特殊变量，保存了到外部资源的一个引用，资源是通过专门的函数来建立和使用的
null				特殊的值，表示变量没有值，唯一的值就是null
1.resource
PHP4引入，使用资源时，系统会自动启用垃圾回收机制，释放不再使用的资源，避免内存消耗殆尽。因此，资源很少需要手工释放
2.null
表示没有设置任何值 不区分大小写
被赋予空值的情况
还没有赋值
被赋值null
被unset()函数处理过的变量
is_null()函数用于判断变量是否为null 返回一个boolean
unset()函数用于销毁指定的变量
# 数据类型转换
(boolean)$param # null、0、未赋值的变量或数组转为false 其他true
(string)$param
(integer)$param # false转为0 true转为1 浮点型小数位直接舍去 如果以数字开头截取到数字费 否则为0
(float)$param
(array)$param
(object)$param
还可以借助settype()函数
bool settype(mixed var, string type) # 成功转换为true 失败为false
# 检测数据类型
is_bool
is_string
is_float/is_double
is_integer/is_int
is_null
is_array
is_object
is_numeric # 是否是数组组成的字符串
## PHP常量
# 声明和使用常量
常量可以理解为值不变的量。
define()函数来定义常量
define(string constant_name, mixed value, case_sensitive=false)
                常量名         值           是否大小写敏感 false敏感 true不敏感
使用常量可以使用$constant_name或者constant()函数
mixed constant(string constant_name)
判断常量是否定义defined()函数
bool defined(string constant_name)
# 预定义常量
__FILE__              默认常量 PHP程序文件名
__LINE__              默认常量 PHP程序行数
PHP_VERSION         内建常量 PHP程序版本
PHP_OS              内建常量 执行PHP解析器的操作系统名称
TRUE                真值true
FALSE               假值false
NULL                空值null
E_ERROR             指到最近的错误处
E_WARNING           指到最近的警告处
E_PARSE             指向解析语法有潜在问题处
E_NOTICE            发生不寻常处的提示但不一定是错误处
## PHP变量
# 变量声明及使用
PHP4之后无需先声明再使用 只需给变量赋值即可
$param = value; # 变量间的赋值各自使用各自的内存互不干扰
$param1 = & $param2 # 内存地址赋值
*
引用和复制的区别在于
复制将原内容复制下来 开辟一个新的内存空间来保存
而引用则是给变量的内容起个别名
*
# 变量作用域
局部变量        函数内部定义的变量 作用域在函数内部
全局变量        定义在所有函数之外的变量 作用域是整个PHP文件 但是在用户自定义函数内部不可用 如果希望在用户自定义函数内部使用全局变量 则需要使用global关键字声明
静态变量        在函数调用结束后依然保留变量值，再次回到作用域时 又可以继续使用原来的值 使用static关键字声明
# 可变变量
$a = 'b';
$b = '123';
$$a # 就指向了$b
# PHP预定义变量
详情查看资料
## PHP运算符
# 算术预算福
+ - * / %
# 字符串运算符
.将两个字符串串联起来
# 赋值运算符
=
+=
-=
*=
/=
.= # 串联字符 将右边的字符串连接到左边的变量上
%=
# 递增和递减运算符
--
++
# 位运算符
&
|
^
~
<<
>>
# 逻辑运算符
&& 或 and
|| 或 or
xor （异或)
!
# 条件运算符
?: // 三项表达式
# 运算符的优先级
详情看PDF
## PHP表达式
可以连续赋值 $a=$b=$c=1;
记住在每个表达式结尾添加分号;
## PHP函数
# 定义和调用函数
function func_name($p1, $p2, $p3...) {
    <statements>
}
# 在函数间传递参数
1.按值传递
function func_name($param1, ....) {
    func_body;
}
函数内部对参数修改不影响外部 是局部变量
2.按引用传递
function func_name(& $param1, ....) {
    func_body;
}
函数内部修改影响外部 对引用内存的修改
3.默认参数
function func_name($param1=default1, ...) {
    func_body;
}
*
有默认值的参数必须在非默认参数的右边
*
# 返回值
function func_name($param1, ...) {
    func_body;
    return xxx;
}
# 变量函数
$func = 'func_name'; # 给一个变量赋值为一个函数
$func(); # 通过变量调用对应的函数
## 编码规范
# PHP命名规则
1.类命名
使用大写字母作为词的分隔，其他字母均使用小写
名字的首字母大写
不要使用下划线
class Name {

}
2.类属性命名
属性命名应该以字符m为前缀
前缀m后采用与类命名一致的规则
m总是在名字开头起修饰作用
$mName
3.方法命名
命名规范与类命名规范一致
4.方法中参数命名
第一个字符使用小写
首字符后的所有字符都按照类命名规则首字符大写
5.变量命名
所有字母小写
使用_作为每个词的分界
6.引用变量
带有r前缀
7.全局变量
带有g前缀
8.常量/全局变量
应该全部使用大写 单词之间用_分隔
9.静态变量
带有s前缀
10.函数命名
所有名称都使用小写，多个单词以_分隔

### 流程控制语句
## 条件控制语句
# if-else if-else语句
if (expression) {
	语句1;
	语句2;
} else if (expression) {
	语句1;
	语句2;
} else {
	语句;
}
# swtich语句
swtich (变量或表达式) {
	case 常量表达式1:
		语句1;
		break;
	case 常量表达式2:
		语句2;
		break;
	case 常量表达式3:
		语句3;
		break;
	default:
		语句n+1;
		break;
}
## 循环控制语句
# while循环
whlile (表达式) {
	语句
}
# for循环
for (初始化语句; 判断语句；迭代表达式语句) {
	语句;
}
# foreach循环
foreach ($array as $item) {
	语句;
}
foreach ($array as $key => $value) {
	语句;
}
foreach用于未初始化的数组或其他类型的变量会报错 应该先使用is_array判断一下
## 跳转语句
# break
可以终止当前循环，包括while do...while for foreach和switch在内的所有控制语句
break不仅可以跳出当前循环 还可以指定跳出几重循环
break $num;
# continue
只能终止本次循环进入下一次循环中，也可以指定跳出几层循环
### 字符串操作
## 字符串的定义方法
# 使用单引号或双引号定义字符串
双引号中的内容是通过PHP的语法分析器解析过的，任何变量在双引号中都会被转换为实际的值输出显示
而单引号则是所见即所得，直接输出不经过转换
# 使用定界符<<<
与双引号一样，变量会被替换为实际的值。
## 字符串操作
# 去除字符串首尾空格和特殊字符
1.trim函数
用于去除字符串首尾处的空白字符（或其他字符）
trim(string str[, string charlist]);
charlist可选，为所有希望过滤的字符，可以使用..列出一个字符范围。如果不设置该参数，则所有的可选字符都将被删除。
不指定charlist参数是的trim()函数去除的字符
\0
\t
\n
\x0B
\r
" "
2.ltrim()
用于去除字符串左边的空白字符(或其他字符)
3.rtrim()
用于去除字符串右边的空白字符（或其他字符）
# 转义、还原字符串数据
1.手动转义、还原字符串数据
\是转义符，紧跟之后的第一个字符将变得没有意义或者特殊意义。
2.自动转义、还原字符串数据
string addslashes(string str)函数 输入需要转义的字符串 返回转义后的字符串
string stripslashes(string str) 输入转义后的字符串 返回还原的字符串（即去除反斜杠\)
string addcslashes(string str, string charlist) 在指定的字符串前加上反斜杠 如果参数charlist中包含\n\r等字符，将以C语言风格转换 而其他非字母数据且ASCII低于32以及高于126的字符均转换为八进制表示
string stripcslashes(string str) 将转义后的字符串还原
# 获取字符串的长度
int strlen(string str) 函数
汉字占用两个字符，数字、英文、小数点、下划线和空格占一个字符
也可以用于检测字符串的长度
# 截取字符串
string substr(string str, int start[, int length])
start从0开始
# 比较字符串
1.按字节进行字符串比较
int strcmp(string str1, string str2) // 区分字符大小写 相等则返回0 str1大于str2则返回大于0 小于则返回小于0
strcasecmp(string str1, string str2) // 不区分字符大小写
2.按自然排序法进行字符串比较
int strnatcmp(string str1, string str2) // 从左向右进行比较，如果数字比较则按照自然排序法 其他则根据字符的ASCII码值进行比较
3.指定从源字符串的位置开始比较
int strncmp(string str1, string str2, int len) // 比较字符串的前n个字符
# 检索字符串
1.strstr()函数查找指定的关键字
获取一个指定字符串再另一个字符串中首次出现的置为到后者末尾的子字符串，有则返回剩余字符串，没有返回false
string strstr(string haystack, string needle) // 区分大小写
string strrchr(string haystack, string needle) // 后序开始搜索
2.substr_count()搜索子串出现的次数
int substr_count(string haystack, string needle) 
# 替换字符串
1.str_ireplace() 
mixed str_ireplace(mixed search, mixed replace, mixed subject[, int count])
search 可以是数组 要搜索的值
replace 替换的值
subject 可以是数组 被搜索的值
count 替换的数量
str_treplace() 不区分大小写 str_replace 区分
2.substr_replace()函数
用于将指定字符串的部分字符串进行替换
mixed substr_replace(mixed string, mixed repl, mixed start[, mixed length])
string 可以是数组 要操作的原始字符串
repl 指定替换后的字符串
start 开始位置
length 长度
# 格式化字符串
string number_format(float number[, int decimals[, string dec_point[, tring thousands_sep]]])
number 要格式化的数字
decimals 要保留的小数位
dec_point 小数点显示的字符
thousands 千位分隔的字符
# 分割、合成字符串
1.分割字符串
array explode(string delimiter, string str[, int limit])
delimiter 分割符
str 	被分割的字符串
limit 返回的数组中最多包含limit个元素
2.合成字符串
string implode(string glue, array pieces)
glue 分隔符
pieces 合成的数组
### 正则表达式
## 什么是正则表达式
描述字符串结构的语法规则，是一个特定的格式化模式，可以匹配、替换、裁取匹配的子串。
## 正则表达式语法规则
# 行定位符
^
$
# 单词分解符
\b // \btm\b 表示需要匹配的是一个完整的单词而不是一部分
\B // \Btm\B 表示需要匹配的是一部分而不是完整的单词
# 字符类
[] 出现在括号内的都匹配
[:digit:] 十进制数字集合 [0-9]
[[:alnum:]] 字母和数字的集合 [a-zA-Z0-9]
[[:alpha:]] 字母集合 [a-zA-Z]
[[:blank:]] 空格和制表符
[[:xdigit:]] 十六进制数字
[[:punct:]] 特殊字符集合 如@!#$?等
[[:print:]] 可打印字符 包括空格
[[:space:]] 空白字符
[[:graph:]] 可打印字符 不包括空格
[[:upper:]] 大写字符 [A-Z]
[[:lower:]] 小写字符 [a-z]
[[:cntrl:]] 控制字符
# 选择字符
| 或
# 连字符 
- 表示字符的范围
# 排除字符
[^] 匹配不匹配括号内的其他字符
# 限定符
?
*
+
{n, m}
# 点号字符
除换行符以外的任意字符
# 转义字符
\ 将特殊意义的字符转换为普通字符
# 反斜线
1.将不可打印的字符显示出来
\a
\b
\e
\f
等
2.指定预定义字符集
\d 一个十进制数字
\D 非十进制数字
\s 空白字符
\S 非空白字符
\w 单词
\W 非单词
3.断言的限定符
# 括号字符
(xxx|yyy) 表示匹配xxx或yyy
第二个作用是分组
# 反向引用
# 模式修饰符
设定模式，规定正则表达式应该如何解释和应用
i		忽略大小写
M		多文本模式 即字符串内部有多个换行符时 影响^$的匹配
s		单文本模式 .可以匹配换行符 其他模式下不行
X		忽略空白字符
## PCRE兼容正则表达式
# preg_grep()函数
array preg_grep(string pattern, array input)
使用数组input中的元素一一匹配表达式pattern，返回匹配元素组成的数组
# preg_match() preg_match_all()
int preg_match/preg_match_all(string pattern, string subject[, array matches])
字符串subject中匹配表达式pattern，如果有数组则每次匹配都存储到matches数组中
返回值是0或1 preg_match匹配到第一个就返回 preg_match_all则匹配全部 array matches对preg_match_all是必须的
# preg_quote()函数
string preg_quote(string str[, string delimiter])
将字符串str中的所有特殊字符进行自动转义 如果有delimiter则对应的子串也将转义
# preg_replace()函数
mixed preg_replace(mixed pattern, mixed replacement, mixed subject[, limit])
在字符串subject中匹配表达式pattern， 将匹配项替换成子串repleacement
在replacement中使用$1 $2获取匹配的分组字符串
# preg_replace_callback() 函数
mixed preg_replace_callback(mixed pattern, callback callback, mixed subject[, int limit])
使用回调函数而不是字符串来替换 
function func($arr) { // 传入的参数是一个数组 需要留意
	return $str;
}
# preg_split()函数
array preg_split(string pattern, string subjec[, int limit])
### PHP数组
## 什么是数组
一组数据的集合
## 声明数组
array array([mixed ...])
mixed语法为 key => value 如果没有指定key 则自动生成从0开始的整数索引
print_r($arr) 迭代输出一个数组
## 数组的类型
PHP支持两种数组 索引数组（indexed array)和联合数组(associative array)前者使用数字作为key，后者使用字符串作为key
# 数字索引数组
数字索引一般表示数组元素在数组中的位置，有数字组成，下标从0开始，数字索引数组默认索引值从0开始。也可以从指定位置开始保存数据
# 关联数组
关联数组使用字符串索引来访问存储在数组中的值 对于数据库层交互非常有用
## 输出数组
bool print_r(mixed expression)
##数组的构造
# 一维数组
数组元素时变量
# 二维数组
数组元素时一维数组
##　遍历数组
1.使用foreach结构遍历数组
foreach ($arr as $item) {

}
foreach ($arr as $key => $value) {


}
2.list()函数
void list(mixed ....) 仅用于数字索引的数组
## 字符串与数组的转换
1.explode()函数 将字符串转换为数组
array explode(string delimiter, string str[, int limit]);
2.implode()函数 将数组转换为字符串
string implode(string glue, array piceces)
## 统计数组元素个数
int count(mixed array[, int mode])
mode 可选参数 COUNT_RECURSIVE(或者1)递归的对数组计算 默认0
## 查询指定元素
mixed array_search(mixed needle, array haystack[, bool strict])
找到指定值则返回键名，否则返回false  strict为true时还将检查类型是否符合
## 获取数组中最后一个元素
mixed array_pop(array array)
获取并返回数组的最后一个元素，数组长度减一 数组为空或不是数组时返回null
## 添加元素
int array_push(array array, mixed var[, mixed ....])
将传入的变量压入数组的尾部，数组长度加一，并返回数组元素总数
## 删除数组中重复元素
array array_unique(array array)
用于将值作为字符串排序，然后每个只保留第一个键名，忽略后面所有的键名，即删除重复元素

### PHP与Web页面交互
## 表单
# 创建表单
<form action="" method="" enctype="" target="">
target _blank 新窗口 _self 当前窗口 _parent 父窗口 _top 顶级窗口
# 表单元素
1.<input>
2.<select><option>
3.<textarea>
## 在普通Web也中插入表单
## 获取表单数据的两种方法
#POST
#GET
## PHP参数传递的常用方法
# $_POST[]全局变量
通过post方法提交过来的数据
有些可以直接使用$<参数名>来获取数据 与php.ini的配置有关 register_globals=ON/OFF ON则可以取的到 但存在安全隐患 推荐使用OFF
# $_GET[]全局变量
通过GET方法提交过来的数据
# $_SESSION[]变量
获取表单元素的值 使用$_SESSION传参方法获取的变量值，保存之后可以在任何页面中使用 但很耗费系统资源
## 在Web页面中嵌入PHP脚本
# 在HTML标记中添加PHP脚本
可以随时添加<?php ?>PHP脚本标记，标记中的所有文本将被解释为PHP，标记之外的则被认为是普通的HTML
# 对表单元素value属性赋值
value="<?php  echo 123;?>"
## PHP中获取表单数据
# 获取文本框、密码域、隐藏域、按钮、文本域的值
<form>标签中的name是所有表单元素都具备的属性，即为这个表单元素的名称，在使用时使用name属性来获取相应的value值。
# 获取单选按钮的值
radio一般成组出现，具有相同的name和不同value
# 获取复选框的值
checkbox 相同的name 不同的value 可以是多个值 name一般以数组的命名以[]结尾
# 获取下拉列表框/菜单列表框的值
select option
# 文件
file
## URL传递的参数进行编解码
# 对URL传递的参数编码
string urlencode(string str)
对服务器而言，可以自动识别
# 对URL传递的参数解码
string urldecode(string str) 
## PHP与Web表单的综合应用
move_upload_file($_FILES['name']['tmp_name'], 目的地包括保存的文件名);

### PHP与JavaScript交互
如同在HTML中一样使用即可

### 日期和时间
## 系统时区设置
# 时区划分
24个时区 UTC
# 时区设置
1.修改php.ini配置文件中的;date.timezone=选项 Asia/Shang_Hai
2.在应用程序中使用date_defualt_timezone_set(timezone)
## PHP日期和时间函数
# 获得本地化时间戳
mktime()函数将一个时间转换为UNIX时间戳
int mktime(int hour, int minute, int second, int month, int day, int year,int [is_dst]) 默认-1（不确定）夏令1 不是0
# 获取当前时间戳
int time(void)
# 获取当前日期和时间
date(string format[, int timestamp = time()])
返回按照指定格式产生的字符串 timestamp为可选值 不提供则为当前时间戳
预定义的format
DATE_ATOM			原子钟格式
DATE_COOKIE			HTTP Cookie格式
DATE_ISO8601		ISO8601格式
DAtE_RFC822
DATE_RFC850
DATE_RSS
DATE_W3C			World wide web Consortium格式
# 获取日期信息
array getdate([int timestamp]);
# 检验日期的有效性
bool checkdate(int month, int day, int year)
# 输出格式化的日期和时间
a			小写的上午或下午 am或pm
A			大写的上午或下午 AM或PM
B			Swatch Internet标准时间 返回值为000~999
d			月份中的第几天 有前导的0 范围1~31
D			星期中的第几天 文本格式 3个字母 Mon~Sun
F			月份 完整的文本格式 January~December
h			小时 12小时格式
H			小时 24小时格式
i			有前导零的分钟数
I			判断是否为夏令
j			月份中的第几天 没有前导0
l			星期数 完整的文本格式 返回
L			是否是闰年 是为1 不是为0 
m			数字表示的月份 有前缀0
M			3个字母缩写表示的月份 Jan~Dec
n			数字表示的月份 没有前导0
O			与格林威治时间相差的小时数 如+0200
r 
s			描述 有前导0
S			每月天数后面的英文后缀 两个字符 如st nd等
t			每月应有天数 28~31
T 			所在时区
U			从UNIX纪元1970-01-01 00:00:00+0000开始至今的秒数
w			星期中的第几天 0~6
W			第几周 每周从周一开始
y			两位数字表示的年份 如88
Y			四位数字表示的年份 如1988
z			年份中的第几天 1~366
Z 			时差偏移量的秒数
# 显示本地化的日期和时间
1.setlocale()函数
改变PHP默认的本地化环境
string setlocale(string category, string locale)
category可选项
LC_ALL					包含以下所有设置本地化规则
LC_COLLATE				字符串比较
LC_CTYPE				字符串分类和转换
LC_MONTARY				本地化环境的货币形式
LC_NUMERIC				本地化环境的数值形式
LC_TIME					本地化环境的时间格式
locale为空 就会使用环境变量的locale或lang的值 en_US美国 chs简体中文 cht繁体中文
2.strftime()桉树
根据本地化环境设置来格式化输出日期和时间
string strftime(string format, int timestamp)
# 将日期和时间解析为UNIX时间戳
int strtotime(string time[, int now])
# 实现倒计时功能
# 页面脚本的运行时间


******************* 核心技术 *****************
### Cookie和Session
## Cookie管理
# 了解Cookie
1.什么事Cookie
是一种远程浏览器端存储数据并以此来跟踪和识别用户的机制，简单的说，Cookie是Web服务器暂时存储在用户硬盘上的一个文本文件，并随后被Web浏览器读取。用户再次访问Web网站时，通过读取Cookie文件记录这位访客的特定信息。
文本文件的命令格式
用户名@网站地址[数字].txt
2.Cookie的功能
Web服务器可以应用Cookie包含信息的任意性来筛选并经常性维护这些信息 常用于这些方面
A.记录访客的某些信息 如访问次数 登录的用户名等
B.在页面之间传递变量
C.将所查看的Internet页存储在Cookie的临时文件夹中 提高浏览速度
# 创建Cookie
bool setcookie(string name[, string value[, int expire[, string path[, string domain[, int secure]]]]])
name 		Cookie的变量名 $_COOKIE['<cookie_name>']获取Cookie
value		变量值 保存在客户端
expire		过期时间 标准的UNIX时间戳 如果不设置过期时间将永远有效 除非手动删除
path		Cookie在服务器端的有效路径	如果/则在整个domain中有效 如果/ll则在domain下的/ll目录及其子目录中有效 默认是当前目录
domain		Cookie的游侠域名	如果要在所有xxx.com域名下的子域都有效 则应该设置为xxx.com
secure		指明Cookie是否仅通过安全的HTTPS 值为0或1	1则只在HTTPS连接上有效 0则都有效
# 读取Cookie
通过超级全局数组$_COOKIE[]来读取浏览器端的Cookie值
# 删除Cookie
1.使用setCookie()函数删除
setcookie('name', '', time() - 1);
2.手动删除Cookie
# Cookie的生命周期
不设定时间，就表示生命周期是浏览器会话的期间，关闭就消失，称为会话Cookie，一般不保存在硬盘上，而是在内存中
设置了过期时间就会保存在硬盘中直到超时
浏览器存储的cookie有上线，最大容量有限制，每个域名的cookie有最大数量限制，达到后会自动删除.
## Session管理
# 了解Session
1.什么是Session
会话，本义是指有始有终的一系列动作/消息。
计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统所经过的时间。
2.Session工作原理
启动一个Session会话时，会生成一个随机且唯一的session_id,也就是session的文件名，此时session_id存储在服务器的内存中，关闭页面时id自动注销。重新登录页面会再次生成一个随机且唯一的id
3.Session的功能
Web技术中非常重要，由于网页是一种无状态的连接程序，因此无法得知用户的浏览状态。通过Session则可记录用户的有关信息，以供用户再次以此身份对Web服务器提交要求时确认身份。
Session适用于存储信息量较少的情况。
# 创建会话
1.启动会话
session_start() 会话变量被登录到$_SESSION中
bool session_start()
使用session_start()前不能有任何输出
使用session_register()函数 不需要调用session_start()函数 会在注册变量后隐含地调用session_start()
2.注册会话
session_start();
$_SESSION['admin'] = null;
3.使用会话
if (!empty($_SESSION['session_name'])) {
	$myparam = $_SESSION['session_name'];
}
4.删除会话
1)删除单个会话
unset($_SESSION['session_name']);
2)删除多个会话
$_SESSION = array();
3)结束会话
session_destory();
# Session设置时间
1.客户端没有禁止Cookie
1)
session_set_cookie_params($time);
必须在session_start()之前调用
2)
session_start()
setcookie(session_name(), session_id(), time() + $time, '/');
2.客户端禁止Cookie
1)登录之前提醒用户打开Cookie
2)设置php.ini中 session.use_trans_sid=1 或者编译时打开 -enable-trans-sid选项 让PHP自动跨页面传递session_id
3)通过GET方法，隐藏表单传递session_id
4)使用文件或者数据库存储session_id,在页面传递中手动调用
Session原理为请求页面之后产生一个session_id，如果禁止Cookie就无法传递session_id，就会重新产生一个session_id，造成session传递失效
# 通过Session判断用户的操作权限


## Session高级应用
# Session临时文件
服务器中，如果所有用户的Session都保存到临时目录中，会降低服务器的安全性和效率，打开服务器存储的站点非常慢
使用session_save_path()存储Session临时文件
session_save_path()应该在session_start()之前调用
# Session缓存
将网页中的内容临时存储到IE客户端的Temporaty Internet Files文件夹下，并且设置缓存时间。
string session_cache_limiter([string cache_limiter])
cache_limiter 为private或public
int session_cache_expire([int new_cache_expire])
设置缓存时间 单位是分钟
以上两个函数需要在session_start()前调用
# Session数据库存储
bool session_set_save_handler(string open, string close, string read, string write, string destroy, string gc)
open(save_path, session_name) 	找到存储地址，取出变量名名称
close()							关闭数据库
read(key)						读取session键值 key对应session_id
write(key, data)				data对应设置的session变量
destroy(key)					注销session对应的Session键值
gc(expire_tiem)					清除过期Session记录
function _session_open($save_path, $session_name) {
	global $handle;
	$handle = mysql_connect('localhost', 'root', ''root') or die('数据库连接失败');
	mysql_select_db('db_database', $handle) or die('没有此库名');
	return (true);
}
function _session_close() {
	global $handle;
	mysql_close($handle);
	return (true);
}
function _session_read($key) {
	global $handle;
	$time = time();
	$sql = "select session_data from tb_session where session_key = '$key' and session_time > $time";
	$result = mysql_query($sql, $handle);
	$row = mysql_fetch_array($result);
	if ($row) {
		return ($row['session_data']);
	} else {
		return (false);
	}
}
function _session_write($key, $data) {
	global $handle;
	$time = 60 * 60;
	$lapse_time = time() + $time;
	$handle = mysql_connect('localhost', 'root', 'root') or die ('数据库连接失败');
	mysql_select_db('db_database', $handle) or die('没有此库');
	$sql = "select session_data from tb_session where session_key = '$key' and session_time > $lapse_time";
	$result = mysql_query($sql, $handle);
	if(mysql_num_rows($result) == 0) {
		$sql = "insert into tb_session values ('$key', '$data', $lapse_time)";
		$result = mysql_query($sql, $handle);
	} else {
		$sql = 'update tb_session set session_key = '$key', session_data = '$data', session_time = $lapse_time where session_key = '$key'";
		$result = mysql_query($sql, $handle);
	}
	return ($result);
}
function _session_destroy($key) {
	global $handle;
	$sql = "delete from tb_session where session_name = '$key'";
	$result = mysql_query($sql, $handle);
	return ($result);
}
function _session_gc() {
	global $handle;
	$lapse_time = time();
	$sql = "delete from tb_session where session_tiem < $lapse_time";
	$result = mysql_query($sql, $handle);
	return ($result);
}

### 图形图像处理技术

### 文件系统
## 文件处理
包括读取、关闭、重写等。
# 打开/关闭文件
打开/关闭文件使用fopen()和fclose()函数，小心防止错误操作。
1.打开文件
resource fopen(string filename, string mode[, bool use_include_path]);
filename是要打开的包含路径的文件名，可以是相对路径或绝对路径，如果没有前缀表示打开的是本地文件。mode是打开文件的方式。use_include_path在php.ini中指定的参数，希望PHP在此路径下打开文件。
mode 可取值
r		只读		读模式 进行读取 文件指针位于文件开头
r+		只读		读写模式 文件指针位于文件的开头 在现有文件内容的末尾之前进行写操作将会覆盖原有内容
w		只写		写模式 文件指针指向文件开头 如果文件存在则所有文件内容删除 否则将会创建一个新的文件
w+		只写		读写模式 文件指针指向文件卡头 如果文件存在则所有文件内容删除 否则将会创建新的文件
x		谨慎写		写模式 文件指针指向文件开头 如果文件已存在则不会打开文件 并返回false产生警告
x+		谨慎写		读写模式 文件指针指向文件开头 如果文件已存在则不会打开文件 并返回false产生警告
a		追加		追加模式 文件指针指向文件尾部，已有内容则追加到文件尾部 没有则创建新文件
a+		追加 		读写模式 文件指针指向文件开头 已有内容则追加到文件尾部 没有则创建新文件
b		二进制
t		文本
2.关闭文件
bool fclose(resource handle)
# 读写文件
1.读取数据
可以一次读取一个字符，一行字符或整个文件，还可以读取任意长度的字符串
（1）读取整个文件 readfile file file_get_contents
1)readfile()
用于读取一个文件并将其写入到输出缓冲中，如果出现错误则返回false
int readfile(string filename)
使用readfile不需要fopen/fclose，不需要echo/print等输出语句，直接写出文件路径即可
2)file()
可以用于读取整个文件内容，只是将文件内容按行存放到数组中，包括换行符在内，如果失败则返回false
array file(string filename)
3)file_get_contents()
将文件内容读入一个字符串，如果有offset和maxlen则从指定位置读取指定长度的字符串，如果失败返回false
string file_get_contents(string filename[, int offset[, int maxlen]])
此方法适用于二进制对象，是将整个文件内容读入一个字符串中的首选方式
（2）读取一行数据 fgets() fgetss()
1)fgets()
string fgets(int handle[, int length])
handle是打开的文件，函数能够实现从handle指定文件中读取一行数据并返回长度最大值为length-1个字节的字符串。在遇到换行符、EOF或者读取了length-1个字节之后停止。如果没有length参数，则读取到行结束
2)fgetss()
是fgets()函数的变体，用于读取一行数据，同时会过滤掉内容中的HTML和PHP标记
string fgetss(reource handle[, int length[, string allowable_tags]])
过滤掉任何HTML和PHP标记，allowable_tags用于控制哪些标记不被过滤
（3）读一个字符 fgetc()
string fgetc(resource handle)
（4）读取任意长度的字符串 fread()
fread()可以从文件中读取任意长度的字符串 
string fread(int handle, int length)
length是要获取的字符串
2、写入数据
fwrites() fputs() file_put_contents()向文件写入数据
int fwrite(resource handle, string string[, int length])
把内容sring写入文件，如果指定了length则在写入指定字节后停止。
int file_put_contents(string filename, string data[, int flags]);
flags可取值 FILE_USE_INCLUDE_PAth FILE_APPEND LOCK_EX LICK_EX为独占锁定s
file_put_contents和依次调用fopen() fwrites() fclose()功能一样
# 操作文件
对文件本身进行操作 如复制、重命名、查看修改日期等
bool copy(string path1, string path2)			将文件从path1复制到path2 如果成功返回true 如果失败返回false
bool rename(string filename, string filename2) 	把filename1重命名为filename2
bool unlink(string filename) 					删除文件 成功返回true 失败返回false
int fileatime(string filename) 					返回文件最后一次被访问的时间，时间以UNIX时间戳的方式返回
int filemtime(string filename)					返回文件最后一次被修改的时间，时间以UNIX时间戳的方式返回
int filesize(string filename)					返回文件filename的大小(bytes)
array pathinfo(string name[, int options])		返回一个数组，包含文件name的路径信息，有datetime，basename和extension，可以通过options指定返回的信息有PATHINFO_DIRNAME,PATHINFO_BASENAME,PATHINFO_EXTENSION,默认全部返回
string realpath(string filename) 				获取文件的绝对路径
array stat(string filename)						获取一个数组，包含文件的相关详细信息
## 目录处理
目录是一种特殊的文件，要浏览目录下的文件，首先要打开目录，浏览完毕后，同样要关闭目录。目录处理包含打开目录、浏览目录和关闭目录
# 打开/关闭目录
1.打开目录
resource opendir(string dirpath)
合法的目录路径，成功执行之后返回目录的指针。如果不是合法的目录或者因为权限或文件系统错误而不能打开目录，则返回一个false并产生一个E_WARNING级别的错误信息，可以在opendir()前加上@符号来抑制错误信息的输出
2.关闭目录
void closedir(resource handle)
# 浏览目录
array scandir(string directory[, int sorting_order])
返回一个数组，包含directory中的所有文件和目录，参数sorting_order指定排序顺序，默认按照字母升序排序。如果添加了该参数，则变为降序排序。
# 操作目录
目录是特殊的文件，因此对文件的操作多数同样适用于目录
bool mkdir(string pathname) 				新建一个指定的目录
bool rmdir(string dirname)					删除指定的目录，该目录必须为空的
string getcwd(coid)							获取当前工作的目录
bool chdir(string directory)				改变当前目录为directroy
float disk_free_space(string directory)		返回目录中可用空间（bytes），检查的文件必须通过服务器的文件系统访问
float disk_total_space(string directory)	返回目录的总空间大小(bytes)
string readdir(resource handle)				返回目录中下一个文件的文件名（必须使用opendir()打开）
void rewinddir(resource handle)				将指定的目录重新指定到目录的开头
## 文件处理的高级应用
# 远程文件的访问
支持URL格式的文件调用，需要在php.ini中配置一下，allow_url_fopen: ON
# 文件指针
1.rewind()函数
将文件指针指向文件流的开拓
bool rewind(resource handle)
如果以a的mode打开文件则无论指针在哪都在文件尾部追加内容
2.fseek()函数
实现文件指针的定位
int fseek(resource handle, int offset[, int whence])
handle 打开的文件
offset 为指针位置或相对whence的偏移量 可以是负值
whence 包括3种 SEEK_SET 位置等于offset字节 SEEK_CUR	位置等于当前位置加上offset字节 SEEK_END 位置等于文件尾部加上offset字节 如果忽略whence 系统默认为SEEK_SEt
3.feof()函数
该函数判断文件指针是否在文件尾
bool feof(resource handle)
如果文件指针到达文件结束的位置，返回true，否则返回false
4.ftell()函数
返回当前指针的位置
# 锁定文件
向一个文本文件写入内容时，需要先锁定该文件，以防止其他用户同时修改此文件内容。使用flock()函数
bool flock(resource handle, int operation)
handle是一个已打开的文件，operation可选值为
LOCK_SH		取得共享锁定 （读取程序）
LOCK_EX		取得读取锁定 （写入程序）
LOCK_UN		释放锁定	
LOCK_NB		防止flock()在锁定时阻塞
## 文件上传
需要修改$_FILES中的配置，并了解$_FILES[]全局变量 最后使用move_uploaded_file()实现上传
# 配置php.ini文件
file_uploads		如果值时ON则说服务器支持文件上传 OFF则不支持
upload_tmp_dir		上传文件临时目录，成功上传之前，文件首先存放在服务器端的临时目录中，如果想要指定位置可以设置，否则使用系统默认目录即可
upload_max_filesize	服务器允许上传的文件的最大值，以MB为单位，默认2MB，可自行设置
还有一些属性可能影响文件上传
max_execution_time 	PHP中一个指令所能执行的最大时间，单位是秒
memory_limit		PHP中一个指令所分配的内存空间，单位是MB
# 预定义变量$_FILES
$_FILES变量存储的是上传文件的相关信息，这些信息对于上传功能有很大的作用。该变量是一个二维数组。
$_FILE[filename][name]				上传文件的文件名
$_FILE[filename][size]				存储了文件大小 单位为字节
$_FILE[filename][tmp_name]			文件上传时，首先在临时目录中被保存成一个临时文件，该变量为临时文件名
$_FILE[filename][type]				上传文件的类型
$_FILE[filename][error]				存储了上传文件的结果如果返回0说明文件上传成功
# 文件上传函数
bool move_uploaded_file(string filename, string destination) 
将上传文件存储到指定的位置，如果成功返回true 如果失败返回false filename是上传文件的临时文件名
使用move_uploaded_file()函数上传文件时，需要设置enctype="multipart/form-data"属性
# 多文件上传
将name设置为xxx[] 则在$_FILES[xxx][name/tmp_name/error/...] 都变为数组

### 面向对象
## 面向对象的基本概念
# 类
# 对象
# 面向对象编程的三大特点
继承
封装
多态
## PHP与对象
# 类的定义
class MyObject {

}
# 成员方法
类中的函数称为成员方法，函数和成员方法唯一的区别即使，函数实现的是某个独立的功能，而成员方法是实现类中的一个行为，是类的一部分。
class MyObject {
	function func($param1, $param2) {
		echo $param1;
	}
}
# 类的实例化
使用类的方法需要先实例化类，通过new关键字来声明一个对象。再使用以下格式调用成员方法
对象 -> 成员方法
# 成员变量
类中的变量也称为成员变量（也有称为属性或字段的）。成员变量用来保存信息数据，或与成员方法进行交互来实现某项功能。
public/private/protected/static/final 成员变量
调用的方式和成员方法一样
对象 -> 成员变量 （此处的变量是没有$前缀的)
$this -> 成员变量 调用本实例的成员变量
# 类常量
const PI = 3.1415927;
使用
类名::类常量
# 构造方法和析构方法
1.构造方法
当一个类实例化一个对象时，可能需要随着对象初始化一些成员变量。
构造方法就是生成对象时自动执行的成员方法，作用就是初始化对象，可以没有参数，也可以有多个参数。
格式
void __construct([mixed args[,...]])
没有显式声明构造函数，PHP会自动生成一个没有参数的构造函数，并且内部没有任何操作。
2.析构方法
在对象被销毁时调用，作用是释放内存。
void __destruct(void)
PHP使用垃圾回收机制，自动清除不再使用的对象，释放内存。即使不调用unset()方法，析构方法也会自动调用。
# 继承和多态的实现
1.继承
子类继承父类所有的成员变量和方法，包括构造函数，当子类创建时，PHP会先在子类中查找构造方法，如果子类有自己的构造方法，PHP会先调用子类的构造方法，没有则调用父类的构造方法。
class SubClass extends SuperClass {

}
2.多态
存在两种形式 重写和重载
1)重写就是子类中重写父类的方法，不同子类调用同名的方法得到的结果是不同的
2)重载就是通过参数数量或类型来将同名的函数区分开，调用不产生混淆,好处是可实现代码重用
# $this->和::的使用
PHP通过伪变量$this->和作用域操作符::来实现
1.$this->
在定义类是，想要调用类中的方法或变量，用伪变量$this-> $this的意思就是本身 所以只能在类的内部使用
get_class()函数返回对象所属类的名字，如果不是对象则返回false
2.操作符::
可以在没有声明任何实例的情况下访问类中的成员方法或成员变量
关键字::变量名/常量名/方法名
关键字分为
parent::  可以调用父类中的成员变量、成员方法和常量
self::	  可以调用当前类中的静态成员和常量
类名::		可以调用本类中的变量、常量和方法
# 数据隐藏
1.public （默认的 没有显式声明就是public的）
公开，没有隐藏的数据信息。可以在程序的任何位置被其他的类和对象调用。子类可以继承和使用父类中的所有公共成员。
2.private
只能在所属类的内部被调用和修改，不可以在类外被访问。在子类中也不可以
3.protected
对本类和子类可见，在类外不可见。
# 静态变量/方法
不是所有的变量方法都要通过创建对象来调用，可以通过给变量方法加上static关键字来直接调用，调用静态成员的格式为
关键字::静态成员
关键字
self::	类内部调用静态成员时使用
类名::	在类外调用类内部的静态成员使用
静态方法中，只能调用静态变量，不能调用普通变量，普通方法中可以调用静态变量
还有一个好处就是对象销毁之后，静态成员依然存在，可以下次继续使用
## 面向对象高级应用
# final关键字
final class class_name {

}
表示这个类不能被继承 也不能有子类
如果有一个方法被final修饰
final function func_name()
表示这个方法不能被子类重写 也不能被覆盖
# 抽象类
abstract class AbstractClass {

}
抽象类是一个不能被实例化的类，只能作为其他类的父类来使用，抽象类使用abstract关键字来声明
抽象类和普通类相似，包含成员变量，成员方法，区别在于抽象类至少包含一个抽象方法，抽象方法没有方法体，其功能的实现只能在子类中完成。抽象方法也是使用abstract关键字声明的
abstract function func_name(); // 分号不能少
# 接口的使用
interface inter_name {

}
PHP只支持单继承，想要实现多重继承需要使用接口
不能用public以外的关键字来修饰接口中的类成员，对于方法，不写关键字也可以。
子类通过implements关键字来实现接口，如果需要实现多个接口，需要使用逗号分隔，并且所有未实现的方法需要在实现类中实现。
# 克隆对象
1.关键字clone
PHP4之前对象赋值是复制一个备份，PHP5之后则是传递引用。如果想要得到一个备份 可以使用clone关键字来实现
2.__clone方法
除了单纯的克隆对象外，还需要克隆出的对象可以拥有自己的属性和行为。需要使用__clone方法来实现。作用是在克隆过程中，调用__clone方法。
# 对象比较
== 比较对象内容
=== 比较对象地址
# 对象类型检测
ObjectName instanceof ClassName
# 魔术方法
以 __ 开头的方法
__construct
__destruct
__clone
1.__set和__get方法
当程序视图写入一个不存在或不可见的成员变量时，PHP就会执行__set方法，__set方法包含两个参数，分表表示变量名称和变量值，参数不可省略。
当程序试图调用一个未定义或不可见的成员变量时，可以通过__get方法来获取变量，有一个参数，表示要调用的变量名
2.__call方法
当程序试图调用不存在或不可见的成员方法时，会先调用__call来存储方法名及其参数，包含两个参数，方法名和参数数组
3.__sleep和__wakeup方法
使用serialize()函数可以实现序列化对象，将对象中的变量全部保存下来。如果包含__sleep()方法则先执行__sleep 目的是关闭对象可能具有的数据库连接等类似的善后工作 return array("field_name") 只有在这个数组中的成员变量会被序列化
unserialize()函数反序列化对象，__wakeup方法则是在恢复可能丢失的工作
4.__toString方法
当使用echo和print输出对象时，将对象转化为字符串
5.__autoload方法
将一个独立、完整的类保存到一个PHP页中，并且文件名和类名保持一致，__autoload方法可以自动实例化需要使用的类


### PHP加密技术
## PHP加密函数
# 使用crypt()函数进行加密
string crypt(string str[, string salt])
str是需要加密的字符串 salt是加密时使用的干扰字符串 如果省略第二个参数 则会随机生成一个干扰字符串
crypt()函数支持4种算法和salt参数的长度
CRYPT_STD_DES			2-character(默认)
CRTPT_EXT_DES			9-character
CRYPT_MD5				12-character $1$开头 
CRYPT_BLOWFISH			16-character $2$开头
默认情况下，PHP使用一个或两个字符的DES干扰字符串 如果使用MD5 则会使用12个字符 通过CRYPT_SALT_LENGTH变量来查看当前所使用的干扰字符串的长度
加密是单向了 密文不能还原成明码
# 使用md5()函数进行加密
md5()函数使用MD5算法 作用是把不同长度的数据信息结果一系列的算法计算成一个128位的数值，就是把一个任意长度的字节串转换为一定长的大整数。
string md5(string str[, bool raw_outptu])
str加密的明文 raw_output如果true返回一个二进制的密文 默认为false
# 使用sha1()函数进行加密
string sha1(string str,[bool raw_output])
返回一个40位的十六进制数，如果raw_output为true 返回一个20位的二进制
## PHP加密扩展库
# Mcrypt扩展库
1.Mcrypt库安装

*
Mcrypt在PHP7.2之后过时 
*

### MySQL数据库基础
## MySQL概述
## 启动和关闭MySQL
## 操作MySQL
## MySQL数据类型

### PHP操作MySQL数据库 (需要打开php.ini中配置 extension_dir=/ext和extension=mysqli)
## PHP操作MySQL数据库的方法
# 连接MySQL服务器
mysqli mysqli_connect([string server[, string username, [string password[, string dbname[, int port[, string socket]]]]]])
mysqli_connect函数用于打开一个MySQL服务器的连接 如果成功返回一个MySQL连接标识 失败返回false
servver		MySQL服务器地址
username	用户名 默认值是服务器进程所有者的用户名
password 	密码 默认值空
dbname		连接的数据库名称
port		Mysql服务使用的端口号
socket 		UNIX域的socket
# 选择MySQL数据库
在mysqli_connect中指定数据库或者mysqli_select_db
bool mysqli_select_db(mysqli link, string dbname)
*
实际开发中 将MySQL服务器的连接和数据库的选择存储于一个单独文件中，需要使用的脚本中通过require语句包含这个文件即可，即有利于程序维护也避免代码冗余。
*
# 执行SQL语句
mixed mysqli_query(mysqli_link, string query[, int resultmode])
link 为必选参数 mysqli_connect返回的连接标识
query 必选参数 只要执行的查询语句
resultmode 可选参数 取值有MYSQLI_USE_RESULT和MYSQL_STORE_RESULT,MYSQLI_STORE_RESULT默认，大量返回数据则使用MYSQLI_USE_RESULT
select 查询成功返回查询结果集 否则返回false；update insert delete则执行成功返回true 失败返回false
# 将结果集返回到数组中
array mysqli_fetch_array(resource result[, int result_type])
result 			资源类的参数 传入的是由mysqli_query函数返回的数据执行。
result_type		可选项 设置结果集数组的表述方式
				MYSQLI_ASSOC	关联数组 数组下标由表的字段组成
				MYSQLI_NUM		索引数组 数组下标由数组组成
				MYSQLI_BOTH		返回一个同时包含关联和数字索引的数组 默认值
*
mysqli_fetch_array返回的字段名区分大小写
*
# 从结果集中获取一行作为对象
object mysqli_fetch_object(resource result)
使用$row->col_name获取数据
# 从结果集中获取一行作为枚举数组
mixed mysqli_fetch_row(resource result)
# 从结果集中获取一行作为关联数组
mixed mysqli_fetch_assoc(resource result)
# 获取查询结果集中的记录数组
int mysqli_num_rows(resource result)
# 释放内存
void mysqli_free_result(resource result);
# 关闭连接
bool mysqli_close(mysqli link)
# 连接和关闭MySQL服务器的最佳时机
MySQL服务器连接应该及时关闭，但并不是说每一次数据库操作后都需要立即关闭MySQL连接
## 管理MySQL数据库中的数据
# 添加数据
mysqli_query("insert table_name (col_name1, ...) values (val1, ...)")
# 编辑数据
mysqli_query("update table_name set col_name1 = val1, ... where condition")
# 删除数据
mysqli_query("delete from table_name where condition")

### PDO数据库抽象层
## 什么是PDO
PHP Data Object 支持的数据库包括MySQL Oracle常用书出具
PHP6中默认使用PDO
# 特点
数据库访问抽象层，作用是同一各种数据库的访问接口
通过一种轻型、清晰、方便的函数，统一各种不同RDBMS的共有特性
PDO扩展是模块化的，能够在运行时为数据库后端加载驱动宏程序
打开php.ini中的extension=pdo_<dbms_name>
## PDO连接数据库
$pdo = new PDO("<dbms_name>:host=<host>:<port>?dbname=<dbname>", <username>, <password>);
# DSN详解
Data Source Name，提供联结数据库需要的信息，包括3部分POD驱动名称（如mysql/sqlite等）:和驱动特定的语法
## PDO中执行SQL语句
# exec方法
int PDO::exec(string statement)
返回影响的行数
# query方法
PDOStatement PDO::query(string statement)
返回一个PDOStatemetn
# 预处理语句prepare和execute
PDOStatement PDO::prepare(string statement[, array driver_options])
bool PDO::execute([array input_parameters])
## PDO中获取结果集
# fetch方法
mixed PDOStatement::fetch([int fetch_style[, int cursor_orientation[, int cursor_offset]]])
fetch_style控制结果集返回形式
PDO::FETCH_ASSOC		关联数组
PDO::FETCH_NUM			索引数组
PDO::FETCH_BOTH			两种形式都有 默认
PDO::FETCH_OBJ			对象形式
PDO::FETCH_BOUND		布尔值的形式
PDO::FETCH_LAZY			关联数组、索引数组和对象数组 3种都有
cursor_orientation 		PDOStatement对象的一个滚动游标 用于获取指定一行
cursor_offset 			游标的偏移量
# fetchAll方法
array PDOStatement::fetchAll([int fetch_style[, int column_index])
# fetchColumn方法
string PDOStatement::fetchColumn([int column_number])
数字化行中列的索引值，从0开始，默认从第一行开始取值
## PDO中捕获SQL语句中的错误
# 默认模式-PDO:ERRMODE_SILENT
设置PDOStatement中的errorCode属性 需要手动检测代码错误
# 警告模式-PDO::ERRORMODE_WARNING
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING)
产生一个PHP警告，设置errorCode属性，除非明确检查错误，否则程序继续运行
# 异常模式-PDO:ERRORMODE_EXCEPTION
创建一个PDOException，并设置errorCode属性可以将执行代码封装到一个try catch语句块中，未捕获的异常将会导致脚本终端，并使用堆栈跟踪显示哪里出现的问题
## PDO中错误处理
# errorCode方法
用于获取再操作数据库句柄时所发生的错误代码
int PDOStatement::errorCode(void)
返回一个SQLSTATE由5个数字和字母组成的代码
# errorInfo方法
用于获取操作数据库句柄时发生的错误信息
返回一个数组，包含了相关的错误信息
## PDO中事务处理
1.开启事务
beginTransaction
关闭自动提交 直到事务提交或回滚后才恢复
2.提交事务
commit
提交事务 成功返回true 否则false
3.事务回滚
rollback
执行事务回滚操作
## PDO中存储过程
call 

## PHP异常
# 基本使用
当抛出异常，其后代码不会执行，会尝试查找匹配catch代码块
如果没有捕获，也没有使用set_exception_handler()做相应处理，将发生严重异常，并输出UncaughtException错误消息
# Try Throw Catch
1.Try 使用异常的函数应该处于try代码块内
2.Throw 如果触发异常 一个throw应该对应至少一个catch
3.Catch catch代码块会捕获异常 并创建一个包含异常信息的对象
# 创建自定义的Exception类
class CustomException extends Exception {
	
}
# 抛出多个异常
使用多个catch
# 重新抛出异常
只是记录 并不处理
# 设置顶层异常处理器
function myExceptionHandler($exception) {
	// 
}
set_exception_handler('myExceptionHandler');
捕获未处理的异常

### Laravel 
************************** 5.8 ***********************
## 配置Laravel
# 初始化配置
1.公共目录
public目录下的index.php作为前端控制器（应用的唯一入口），所有HTTP请求都会通过该文件进入应用
2.配置文件
config目录下包含所有配置
3.目录权限
需要配置一些目录（如storage和boostrap/cache）的读写权限给Web服务器指定用户
4.应用key
需要先将.env.example复制一份作为.env,如果使用命令创建的应用已经包含则无需这两步操作
php artisan key:generate生成应用key，用于保护用户Session和其他加密数据的安全性
5.更多配置
可以看看config/app.php文件，包含一些基于应用可能需要改变的配置，比如locate和timezone作为本地化
# 环境配置
基于应用运行环境不同设置不同的配置值能够给开发带来极大的方便，比如通常在本地和线上环境配置不同的缓存驱动。
使用PHP扩展库DotEnv来实现这一功能。
不要将.env提交到版本控制系统中，一方面不同环境不同配置，一方面.env文件包含有敏感信息，需要小心对待。
可以将一些环境配置值以占位符的方式放在.env.example中，辅助其他开发者了解应用需要配置的环境变量
可以通过创建.env.testing文件，在执行PHPUnit或带有--env=testing选项的Artisan命令时覆盖.env中的配置值
.env文件所有变量都可以被外部环境变量覆盖，例如服务器级别或系统级别的环境变量
.env文件中所有变量都会被解析为字符串 因此有一些保留值作为转换
比如
true(string) -> true(boolean)
empty(string) -> ""(string)
null(string) -> null(null)
需要包含空格的字符串使用双引号包括整个字符串
获取环境变量配置值
env(<key>, <default>)
判断应用环境
App::environment()
访问配置值
config(<key>)
缓存配置文件
php artisan config:cache 将所有配置文件的配置缓存到单个文件中 从而被框架快速加载
维护模式
php artisan down
## 目录结构
# 简介
可以自行组织目录结构，只要Composer可以自动载入即可
# 根目录
1.App目录
包含应用的核心代码，不是框架的核心代码（框架的核心代码在/vendor/laravel/framework）里。为应用编写的绝大多数代码应该在这里。基于Composer做PHP组件开发的话，只有入口性的代码
2.Bootstrap目录
包含少量文件，app.php用于框架的启动和自动载入配置，还有一个cache文件夹，里面包含框架为提升性能所生成的文件，比如路由和服务缓存文件。
3.Config目录
包含了应用所有的配置文件。
4.Database目录
包含了数据库迁移文件以及填充文件，如果使用SQLite则可以作为SQLite数据库存放目录
5.Public目录
包含了应用入口文件index.php和前端资源文件，该目录也应该是Apache或Nginx等Web服务器所指向的应用根目录。优点在于隔离应用核心文件
6.Resources目录
resources目录包含了应用视图和未编译的原生前端资源文件（LESS、SASS、Javascript），以及本地化语言文件
7.Routes目录
包含了应用定义的所有路由，默认提供了四个路由文件用于不同的入口使用
web.php
包含的路由通过RouteServiceProvider引入，都被约束在web中间件组中，支持Session、CSRF保护以及Cookie加密功能，如果用于无需提供无状态的、RESTful风格的API，那么路由基本都要定义在web.php文件中
api.php
包含的路由通过RouteServiceProvider引入，都被约束在api中间件组中，支持频率限制功能，这些路由是无状态的，请求通过这些路由进入应用需要通过token进行验证并不能访问Session状态
console.php
用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行IO方法进行交互，尽管文件并不定义HTTP路由，但定义了基于控制台的应用入口
channels.php
用于注册应用支持的所有时间广播频道
8.Storage目录
包含编译后的Blade模板，基于文件的Session、文件缓存，以及其他由框架生成的文件，细分为app、framework和logs子目录，app目录用于存放应用生成的文件，framework目录用于存放框架生成的文件和缓存，logs存放应用的日志文件
storage/app/public目录用于存储用户生成的文件，比如可以被公开访问的用户头像，需要在应用根目录的public下生成一个软链接storage指向这个目录 php artisan storage:link
9.Tests目录
包含自动化测试文件，其中默认提供一个开箱即用的PHPUnit示例，每个测试类都要以Test开头，可以通过phpunit或php verdor/bin/phpunit命令来运行测试
10.Vendor目录
包含了应用所有通过Composer加载的依赖
# App目录
应用的核心代码位于app目录下，默认情况下，目录位于命名空间App下，并且被Composer通过PSR-4自动载入标准自动加载
app目录下包含多个子目录 如Console、Http、Providers等。Console和Http目录提供了进入应用核心的API、HTTP协议和CLI是和应用进行交互的两种机制，但实际上并不包含逻辑。换句话说，只是向应用发送命令的方式，Console目录包含了所有编写的Artisan命令，Http目录包含了控制器、中间件和请求等。
其他目录会在Artisan命令make生成相应类的时候自动生成到app目录下
php artisan list make 查看所有artisan生成命令
1.Broadcasting目录
包含了应用所需的所有广播频道类，通过make:channel命令生成。默认不存在。
2.Console目录
包含所有自定义的Artisan命令，通过make:command命令生成。还有Console/Kernel类，可以注册自定义的Artisan命令以及定义调度任务。
3.Events目录
存放事件类，默认不存在。通过event:generate和make:event创建，事件类用于告知应用其他部分某个事件发生情况并提供灵活的、解耦的处理机制。
4.Exceptions目录
包含应用的异常处理器，同时还是处理应用抛出的任何异常的好地方，如果想要自定义异常如何记录和渲染，需要编辑该目录下的Handler类
5.Http目录
包含了控制器、中间件和表单请求等，几乎所有通过Web进入应用的请求处理都可以在此进行
6.Jobs目录
用于存放队列任务，应用中的任务可以被推送到队列，也可以在当前请求生命周期内同步执行。同步执行的任务有时也被看做命令，因为实现了命令模式。默认不存在,make:job创建
7.Listeners目录
包含处理事件的类（事件监听器），接受一个事件并提供对该事件发生后的响应逻辑。默认不存在 event:generate和make:listener创建
8.Mail目录
包含应用所有邮件相关类，可以封装构建邮件所需的所有业务逻辑 Mail::send发送 默认不存在make:mail创建
9.Notifications目录
包含应用发送的所有通知，比如事件发生通知，通知功能将通知发送和通知驱动解耦，默认不存在，make:notification命令
10.Policies目录
包含应用所有的授权策略类，策略用于判断某个用户是否有权限去访问指定资源 默认不存在 make:prolicy
11.Providers目录
包含应用的所有服务器提供者，在应用启动过程中绑定服务到容器、注册事件以及执行其他任务为即将到来的请求处理做好准备工作
12.Rules目录
包含应用的自定义校验规则对象，用于在单个对象中封装复杂的验证逻辑 默认不存在 make:rule

### 核心
## 请求的生命周期
# 简介
# 生命周期概览
1.第一件事
所有请求入口都是public/index.php文件，所有请求都会被web服务器(Apache/Nginx)导向这个文件。index.php文件包含的代码不多，但是，这是加载框架其他部分的起点。
index.php文件载入Composer生成的自动加载设置，然后从bootstrap/app.php脚本获取Laravel应用实例，Laravel第一个动作就是创建服务容器实例
2.HTTP/Console内核
然后，请求被发送到HTTP内核或Console内核（分别用于处理Web请求和Artisan命令），取决于进入应用的请求类型。这两个内核是所有请求都要经过的中央处理器。
app/Http/Kernel.php作为HTTP内核。继承自Illuminate\Foundation\Http\Kernel类，定义了一个bootstrappers数组，这个数组中的类在请求被执行前裕兴，配置错误处理、日志、检测应用环境以及其他在请求被处理前需要执行的任务
HTTP内核还定义了一系列所有请求在处理前需要经过的HTTP中间件，这些中间件处理HTTP会话的读写、判断应用是否处理维护模式、验证CSRF令牌等等
HTTP内核的handle方法签名相当简单，获取一个request，返回一个response，可以把内核想象坐一个代表整个应用的黑盒，输入HTTP请求，返回HTTP响应。
3.服务提供者
内核启动过程中最重要的动作之一就是为应用载入服务提供者，应用的所有服务提供者都被配置在config/app.php配置文件的providers数组中。首先，所有提供者的register方法被调用，被注册后，所有boot方法被调用
服务提供者负责启动框架的所有各种各样的组件，比如数据库、队列、验证器以及路由组件等。
4.分发请求
一旦应用被启动并且所有服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，通过运行所有路由指定的中间件。
# 聚集服务提供者
服务提供者是启动Laravel应用中最关键的部分，应用实例被创建后，服务提供者被注册，请求被交给启动后的应用进行处理。
应用默认的服务提供者存放在app/Providers目录下。
默认AppServiceProvider是空的，这是添加自定义启动和服务容器绑定的最佳位置。
## 服务容器
# 简介
服务容器是一个用于管理依赖和执行依赖注入的强大工具，依赖注入本质是通过构造函数或setter方法将类依赖注入到类中。
# 绑定
1.绑定基础
几乎所有的服务容器都是在服务提供者中完成的
如果一个类没有基于任何接口那么就没有必要将其绑定到容器，会根据PHP的反射服务自动解析出具体的对象
2.简单的绑定
服务提供者中，可以通过$this->app变量访问容器，然后使用bind方法注册一个绑定，该方法需要两个参数，第一个参数是想要注册的类名或接口名称，第二个蚕食是返回类的实例的闭包
$this->app->bind(<>, function($app) {
	return <>;
}); 
3.绑定一个单例
使用singleton方法代替bind方法
$this->app->bind(<>, function($app) {
	return <>;
});
4.绑定实例
intance方法 绑定一个已存在的对象实例到容器，随后调用容器将总是返回给定的实例
$this->app->instance(<>, <>)
5.绑定原始值
可能有一个接收注入类的类，同时需要注入一个原生的数值比如整数，可以结合上下文轻松注入这个类需要的任何值
$this->app->when('<>')->needs('$variableName')->give($value);
6.绑定接口到实现
服务容器的一个非常强大的功能就是其绑定接口到实现，比如一个EventPusher接口以及其实现类RedisEventPusher，可以将这个实现类注册到容器上。
$this->app->bind('EventPusher', 'RedisEventPusher')
告诉容器当一个类需要EventPusher的实现时将注入RedisEventPusher，可以在构造器或者任何其他通过服务容器注入依赖的地方进行EventPusher接口的依赖注入
7.上下文绑定
可能有两个类使用同一个接口，希望不同类注入不同实现。
$this->app->when(PhotoController::class)->needs(Filesystem::class)->give(function () {
	return Storage::disk('local');
});
$this->app->when(VideoController::class)->needs(Filesystem::class)->give(function () {
	return Storage::disk('s3');
});
8.标签
少数情况下，需要解析特定分类下的所有绑定，在注册完之后，通过tag方法分配标签
$this->app->bind('p1', function() {
	return <>;
});
$this->app->bind('p2', function() {
	return <>;
});
$this->app->tag(['p1', 'p2'], 't1');
通过tagged方法解析标签绑定
$app->tagged('t1');
9.扩展绑定
extend方法允许对解析服务进行修改，extend方法接受一个闭包来返回修改后的服务
$this->app->extend(Service::class, function($service) {
	return new NewService($service);
});
# 解析
1.make方法
有很多方法可以从容器中解析对象，首先，make方法，接受想要解析的类名或接口名作为参数
$xxx = $this->app->make('<interface or class>')
如果所在代码位置访问不了$app变量，可以使用辅助函数resolve
$api = resolve('<>');
某些类的依赖不能通过容器来解析，可以通过关联数组方式将其传递到makeWith方法来注入
$api = $this->app->makeWith('<>', [key => value])
2.自动注入
最常用的通过在类的构造函数中对依赖进行类型提示来从容器中解析对象，控制器、事件监听器、队列任务、中间件等都是通过这种方式。
容器会自动为其解析类注入依赖。
# 容器事件
服务容器在每一次解析对象时都会触发一个事件，可以用resolving方法监听该事件。
$this->app->resolving(function($object, $app) {
	// 所有容器事件处理代码
});
$this->app->resolving(xxx::class, function($object, $app) {
	// 指定类的容器事件处理代码
});
# PSR-11
服务容器实现了PSR-11接口，可以通过类型提示PSR-11容器接口来获取Laravel容器的实例；


## 服务提供者
# 简介
是Laravel应用启动的中心，核心服务都是通过服务提供者启动。
这里的启动包括注册服务，注册服务容器绑定，事件监听器，中间件，路由
自带的config/app.php的providers数组中是应用所要加载的所有服务提供者类，启动很多是延迟脚在的，不会每次请求都加载，只有真正需要时加载
# 编写服务提供者
所有服务提供者都继承自Illuminate\Support\ServiceProvider类，大部分服务提供者都包含两个方法，register和boot。register方法中，唯一要做的就是绑定服务到容器，不要尝试在这个方法中注册事件监听器，路由或其他任何功能。
php artisan make:provider XXXServiceProvider // 生成服务提供者
1.register方法
此方法应该只用于绑定服务到服务容器。
2.bindings和singletons属性
如果服务提供者注册了很多简单的绑定，可以使用bindings和singletons属性代替手动注册方法以简化代码
public $bindlings = [
	XXX::class => XXXImpl::class
]
public $singletons = [
	XXX::class => XXXImpl:class
]
3.boot方法
在服务提供者中注册视图Composer，需要使用boot方法。此方法在所有服务提供者被注册以后才会被调用
# 注册服务提供者
所有服务提供者都是通过配置文件config/app.php中进行注册，包含列出所有服务提供者名字的providers数组。默认只列出所有核心服务提供者。
要注册自定义的服务提供者，需要将其追加到该数组中
'provirder' => [
	XXXServiceProvider
]
# 延迟加载服务提供者
如果自定义的服务提供者中只注册绑定，可以选择延迟加载该绑定的服务。
Laravel编译并保存所有延迟服务提供者的服务和类名。
想要延迟加载提供者，需要实现\Illuminate\Contracts\Supports\DeferrableProvider接口并定义一个provides方法，会返回通过服务提供者注册的服务容器绑定
class XXXSerivce extends ServiceProvider implements DeferrableProvider {

	public void provides() {
		return [
			XXX::class
		]
	}
}

## 门面(Facades)
# 简介
门面为应用服务容器中的绑定类提供了一个静态接口，内置了很多门面。门面作为服务容器中底层类的静态代理，在维护是能够提供更加易于测试、灵活、优雅的语法
所有门面定义在Illuminate\Support\Facades命名空间下
外观模式(门面模式)
隐藏系统的复杂性，并向客户端提供了可以访问系统的接口。属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或使用
比如
class CPU {
	public boot() {
	
	}
	public shutdown() {
	
	}
}
class Memory {
	public boot() {
	
	}
	public shutdown() {
	
	}
}
class Disk {
	public boot() {
	
	}
	public shutdown() {
	
	}
}
class Computer {
	public __construct(CPU $cpu, Memory $memory, Disk $disk) {
		$this->cpu = $cpu;
		$this->memory = $memory;
		$this->disk = $disk;
	}
	
	public boot() {
		echo '开始启动';
		$this->cpu->boot();
		$this->meomry->boot();
		$this->disk->boot();
		echo '启动完成';
	}
	public shutdown() {
		echo '关机开始';
		$this->cpu->shutdown();
		$this->memory->shutdown();
		$this->disk->shutdown();
		echo '关机结束';
	}
}
将CPU，memory，disk的接口集成至computer中，对外隐藏了子系统的接口，只需要调用Computer对外接口即可。
# 何时使用门面
门面有需要注意的地方，最主要的危险是类范围蠕变，由于门面好用且无需注入。在单个类中使用过多门面，会导致类越来越大。使用依赖注入则会让此类问题缓解。
1.门面 vs 依赖注入
2.门面 vs 辅助函数
# 门面工作原理
Laravel中，门面就是一个为容器中对象提供访问方式的类，该机制原理由Facade类实现。
门面类只需要实现一个方法 getFacadeAccessor，定义了从容器中解析什么，然后使用魔术方法__callStatic()从门面中调用解析对象
# 实时门面
使用实时门面，可以将应用中任意类当做门面来使用。
<class implements Facades>::<method_name>()
使用Facade接口的实现类作为前缀即可引入依赖，无需在方法参数列表中显式导入Facade实例

## 契约
是指框架提供的一系列定义核心服务的接口。
每个契约都有框架提供的相应实现。
所有Laravel契约都有其对应的GitHub库，为所有有效的契约提供了快速入门指南，同时也可以作为独立、解耦的包被包开发者使用
# 契约 vs 门面
门面为Laravel服务的使用提供了便携方式--无需从服务容器中类型提示和契约解析即可直接通过静态门面调用
不同于门面无需在构造器中进行类型提示，契约允许在类中定义显式的依赖。
# 何时使用契约
大多数情况下使用契约或者门面取决于个人或团队喜好。


### 基础组件
## 路由
# 路由入门
最基本的Laravel路由只接收一个URI和一个闭包，并以此为基础提供一个非常简单优雅的路由定义方法
Route::get('<path>', function() {
	return '<string or template>';
});
# 默认路由文件
所有Laravel路由都定义在位于routes目录下的路由文件中，通过框架自动加载，相应逻辑位于app/Providers/RouteServiceProvider类。routes/web.php文件定义了Web界面的路由，这些路由被分配到web中间件组，从而可以使用Session和CSRF保护等功能。routes/api.php中的路由是无状态的，分配到api中间件组中。
大多数应用中，都是从routes/web.php文件开始定义路由，定义在routes/web.php中的路由可以通过在浏览器中输入对应URL进行访问。
而routes/apid中的路由被嵌套在一个路由群组中，所有路由自动添加/api前缀，无需手动添加。可以通过编译app/Providers/RouteServiceProvider类来修改路由前缀以及其他路由群组选项。
# 有效的路由方法
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::delete($uri, $callback);
Route::patch($uri, $callback);
Route::options($uri, $callback);
有时还还需要注册一个路由响应多种HTTP请求动作——可以使用match()方法来实现，或者，可以使用any()方法注册一个路由来响应所有HTTP请求动作
Route::match($method_arr, $uri, $callback);
Route::any($uri, $callback);
web.php中的路由都默认收到CSRF保护检查，而api.php中的则没有限制
# CSRF保护
web.php路有文件中的所有请求方式为PUT/POST/DELETE的路由对应的HTML表单都必须包含一个CSRF令牌字段，否则请求将会被拒绝
如果不在VerifyCsrfToken中间件中排除对它的检查（也不安全），那么就需要在表单提交中带上csrf_token字段
csrf_token() 生成一个csrf_token字符串
csrf_field() 生成一个隐藏的input标签，value为csrf_token字符串
# 路由重定向
需要定义一个重定向的URI路由，使用Route::redirect方法
Route::redirect($source_uri, $destination_uri[, $status_code])
默认情况下，返回302状态码，可以添加一个可选的参数指定状态码
Route::permanentRedirect($source_uri, $destination_uri) // 指定返回301状态码
# 路由视图
如果需要返回一个视图，可以使用Route::view方法和redirect方法类似。
Route::view($uri, $view_name[, $params_arr]) // 相当于Route::get($uri, function() { return view($view_name[, $params_arr])});
第三个参数作为视图的渲染数据
# 路由参数
1.必选参数
Route::get('xxx/{param}', function($param) {
	return $param;
});
按照位置给变量赋值
2.可选参数
在path的大括号中添加?并给方法参数赋默认值
Route::get('xxx/{param?}', function($param = null) {
	
});
3.正则约束
Route::get('xxx/{param}', function($param) {
	return $param;
})->where('param', '<pattern>')
Route::get('xxx/{param}', function($param) {
	return $param;
})->where(['param', '<pattern>', ...])
使用正则表达式还有一个好处就是避免了user/{id}和user{name}的混淆
4.全局约束
如果想要路由参数在全局范围内被给定正则表达式约束，可以使用pattern方法 需要在RouteServieProvider类的boot方法中定义这种约束模式
class RouteServiceProvider extends ServiceProvider {
	public boot() {
		Route::pattern([]);
		parent::boot();
	}
}
一旦模式被应用，将自动应用到所有包含该参数名的路由中
5.编码
Laravel路由组件支持除/之外的所有字符，如果要在占位符中使用/需要通过where条件正则表达式显示允许
Route::get($uri, $callback)->where($param, '.*');
# 命名路由
命名路由为生成URL或重定向提供了方便，在路由定义之后使用name方法链的方式来定义该路由的名称
Route::get($uri, $callback)->name($router_name)
然后可以简化使用重定向
Route::get($uri, function() {
	return redirect()->route($router_name);
});
Route::get($uri, function($id) {
	$url = route($router_name, [$params_arr]);
	return $url;
})->name($router_name);
# 检查当前路由
想要判断当前请求是否被路由到给定命名路由，可以使用Router实例上的named方法
$request->route()->named($router_name)
判断当前请求是否被路由到命名为$router_name的路由上
# 路由分组
目的是可以在多个路由中共享相同的路由属性，比如中间件和命名空间等。共享属性以数组的形式作为第一个参数被传递给Route::group方法
嵌套的分组会尝试智能的将属性合并到父分组中，中间件和where条件会直接被合并，而路由命名、命名空间，以及路由前缀会被附加到父组件对应的属性之后，命名空间分隔符和URI的斜杠会被自动添加到合适的位置
1.中间件
要给某个路由分组中定义的所有路由分配中间件，可以在定义分组之前使用middleware方法，中间件会按照数组中定义的顺序依次执行
Route::middleware(['first', 'second'])->group(function() {
	Route::get($uri1, $callback1);
	Route::get($uri2, $callback2);
})
2.命名空间
使用namespace方法分配同一个PHP命名空间给该分组下的多个控制器。
Route::namespace('Admin', function() {
	// 使用 App\Http\Controllers\Admin 命名空间下的Controller
});
3.子域名路由
还可以被用于处理子域名路由，子域名可以像URI一样被分配给路由参数，从而允许捕获子域名的部分用于子路由或控制器 使用domain方法
Route::domain('{account}.blog.dev')->group(function() {
	Route::get('user/{id}', function($account, $id) {
		// http://test.blog.dev/user/1 $account => test $id => 1
	}
});
4.路由前缀
prefix方法为分组中的每个路由添加一个指定的URI前缀
Route::prefix('admin')->group(function() {
	Route::get('users', function() {
		// /admin/users 访问
	}
});
5.路由名称前缀
name方法为分组中的路由name增加前缀
Route::name('admin')->group(function() {
	Route::get('users', function() {
		
	})->name('users'); // 此路由命名为admin.users
})
# 路由模型绑定
php artisan make:migration create_table_user --create=user
上一个命令在database/migrations目录下创建<日期>_create_table_user.php文件 添加
public function up() {
	Schema::create('user', function (Blueprint $table) {
		$table->increment('id');
		$table->string('name');
        $table->string('email')->unique();
        $table->string('password');
        $table->rememberToken();
        $table->timestamps();
	});
}
再使用
php artisan migrate 创建数据库表
可能报1071 Specified key was too long; max key length is 1000 bytes错误
需要将MySQL的默认字符街变为utfmb4 然后在AppServiceProvider的boot()方法中添加
Schema::defaultStringLength(191);

注入模型ID到路由或控制器动作时，通常需要查询数据库才能获取相应的模型数据。路由模型绑定让注入模型实例到路由变得简单
1.隐式绑定
会自动解析定义在路由或控制器动作（变量名匹配路由片段）中的Eloquent模型类型声明
Route::get('users/{id}', function(App\Models\User $user) {
	return $user->email;
});
此时会自动将请求传入的UserId对应的数据模型注入到$user中
2.自定义键名
如果使用的列名不是id则需要覆盖Model的getRouteKeyName()返回需要查询的列名
getRouteKeyName() 默认返回的是主键名
3.显式绑定
在RouteServiceProvider的boot方法中使用Route的model方法绑定数据模型到指定的名称中
public function boot() {
	parent::boot();
	Route::model('user_model', App\Models\User::class);
}
Route::get('users/{user_model}', function($user) {
	// 此时也会注入对应的数据
});
如果匹配的数据模型不存在则返回404
4.自定义解析逻辑
在RouteSerivceProvider的boot方法中使用Route::bind方法，传递到bind方法的闭包会获取到URI请求参数中的值，并且返回想要在该路由中注入的类的实例
# 兜底路由
Route::fallback方法可以定义一个当所有其他路由都为匹配时所执行的路由，通常未处理请求会通过Laravel的异常处理器渲染一个404页面。定义fallback路由时，所有web中间件组的路由都会以此兜底
# 频率限制
Laravel自带一个中间件用于限制对应用路由的访问频率。throttle中间件接收两个参数用于判断给定时间内的最大请求次数
Route::middle('auth:api', 'throttle:60:1')->group(function() {

});
动态频率限制
Route::middleware('auth:api', 'throttle.rate_limit,1')->group(function() {
	Route:get($uri, $callback);
});
对包含rate_limit的模型访问添加限制
# 表单方法伪造
_method 字段
或
@method('PUT')
# 访问当前路由
可以使用Route门面上的current/currentRouteName/currentRouteAction方法来访问处理当前输入请求的路由信息

## 中间件
中间件为过滤进入应用的HTTP请求提供了一套便利的机制。
Laravel框架自带了一些中间件，包括认证、CSRF保护中间件等，位于App/Http/Middleware目录下
# 定义中间件
php artisan make:middleware CheckToken
class CheckToken 
{
	public function handle($request, Closure $next) 
	{
		if ($request->input('token') != 'xxx') {
			return redirect()->to('xxxx');
		}
		return $next.handle($request);
	}
}
请求之前的中间件
// 拦截逻辑
return $next->handle($request);
请求之后的中间件
$response = $next->handle($request);
// 拦截逻辑
return $response;
# 注册中间件
中间件分3类，全局中间件、中间件组和指定路由中间件
1.全局中间件
在每一个请求中都被执行，需要将全局中间件添加到app/Http/Kernel.php的数组属性$middleware中
除了必须，否则很少将业务级别的中间件放到全局中间件中
2.分配中间件到指定路由
app/Http/Kernel.php文件中分配给中间件一个key，默认情况下，该类的$routedMiddleware属性包含了Laravel自带的中间件，添加自定的放到最后并分配一个key
然后在Route::xxx()->middleware($route_middleware_key)
3.可以将多个中间件分配到一个键名下，方便为路由配置中间件。使用App/Http/Kernel.php中的middlewareGroups属性
Laravel已经定义了web和api两个中间件组，并在RouteServiceProvider中为web.php和api.php分配这两个中间件组。
$middlewareGroup = [
	'customMiddlewareGroup' => [
		'<middleware::class or middleware_alias>',
	],
]
注册方式
Route::group(['middleware'=>['middle_alias']], function() {
	Route::get($uri, $callback);
});
或者
Route::middleware('middleware_alias')->group(function() {
	Route:get($uri, $callback);
});
4.中间件排序
通过app/Http/Kernel.php中的$middlewarePriority属性来指定优先级
# 中间件参数
还可以接受额外的自定义参数，在$next参数之后传入中间件
class CheckRole
{
	public function handle($request, $next, $role) 
	{
		
	}
}
传入$role需要在middleware('checkRole:1') 此时$role = 1
# 终端中间件
有时候中间件可能需要在HTTP响应发送到浏览器之后做一些工作，需要定义一个终端中间件并添加terminate方法到中间件中
public function terminate($request, $response) {
	// 后台工作
}
接受街球和响应作为参数，定义了终端中间件后需要添加到Kernel.php文件的全局中间件列表中
调用terminate方法时，会从服务容器中取出一个该中间件的新实例，如果想要使用同一个，则需要使用singleton方法注册为单例

## CSRF保护
跨站请求伪造（CSRF）是一种通过伪装授权用户的请求来攻击授信网站的恶意漏洞。
Laravel通过自带的CSRF保护中间件避免被攻击。自动为每一个被应用管理的有效用户生成一个CSRF令牌，并存储到Session中。该令牌用于验证授权用户和发起请求者是否相同
任何时候在HTML表单中。都应该引入CSRF令牌字段，这样才能启动保护。@csrf可以生成包含CSRF令牌的隐藏字段
中间件组web的VerifyCsrfToken会自动为验证请求输入的token值和Session中保存的token值是否相同。如果没有传递csrf或者与session中的不同则报错
CSRF令牌 和 Javascript
可以让Javascript HTTP库自动为每个请求添加CSRF令牌 默认情况下 resources/js/bootstrap.js文件会将csrf.tokenmeta标签值注册到AxiosHTTP库中，没有则需要手动配置
# 排除指定URL不做CSRF安全校验
可以将需要排除的URL放到api.php中
也可以需要排除的中间件类中添加$except属性数组
# X-CSRF-Token
除了作为POST参数进行验证外，也可以通过设置X-CSRF-Token请求头来实现验证，VerifyCsrfToken中间件会检查X-CRSF-TOKEN请求头。
实现方式，先创建一个meta标签并将Crsf令牌保存到该meta标签中
<meta name="csrf-token" content="{{ csrf_token() }}">
然后在js库(以下为jQuery)中添加早所有请求头
$.ajaxSetup({
	headers: {
		'X-CSRF-TOKEN': $('meta[name="csrf-token"]).attr('content')
	}
})
# X-XSRF-Token
Laravel还会将CSRF令牌保存到名为XSRF-TOKEN的Cookie中，可以使用该Cookie值来设置X-CSRF-Token请求头。
有些JavaScript框架会自动执行上一步操作

## 控制器
组织管理相对复杂的业务逻辑处理，控制器用于将相关HTTP请求封装到一个类中进行处理，位于app/Http/Controllers中
# 控制器入门
1.定义控制器
php artisan make:controller UserController
class UserController extends Controller {
	public function show($id) {
		return view('user.profile', ['user' => User::findOrFail($id)]);
	}
}
Route::get('user/{id}', 'UserController@show'); // 使用UserController的show方法
在resource/views/user下创建profile.blade.php
{{ dd($user) }}
控制器类不一定继承自基类，但是，基类包含一些便利方法，比如middleware、validate和dispatch等
2.命名空间
web.php下的命名空间在RouteServiceProvider的mapWebRoutes()方法添加了基础的命名空间
->namespace($this->namespace) 代表app/Http/Controllers 只需要添加之后的即可使用
3.单一动作控制器
public function __invoke() 魔术方法
实现这个方法的控制器只处理一个动作，在Route中无需使用@指定调用的方法
需要快速创建单一动作控制器 使用
php artisan make:controller UserController --invokable
# 控制器中间件
可以
Route::get($uri, 'XController@method')->middleware('middleware_alias');
不过将中间件放在控制器构造函数中更加方便，使用middleware方法可以轻松分配中间件给该控制器，对所有控制器方法都有效。
public function __construct() {
	$this->middleware('');
	$this->middleware('')->only('method_name'); // 只在指定方法中使用中间件
	$this->middleware('')->except('method_name'); // 排除指定方法不使用中间件
	$this->middleware(function($request, $next) {
		return $next.handle($request);
	}); // 使用闭包匿名中间件
}
# 资源控制器
可以很边界的构建基于资源的RESTFul控制器。
php artisan make:controller XController --resource
会创建使用资源中可能会用到的大部分方法
再使用
Route::resource($uri, 'XController');
将一个资源控制器注册到一个资源路由上 这个路由包含了处理资源对应动作的多个路由
Route::reource([
	'photos' => 'PhotoController',
	'posts' => 'PostController',
])
使用数组可以一次性注册多个资源路由
资源控制器处理的动作
请求方式			URI路径				控制器方法				路由名称
GET					/posts				index					posts.index
GET					/posts/create		create					posts.create
POST				/posts				store					posts.store
GET					/posts/{posts}		show					posts.show
GET					/posts/{post}/edit	edit					post.edit
PUT/PATCH			/posts/{post}		update					posts.update
DELETE				/posts/{posts}		destory					posts.destroy
2.指定资源模型
php artisan make:controller PostController --resource --model=Post
不推荐这种模型绑定
3.伪造表单方法
<form method="post">
	@method('PUT')
</form>
4.部分资源路由
Route::resource('post', 'PostController', ['only' => ['show', 'index']]); // 只配置show和index的资源路由
Route::resource('post', 'PostController', ['except' => ['show', 'index']]); //　排除不配置show和index的资源路由
5.命名资源路由
Route::resource('post', 'PostController', ['names' => ['create' => 'posts.build']]); // 将create对应的路由名称改为posts.build 原来是posts.create
6.命名资源路由参数
Route::resource('post', 'PostController', ['parameters' => ['users' => 'admin_user']]); // 为show生成posts/{admin_user}的uri
7.本地化资源URI
在RouteServiceProvider的boot方法中添加Route::resourceVers方法 实现本地化
Route::resourceVers([
	'create' => 'xinzeng',
	'edit' => 'bianji',
]);
8.补充资源控制器
如果需要在默认资源路由之外添加额外的路由到资源控制器，应在调用Route::resource之前定义这些路由 否则可能出现覆盖
Route::get('posts/popular', 'PostController@method');
# 依赖注入
1.构造函数注入
可以在控制器的构造函数中注入任何依赖，会被自动解析并注入到控制器实例中
2.方法注入
可以在方法中进行依赖注入，也会自动解析
如果有路由参数则需要放在其他参数之后
# 路由缓存
不会作用于基于闭包的路由，必须使用控制器路由
php artisan route:cache
每次请求从缓存中读取路由，如果添加新路由需要重新生成路由缓存，则需要在项目部署阶段运行route:cache命令
清除路由缓存文件
php artisan route:clear

## HTTP请求
# 访问请求实例
class UserController extends Controller {
	public function store(Request $request) {
		$name = $request->input('name');
	}	
}
1.依赖注入和路由参数
如果还想在控制器方法中获取路由参数，只需要将路由参数置于其他依赖之后即可。
2、通过闭包访问请求
Route::get('/', function(Request $request) {

});
3.请求路径&方法
Request提供多个方法用于检测应用的HTTP请求
1)获取请求路径
$request->path() // 返回URI的path部分
$request->is(pattern) // URI的path部分是否匹配正则表达式
2)获取请求URL
$request.url() // 不包含查询字符串
$request.fullUrl() // 包含查询字符串
3)获取请求方法
$request.method()
$request.isMethod('method_name')
4.PSR-7请求
PSR-7标准指定了HTTP消息接口，包括请求和响应。
需要安装一些库，将典型的Laravel请求响应转换为兼容PSR-7接口
composer require symfony/psr-http-message-bridge
composer require zendframework/zend-diactoros
在注入是指定为Psr\Http\Message\ServerRequestInterface $request即可注入PSR-7标准的请求
# 请求字符串处理
在App/Http/Kernel中的全局中间件中引入了
TrimStrings 去除url字符串的空格
ConvertEmptyStringToNull 将空字符串转换为null
# 获取请求输入
1.获取所有输入值
$reqeust->all() 以数组形式获取所有输入值
2.获取单个输入值
$reqest->input('param_name'[, 'default_vaule'])
3.从查询字符串中获取输入
input()方法会从整个请求负载（包括查询字符串）中获取值，query则只会从查询字符串中获取数值
$request->query('param_name'[, 'default_value'])
不带参数的query方法则返回所有查询字符串的值
$request有两个属性对象存放参数值
query
request
query()方法从query中获取
post()方法从request中获取
input()方法从query和request中获取
4.通过动态属性获取输入
$name = $request->name;
实现原理是__get()魔术方法
5.获取JSON输入值
Content-Type: application/json 可以用input方法获取JSON数据
6.获取输入的部分数据
$request->only([])
$reqeust->except([])
7.判断请求参数是否存在
$requst.has([])
# 上一次请求
允许在两次请求之间保存上一次输入数据，检测校验数据失败后需要重新填充表单数据时很有用
1.将输入存储到session
$request->flash() // 将当前输入存放到一次性Session（即取出后立刻销毁）中，这样下次请求时上一次输入依然有效
$reqeust->flashOnly()
$request->flashExcept()
2.将输入存储到Session然后重定向
return redirect()->withInput()
return redirect()->withInput($reqeust.except())
return redirect()->withInput($reqeust.only())
3.取出上次请求数据
$request->old('')
old() 在blade模板中显示
# Cookie
Laravel框架创建的Cookie都经过加密并使用一个认证码进行签名
1.取出Cookie
$value = $request->cookie('name')
Cookie::get('name')
2.添加Cookie
return $response()->cookie(name, value, expire, path, domain, secure, httpOnly)
还可以使用Cookie门面将应用于附件的Cookie推送到输出响应队列，queue方法接受一个Cookie实例或者创建Cookie实例的必要参数，在响应发送到浏览器之前添加
Cookie::queue(Cookie::make())
Cookie::queue(name, value, expire, path..)'
3.生成Cookie实例
可以使用全局辅助函数cookie() 只有在添加到响应实例上才会发送到客户端
# 文件上传
1.获取上传的文件
使用Request实例提供file方法或者动态属性来访问上传文件
$file = $request->file('photo')
$file = $request->photo;
$requet->hasFile('photo')  // 是否包含文件
2.验证文件是否上传成功
$request->file('photo')->isValid()
3.文件路径 & 扩展名
UploadedFile类还提供了访问上传文件绝对路径和扩展名的方法
extension方法可以基于文件内容判断文件扩展名 可能会和客户端提供的扩展名不一致
$request->file('photo')->path()
$request->file('photo')->extension()
4.其他文件方法
1)保存上传的文件
需要配置某个文件系统 配置位于config/FileSystem.php
默认使用local配置存放上传文件，即本地文件系统。默认根目录是storage/app
public也是本地文件系统，不过存放的文件可以被公开访问，对应的根目录是storage/app/public 需要创建一个软连接
UploadedFile有一个store方法，会将上传的文件移动到相应的磁盘路径上，可以是本地文件系统的某个位置，也可以是云存储的路径
store接受一个文件保存的相对路径（相对于文件系统配置的根目录），该路径不需要包含文件名，系统会自动生成一个唯一ID作为文件名
store还接受一个可选的参数用于存储文件的磁盘名称作为第二个参数
如果不希望自动生成文件名 可以使用storeAs
storeAs(path, file_name, disk_name)
# 配置信任代理
应用运行在一个会中断TLS/SSL证书的负载均衡器之后，不会生成HTTPS链接，通常因为应用是从负载均衡器从80端口转发过来的流量。所以不知道如何生成加密链接。
使用APP/Http/Middleware/TrustProxies中间件。允许快速自定义需要被应用信任的负载均衡器或代理
$proxies属性列表中。
$headers属性列表还可以配置代理转发的带有请求来源信息的消息头
protected $proxies = [
	'',
	'',
]
2.信任所有代理
protected $proxies = "*";

## HTTP响应
# 创建响应
1.字符串 & 数组
所有路由和控制器处理完业务逻辑之后都会返回一个发送到用户浏览器的响应。提供多种不同方式来返回响应，最基本的响应是返回一个简单字符串，框架会自动转换为一个完整的HTTP响应
返回数组则会自动转换为一个JSON响应
2.Response对象
并不只是从路由动作简单返回字符串和属组，都会返回一个完整的Response实例或视图
返回一个完整的Response实例允许自定义响应的HTTP状态码和头信息，提供了一系列方法用于创建HTTP响应
return response('', 200)->header('', '');
3.添加响应头
return response($content)->header()->header()->header();
return response($content)->withHeaders([ , , ]);
4.添加Cookie到响应
return response($content)->coolie($name, $value, $expire, $path, $domain, $secure, $httpOnly)
也可以使用Cookie门面
Cookie::queue()
Cookie::queue()
return response($content);  // queue添加的cookie在响应返回前添加
5.cookie & 加密
默认被框架自动加密，如果需要不加密的cookie则修改app/Http/Middleware/EncryptCookies中间件
protected $except = []; // 需要排除的cookie
# 重定向
return redirect() // 重定向
return back()->withInput() // 返回上一个页面并带上参数
2.重定向到命名路由
redirect() 不带参数会返回一个Redirector实例，可以调用此实例上的方法。
return redirect()->route('')
return redirect()->route('', [])
3.重定向到控制器动作
retrurn redirect()->action('controller@method')
retrurn redirect()->action('controller@method', [])
4.重定向到外部域名
return redirect()->away('')
5.带一次性Session数据的重定向
return redirect('').with();
return redirect('').withInput();
# 其他响应类型
可以通过辅助函数response()方便生成其他类型的响应实例
无参数的response()会返回ResponseFactory契约的一个实现，提供了用于生成各种响应的方法，如视图响应，JSON响应，文件下载，流响应等等
1.视图响应
return response()->view('', $data, $status_code)->header('', '')
如果不需要传递自定义的状态码和头信息则使用
return view('')
2.JSON响应
return response()->json([])
如果想要返回JSONP响应可以在json方法之后调用withCallback方法
return response()->json([])->withCallback($request->input(''))
或者直接调用jsonp()方法
return response()->jsonp($request->input(''), [])
3.文件下载
download方法用于生成强制用户浏览器下载给定路径文件的想要，接受文件名作为第二个参数，决定用户下载文件的显示名称
return response()->download($pathToFile)
return response()->download($pathToFile, $name, $headers)
return response()->download($pathToFile)->deleteFileAfterSend(true)
(下载文件不能包含中文)
4.流式下载
将指定操作的字符串响应转换为可下载的响应而不用将操作内容写入磁盘，可以使用streamDownload方法，接收一个回调、文件名以及可选的头信息作为参数
return response()->streamDownload(function() {
	echo GitHub::api('repo')
		->contents()
		->readme('laravel', 'laravel')['contents'];
}, 'name', headers[]);
5.文件响应
return response()->file() 直接在用户浏览器中显示文件，而不需要下载，接收文件路径作为第一个参数，头信息数组作为第二个参数
# 响应宏
自定义的可以在多个路由和控制器中复用的响应，可以使用Response门面上的macro方法
Response::macro('caps', function($value) {
	return Response::make(strtoupper($value));
});
return response()->caps('bca');

## 视图
# 创建视图
视图文件存放在resource/views目录下
return view('greeting', ['name' => '123'])
返回resource/views/greeting.blade.php 并携带数据
使用.使用子目录和子文件
2.判断视图是否存在
View::exists('')
3.创建有效视图
return view()->first([], $data)
返回数组第一个有效的视图文件
return View::first([], $data)
# 传递数据到视图
return view($view_path, $data_arr)
可以简单通过数组将数据传递到视图
也可以使用
return view($view_path)->with($key, $value) 将独立的数据片段添加到视图
2.在视图间共享数据
需要在某个服务提供商的boot方法中使用View门面的share方法
pubic function boot() {
	View::share($key, $value);
}
# 视图Composer
是当视图被渲染时的回调函数或类方法，如果有一些数据在视图每次渲染时都做绑定，可以使用视图Composer将逻辑阻止到一个单独的地方
需要在某个服务提供商中注册视图Composer
View::composer('view_path', 'composer_path') 
不包含默认的视图Composer目录，需要自行创建任意目录作为Composer目录
2.添加Composer到多个视图
View::composer($view_arr, function or $composer_path)
View::composer('*', function or $composer_path) // 通配符 * 添加到所有视图
3.视图创建器
视图创建器与Composer类似，但是生效时间在视图实例化时
View::creator('', 'xxx/xxx/xxCreator')

## URL生成
提供来多个辅助函数来帮助在应用中生成URL
# 快速入门
1.生成URL
url辅助函数可用于为应用生成任意URL，并且生成的URL会自动使用当前请求的schema和host属性
$post = App\Post::find(1)
echo url("/posts/${post->id}")
2.访问当前URL
url->current() // 当前url 不包含请求字符串
url->full()	// 当前url 包含请求字符串
url->pervious() // 请求上一个完整的url
上述方法可以使用URL门面访问
URL::current()
URL::full()
URL::previous()
# 命名路由URL
route可用于生成指向命名路由的URL，命名路由允许生成不与实际URL耦合的URL，
route($route_name, $data_arr)
# 签名URL
将签名哈希追加到查询字符串后，以便验证URL在创建之后是否被篡改。
URL::signedRoute($route_name, $data);
URL::temporarySignedRoute($route_name, now->addMinutes(30), $data);   // 有过期时间的临时签名URL
2.验证签名路由请求
$request->hasValidSignature()
还可以分配ValidateSignture中间件到路由
先注册到Keynel.php的$routeMiddleware
在将中间件注册到路由上，验证不通过的请求自动返回403响应
# 控制器动作URL
$url = action('$controller_name@$method_name')
# 参数默认值
URL::defaults([])
设置默认值后 无需通过route辅助函数生成URL时指定传递参数

## Session
HTTP协议本身是无状态的，上下请求无任何关联，因此引入Session来存储用户请求信息以解决特定场景无状态导致的问题。通过简单API统一处理各种Session驱动，开箱即用包括Memcached、Redis和数据库
Laravel没有使用PHP的session机制
# 配置
Sessio配置在config/session.php中。默认使用file驱动，可能考虑memcached或redis获取更佳的Session性能。
'driver' => env('SESSION_DRIVER', 'file') 定义Session存储驱动
file 存储在storage/framework/session目录下
cookie 存储在加密的cookie中
database
memcached /redis 
array 存储在简单PHP数组中，多个请求之间是非持久化的
# 驱动预备知识
1.数据库
php aritsan session:table // 相当于使用php artisan make:migration create_session_table --create=session 再添加字段信息
php artisan migrate; // 建立表
2.Redis
需要使用Composer安装predis/predis依赖包，再在database配置文件中配置Redis连接。Session配置文件中，connection指定使用哪个Redis连接
需要修改
database.php
session.php
.env
# 使用Session
全局辅助函数session()，或者通过request实例，启动过程中会将Session数据设置到实例的Session属性中
$request->session() 获取session
session('key', 'default') 	// 获取session中的值
session(['key' => 'value])	// 设置session中的值
1.获取所有session数据
$request->session()->all()
$request->session()->has('') 	 	// 是否存在键 且值不为空
$request->session()->exists('')		// 是否存在键 不在乎值
# 存储数据
$request->session()->put($key, $value)
session([])
1.推送数据到数组session
$request->session()->push('', '')
2.获取&删除数据
$request->session()->pull($key, $default) // 获取数据并删除
# 一次性数据
$request->session()->flash($key, $value)
$request->session()->reflash($key) // 生存到下一次请求
$request->session()->keep([]) // 长期保存特定数据
# 删除数据
$request->session()->forget($key)
$request->session()->forget([$key, $key2])
$request->session()->reflush() // 一次清空所有数据
# 重新生成Session ID
$request->session()->regenerate()
# 添加自定义Session驱动
需要实现SessionHandlerInterface接口
class MongoSessionHandler implements SessionHandlerInterface
{
    public function open($savePath, $sessionName) {} // 基于file的存储系统 已经存在置为空即可
    public function close() {} // 同open
    public function read($sessionId) {} // 返回与给定$sessionId相匹配的Session数据的字符串版本 从驱动中获取
    public function write($sessionId, $data) {} // 将给定的$data写到存储系统中相应$sessionId
    public function destroy($sessionId) {} //删除
    public function gc($lifetime) {} // 销毁大于给定$lifetime的所有Session数据
}
注册驱动
在某个服务提供商的boot方法中使用Session门面的extend方法
Session::extend('', function($app) {
	return new XXXSessionHandler;
});

## 表单验证
控制器基类使用ValidateRequests trait提供便捷方法通过各种功能强大的验证规则来验证输入的HTTP请求
# 快速入门
1.定义路由
2.创建控制器
3.编写验证逻辑
$request->validate([
	'' => 'required|max:255'
]);
4.首次验证失败后终止后续验证
$request->validate([
	'' => 'bail|required|max:255'
]);
使用bail作为验证规则中的首规则
5.嵌套属性注意事项
$request->validate([
	'user.name' => 'bail|required|max:255'
]);
<input name="user[name]" >
6.显示验证错误信息
会被放入一次性Session中
session()->all()查看所有
总是存在一个$errors变量，是MessageBeg实例，通过web中间件组中的ShareErrorsFromSession绑定到视图
由于是一次性Session 如果别的地方用了 $errors就取不到
7.可选参数注意事项
添加nullable验证规则
8.AJAX请求&验证
不会产生重定向，而是产生一个JSON响应，附带422状态码
# 表单请求验证
1.创建表单请求
php artisan make:request StoreBlogPostRequest
在app/Http/Requests目录下生成StoreBlogPost
class StoreBlogPostRequest extends FormRequest {
	public function authorize() {
		return false;
	}
	public function rules() {
		return [
			'title': 'required',
			'body': 'required',
		];
	}
}
在控制器类中的控制方法注入这个Request替代基类Request
public function store(StoreBlogPostRequest $request) {
	$validated = $request->validated();
}
验证失败，重定向响应会生成并将用户退回上一个位置，错误信息也会被存储到一次性Session以便在视图中显示。如果是Ajax请求则会返回带有422状态码的JSON内容HTTP响应。
2.添加验证后钩子到表单请求
使用withValidator方法，接受完整的构造验证器，从而允许在验证规则执行前调用任何验证器方法
public function withValidator($validator) {
	$validator->after(function($validator) {
		if ($this->somethingElseIsValid()) {
			$validator->errors->add('field', 'error_info');
		}
	});
}
3.授权表单请求
表单请求类还有一个authorize方法，可以通过该方法检查认证用户是否有权限更新指定资源
public function authorize() {
	$comment = Comment::find($this->route('comment'));
	return $comment && $this->user()->can('update', $comment);
}
所有请求都继承自Laravel请求基类，可以使用user方法获取当前认证用户，还要注意上面$this->route('comment')方法的调用，赋予用户访问被调用路由URI参数的权限。
如果返回false，一个包含403状态码的HTTP响应会自动返回而且控制器方法将不会被执行
4.自定义错误消息
在FormRequest子类的messages方法中添加
public function messages() {
	reutrn [
		'title.required' => '标题必须',
		'body.required' => '内容必须',
	];
}
# 自定义验证属性
attributes方法 替换验证消息中的:attribute部分为自定义属性名
public function attributes() {
	return [
		'email' => 'email addres',
	];
}
# 手动创建验证器
不想使用请求实例上的validate方法，可以使用Validator门面手动创建一个验证器实例
$validator = Validator::make($request->all(), [
	'title' => 'required|unique:posts|max:255',
	'body' => 'required',
]);
if ($validator->fails()) {
	return redirect('post/create)->withErrors($validator)->withInput();
}
传递给make方法的第一个参数是需要验证的数据，第二个参数是要应用到数据上的验证规则
没有通过验证后，可以使用withErrors方法将错误存放到一次性session中，使用该方法时，$errors变量重定向后自动在视图间共享。withErrors方法接受一个验证器、或者MessageBeg或者PHP数组
2.自动重定向
调用Validator::make()->validate()方法
3.命名错误包
如果单页面有多个表单，可能需要命名错误的MessageBeg，从而允许为指定表单获取错误信息，只需要传递名称作为第二个参数给withErrors即可
redirect()->withErrors($validators, 'login')->withInput();
然后可以从$errors->login->first('email')访问错误信息
4.验证钩子之后
验证器允许在验证完成后添加回调
$validator = Validator::make()
$validator->after(function($validator)) {
	if ($this->somethingElseInvalid()) {
		$validator->errors->add('field', 'something wrong');
	}
}
# 处理错误信息
调用Validator实例上的errors方法之后，将会获取一个MessageBeg实例，包含多种处理错误信息的便利方法。在所有视图默认有效的$errors变量也是一个MessageBeg实例
1.获取某字段的第一条错误信息
$errors = $validator->errors();
$errors->first('email') // 如果不使用bail作为验证器链的第一个 则会验证所有 可能产生多个错误信息
2.获取指定字段的所有错误信息
foreach ($errors->get('email') as $message) {

}
如果是数组表单字段 可以使用*获取所有数组元素错误信息
foreach ($error->get('attachements.*') as $message) {

}
3.获取所有字段的错误信息
foreach ($errors->all() as $message()) {

}
4.判断是否含有某字段的错误信息
if ($errors->has('email')) {

}
# 自定义错误信息
传递自定义信息作为第三个参数给Validator:make方法
$messages = [
	'required' => 'The :attribute field is required!',
];
$validator = Validator:make($request->all(), [
	'title' => 'required|max:255',
	'body' => 'required',
], $message);
:attribute占位符将会被验证时实际的字段名替换，还可以使用其他占位符
:attribute
:size
:other
:min
:max
:values
2.给定属性指定自定义信息
$messages = [
	'email.required' => '邮箱地址不能为空!',
];
3.在语言文件中指定自定义消息
在resource/lang/<lang>/validation.php文件的custom数组中添加
'custom' => [
	'email' => [
		'required' => '邮箱地址不为空',
	]
]
4.在语言文件中指定自定义属性
resource/lang/<lang>/validation.php的attributes数组 (:attribute占位符使用)
'attributes' => [
	'email' => '邮箱地址',
],
5.语言文件中指定自定义值
可能需要将验证消息中的:value部分替换为自定义的表示值
$request->validate([
	'credit_card_number' => 'required_if:payment_type,cc'
])
payment_type为cc时需要credit_card_number
在resource/lang/<lang>/validation.php的values数组中修改
'values' => [
	'payment_type' => [
		'cc' => 'credit card,
	]
]
# 验证规则大全
Accepted
Active URL
After (Date)
After Or Equal（Date）
Alpha
Alpha Dash
Alpha Numeric
Array
Bail
Before (Date)
Before Or Equal（Date）
Between
Boolean
Confirmed
Date
Date Equals
Date Format
Different
Digits
Digits Between
Dimensions（图片文件）
Distinct
E-Mail
Exists (Database)
File
Filled
Greater Than
Greater Than Or Equal
Image (File)
In
In Array
Integer
IP Address
JSON
Less Than
Less Than Or Equal
Max
MIME Types (File)
MIME Type By File Extension
Min
Not In
Not Regex
Nullable
Numeric
Present
Regular Expression
Required
Required If
Required Unless
Required With
Required With All
Required Without
Required Without All
Same
Size
Starts With
String
Timezone
Unique (Database)
URL
UUID
************************
详情查看教程
************************
# 添加条件规则
1.存在时验证
'sometimes|required|email'
只有存在时才验证
2.复杂条件验证
$v->sometimes([], 'required', function($input) {
	return $input->games >= 100;
});
只有在函数返回true的情况下才添加验证规则到指定字段
# 验证数组输入
$validator = Validator::make($request->all(), [
	'photos.profile' => 'required|image',
]);
$validator = Validator::make($request->all(), [
	'persons.*.email' => 'required|image',
]);
# 自定义验证规则
1.使用Rule对象
php artisan make:rule Uppercase
class Uppercase extends Rule 
包含passes和message两个方法
passes方法接收属性值和名称 并基于属性值是否有效返回true或false
message方法用于验证失败后返回验证错误消息
使用trans()方法返回在语言文件中定义的错误信息
2.使用闭包
如果需要定义一次性的自定义规则，可以使用闭包替代规则对象 接收属性名、属性值以及验证失败后调用$fail回调
$validator = Validator::make($request->all(), [
	'title' => [
		function($attribute, $value, $fail) {
			if ($value === 'foo') {
				return $fail($atribute, ' is invalid.');
			}
		},
	]
]);
3.使用扩展
未看
## 异常错误处理
默认配置了错误和异常处理，在App/Exception/Handler类中触发异常并将响应返回给用户
# 配置
在config/app.php中的debug配置项控制浏览器显示的错误信息数量，默认通过.env文件中的环境变量APP_DEBUG进行设置
本地开发为true，生成环境应为false
# 异常处理器
所有异常都由类App/Exceptions/Handler处理，包含两个方法report和render
1.report方法
用于记录异常并将其发送给外部服务的BugSnag或Sentry，默认情况下，只是将异常传递给异常被记录的基类。可以按自己的需要记录异常并进行相关处理
2.全局日志上下文
如果当前用户ID可用，Laravel会自动将其添加到每一条异常日志信息中作为上下文数据。Handler类的context方法来定义自己的全局上下文数据
3.report辅助函数
可能需要报告一个异常并继续处理当前请求。辅助函数report允许使用异常处理器report方法快速报告一个异常而不会渲染错误页。
public function isValid($value) {
	try {
		// 
	} catch (Exception $e) {
		report($e);
		return false;
	}
}
4.通过类型忽略异常
异常处理器的dontReport属性包含一个不会被记录的异常类型数组，默认情况下，404错误异常不会被写到日志中
# render方法
负责将给定异常转化为发送给浏览器的HTTP响应，默认异常被传递给生成响应的基类
public function render($request, Exception $exception) {
	if ($exception instanceof CustomException) {
		return response()->view('errors.custom', [], 500) // 返回resource/views/error/custom.blade.php 没有数据 响应码为500
	}
}
1.可报告 & 可渲染的异常
可以在异常类中直接定义report和render方法
class CustomException extends Exception {
	public function report() {
	
	}
	public function render($request) {
	
	}
}
当异常存在这些方法时 框架自动调用此方法
# HTTP异常
abort辅助函数 会立即引发一个会被异常处理器渲染的异常
abort($status_code, $response_message)
可在任何时间点使用
1.自定义HTTP错误页面
在resource/views/errors/404.blade.php 文件 
php artisan vendor:publish --tag=laravel-errors // 发布Laravel的错误页面模板

## 日志
提供强大的日志服务来记录日志信息到文件、系统错误日志、甚至Slack
# 配置
config/logging.php配置，允许配置应用的日志通道。
默认情况下，使用stack通道来记录日志信息，stack通道用于聚合多个日志通道到单个通道。
1.配置通道名称
'stack' => [
    'driver' => 'stack',
    'name' => 'channel-name',
    'channels' => ['single', 'slack'],
],
2.有效通道驱动列表
stack	用于创建「多通道」通道的聚合器
single	基于单文件/路径的日志通道（StreamHandler）
daily	基于 RotatingFileHandler 的 Monolog 驱动，以天为维度对日志进行分隔
slack	基于 SlackWebhookHandler 的 Monolog 驱动
syslog	基于 SyslogHandler 的 Monolog 驱动
errorlog	基于 ErrorLogHandler 的 Monolog 驱动
monolog	Monolog 改成驱动，可以使用所有支持的 Monolog 处理器
custom	调用指定改成创建通道的驱动
3.配置single和daily通道
3个可选配置项
bubble、permission和locking 
bubble	表示消息在被处理后是否冒泡到其它通道	true
permission	日志文件权限	644
locking	在日志文件写入前尝试锁定它	false
4.配置slack通道
需要一个url配置项，需要和配置的Slack团队请求URL向匹配
# 构建日志堆栈
1.日志级别
emergency、alert、critical、error、warning、 notice、info 和 debug
记录日志
Log::debug('');
2.写入日志信息
Log::emergency($error);
Log::alert($error);
Log::critical($error);
Log::error($error);
Log::warning($error);
Log::notice($error);
Log::info($error);
Log::debug($error);
3.上下文信息
Log::info('', [])
上下文数据也会以数组形式传递给日志方法，然后和日志信息一起被格式化和显示
4.写入指定通道
Log::channel('')->info('', []);
# 高级Monolog通道自定义
未看

### 前端开发
## Blade模板引擎
Laravel提供的非常简单但功能强大的模板引擎 并不约束使用PHP原生代码，所有Blade视图最终都会被编译为原生PHP代码并缓存直到被修改 位于resources/views目录下
# 模板继承
1.定义布局
最大优点是模板继承和片段组合
<!-- 存放在 resources/views/layouts/app.blade.php -->

<html>
    <head>
        <title>应用名称 - @yield('title')</title>
    </head>
    <body>
        @section('sidebar')
            这里是侧边栏
        @show

        <div class="container">
            @yield('content')
        </div>
    </body>
</html>
上面包含HTML标记和@section@yield定义了一个内容片段
定义了布局，就需要生成继承此布局的子页面
2.继承布局
定义子页面，使用@extends指令来指定子页面锁继承的布局
使用@extends指令来指定子页面锁继承的布局继承一个Blade布局的视图可以使用@section指令注入内容到布局定义的内容片段中。
resources/views/child.blade.php
@extends('layouts.app')
@section('title', '')
@section('sidebar')
	@parent
	<p></p>
@endsection
@section('content')
	<p></p>
@endsection
@parent追加到子页面中，在渲染时会被布局中的内容替换
子页面中的@section配合@endsection使用 定义section
内容布局中的@section配合@show使用 显示子页面中的section
# 组件　& 插槽
组件和插槽给内容片段section和布局layout带来便利。
可复用组件
resources/views/alert.blade.php
<div class="alert alert-danger">
	{{ $slot }}
</div>
{{ $slot }}变量包含了想要注入组件的内容 要构建这个组件使用@component指令
@component('alert')
	<strong>Whoops!</strong> Something went wrong!
@endcompoent
为组件定义多个插槽，可以使用@slot指令命名
<div class="alert alert-danger">
	<div class="alert-title">{{ $title }}</div>
	{{ $slot }}
</div>
@component('alert')
	@slot('title')
		Forbidden
	@endslot
	<strong>Whoops!</strong> Something went wrong!
@endcompoent
没有@slot@endslot的内容都被渲染到{{ $slot }}中 指定名称的渲染到对应名称的变量中
1.传递额外数据到组件
@component('component_name', [key => value])
@endcomponent
2.组件别名
如果Blade组件存储在views的子目录中，可以使用
Blade::component('components.alert', 'alert')在服务提供商的boot方法中
组件设置别名后，可以使用@<component_name>的指令来指定组件
# 数据显示
使用
view('view_name', [key => value]) 
传递数据到视图
在blade文件中使用
{{ $key }} 来显示数据
{{}}语句已经经过PHP的htmlentities函数处理避免XSS攻击
可以使用任何PHP代码到{{}}中
1.显示原生数据
{{ !! $name !! }} 不经过htmlentities函数处理
2.渲染JSOn内容
1)使用json_encode()函数  
比较麻烦
2)使用@json指令
方便
3.HTML实体编码
Blade以及辅助函数e会对HTML实体进行双重编码 如果想要禁止双重编码 可以在AppServiceProvider的boot方法中调用
Blade::withoutDoubleEncoding();
# Blade & Javascript框架
@{{}}告诉Blade渲染引擎表达式应该保持原生格式不做改动 @会被去掉 {{ name }}保持不变不会被解析而是交给Javascript框架解析
1.@verbatim指令
如果有很大一部分篇幅显示Javascript变量，将这部分放在@verbatim中，就不必在每个{{}}前加上@
# 流程控制
1.If语句
@if (count($arr) === 1)
@elseif (count($arr) > 1)
@else
@endif

@unless(condition) // 除非
@isset(param) // 
@empty(param) //
2.认证指令
@auth
	// 用户已登录
@endauth
@guest
	// 用户未登录
@endguest
3.Section指令
@hasSection('') 判断某个section中是否有内容
4.Switch语句
@switch($i)
	@case(1)
		@break
	@case(2)
		@break
	@default
@endswitch
5.循环
$for ($i = 0; $i < 10; $i++)
@endfor
@foreach($arr as $item)
	
@endforeach
@forelse($users as $user)
	// 不为空的情况下
@empty
	// users为空或不存在的情况下
@endforelse
@while(true) 

@endwhile
配合
@break
@continue
使用
可以使用在
@continue($user->type === 1)
@break($user->number === 5)
直接做判断
6.$loop变量
在循环中可以使用$loop变量，提供了一些有用的变量，比如当前讯混的索引，以及是否是最后/最初的迭代
如果身处嵌套循环可以使用
$loop->parent变量来访问父级循环

$loop->index	当前循环迭代索引 (从0开始)
$loop->iteration	当前循环迭代 (从1开始)
$loop->remaining	当前循环剩余的迭代
$loop->count	迭代数组元素的总数量
$loop->first	是否是当前循环的第一个迭代
$loop->last	是否是当前循环的最后一个迭代
$loop->depth	当前循环的嵌套层级
$loop->parent	嵌套循环中的父级循环变量

# 注释
{{-- --}}
# PHP
@php
	// 原生PHP代码
@endphp
# 表单
1.CRSF字段
@csrf
2.方法字段
@method('PUT')
# 包含子视图
@include('shared.errors')
@include('shared.errors', ['some' => 'data'])
@includeWhen($boolean, 'shared.errors', ['some' => 'data']) // 判断是否包含子视图
@includeFirst(['custom.admin', 'admin'], ['some' => 'data']) // 包含数组中的第一个视图
@include 粗粒度 @component细粒度
1.为子视图引入设置别名
Blade::include('includes.input', 'input')
@include('input', ['some' => 'data'])
@input(['some' => 'data'])
2.在视图中渲染集合数据
使用@each('view.name', $jobs, 'job') 循环引入多个局部视图
第一个参数是数据或集合中每个元素要渲染的局部视图，第二个参数是希望迭代的数组或集合，第三个参数是要分配给当前视图的变量名。
@each('view.name', $jobs, 'job', 'view.empty')
第四个参数则是给定数组或集合为空时渲染的视图
@each渲染的视图不会从父视图继承变量，如果需要付视图的变量，可以使用@foreach和@include来替代
# 堆栈
@push('scripts')
	<scripts src=""></script>
@endpush
允许推送内容到命名堆栈，以便在其他视图或布局中渲染
@stack('scripts')使用
如果想要将内容显示在堆栈开头
@prepend('scripts')
@endprepend
# 服务注入
@inject('metrics', 'App\Service\MetricsService')
{{ $metrics->monthlyRevenus() }}
# 扩展Blade
# 自定义If语句

## 本地化
1.配置Locale选项
应用默认语言放在配置文件config/app.php中
App::setLocale($locale)
可以配置一个备用语言，当当前语言不包含给定语言时返回 默认语言一样，别用语言也在config/app.php中
'fallback_locale' => 'en'
2.判断当前本地语言
if (App::isLocale('en') {

} else {

}
# 定义翻译字符串
/resources
	/lang
		/en
			message.php
		/zh_cn
			message.php
1.使用缩写键
return [
	'welcome' => '欢迎',
]
2.使用翻译字符串作为键
使用JSON文件存放在resources/lang目录下
resources/lang/zh_cn.json
{
	'I love programming': '我爱NM',
}
# 获取翻译字符串
__()辅助函数
__('messages.welcome')
__('I love programming')
使用Blade模板引擎，可以使用
{{ __(messages.welcome }}
@lang('messages.welcome)
__()如果翻译字符串不存在会返回传入的键
@lang不会转义任何输出
1.替换翻译字符串中的参数
'welcome' => 'Welcome, :name'
:name占位符
使用
__('messages.welcome', ['name' => 'laravel'])
占位符的首字母大写则传入的数据首字母大写 如果全部大写则所有字符也大写
2.复数
'apples' => 'There is one apple|There are many apples',
可以创建多个数字区间指定翻译字符串的、更复杂的复数规则
'apples' => '{0} There are none|[1, 19] There are some|[20, *] There are many',
使用trans_choice('messages.apple', 10)
trans_choice('time.minutes_age', 5, ['value' => 5])

## Javascript & CSS脚手架
提供了有用的Bootstrap和Vue的一些基本脚手架，使用NPM来安装前端包
# CSS
提供了干净、优雅的API用于编译SASS或Less
# Javascript
引入基本脚手架，使用Vue库可以更轻松编写现代Javascript
# 移除前端脚手架
php artisan preset none

# 使用react
php artisan preset react
未看完
## 编译前端资源(laravel mix) 
未看

### 安全系列
## 登录认证
Laravel中实现登录认证非常简单，配置文件位于config/auth.php中
底层代码中，Larael的认证组件有guards和providers组成。Guard定义用户在每个请求中如何实现认证 Provider定义如何从持久化存储中获取用户信息。支持通过Eloquent和数据库查询两种方式
Provider获取数据信息，一般是数据库
Guard把用户登录状态保存起来，一般是Session
# 数据库考量
默认情况下，使用Eloquent模型User 使用migrant创建（建表所需已经在database中存在)
# 快速入门
提供了几个预置的认证控制器，位于App\Http\Controller\Auth命名空间下。
RegisterController 处理新用户注册
LoginController 处理用户登录认证
ForgetPasswordController 处理重置密码邮件连接
ResetPasswordController 重置密码逻辑
1.路由
php artisan make:auth
生成布局(resources/views/layouts/下)，注册时登录视图(resources/views/auth下和home.blade.php)，以及所有的认证路由，同时生成HomeController用于处理应用的登录请求
routes/web.php中添加了
Auth::routes();
Route::get('/home', 'HomeController@index')->name('home');
Auth::routes() 登录注册相关路由
如果不需要注册Auth::routes(['register' -> false])
2.视图
resources/views/auth
resources/views/layouts 布局文件
resources/views/home.blade.php
3.认证
5.自定义路径
当一个用户成功进行登录认证之后，默认会跳转到/home，可以通过在LoginController、RegisterController和ResetPasswordController中定义redirectTo属性来自定义登录认证成功之后的跳转路径
protected $redirectTo = '/';
接着需要编辑RedirectIfAuthenticated中间件的handle方法来使用新的重定向URI
需要重定向路径自定义生成逻辑 可以生成一个redirectTo方法 优先级比redirectTo属性高
protected function redirectTo() {
	return '/path';
}
6.自定义用户名
默认情况使用email字段进行认证，如果想要自定义认证字段，可以在LoginController中定义username方法
public function username() {
	return 'username';
}
7.自定义Guard


4.自定义路径
在LoginController/RegisterController/ResetPasswordController中定义redirectTo属性来自定义登录成功之后的跳转路径
protected $redirect = '/'
接着需要编辑RedirectAuthenticated中间件的handle方法来使用新的重定向URL
如果重定向需要自定义生成逻辑可以定义一个redirectTo方法取代redirectTo属性
protected function redirectTo() {
	reutrn '/path';
}
redirectTo方法优先级高于属性
5.自定义用户名
可以在LoginController中定义username方法
public function username() {
	return 'username';
}
6.自定义Guard
在LoginController、RegisterController和ResetPasswordController中定义guard方法，将会返回一个guard实例
protected function guard() {
	reutrn Auth::guard('guard_name');
}
guard_name需要在配置文件config/auth.php中配置
7.自定义验证/存储
要修改新用户注册所必需的表单字段，或者自定义新用户字段如何存储到数据库，可以修改RegisterController类，负责验证输入参数和创建新用户
RegisterController的validator方法包含了新用户注册的验证规则，可以按需自定义该方法。
RegisterController的create方法祝福使用EloquentORM在数据库中创建新的User记录。
# 获取登录用户
通过Auth门面访问认证用户
$user = Auth::user();
$id = Auth::id();
通过认证后，还可以通过Request实例访问认证用户。
$request->user();
1.判断当前用户是否通过认证
Auth门面的check方法
Auth::check() // true为通过认证
通常使用中间件来判断是否通过认证，而不是手动调用check
# 路由保护
路由中间件可用于只允许通过认证的用户访问给定路由，Laravel通过定义在Authenticate中的auth中间件来实现这一功能。由于已经在Kernel中注册，将中间件加到相应的路由定义中
Route::get('', function() {

})->middleware('auth');
可以在控制器的构造方法中调用middleware方法而不是在路由器中直接定义实现同样的功能
public function __conctruct() {
	$this->middleware('auth');
}
1.重定向未认证用户
auth中间件判断用户未认证，返回一个JSON401响应。如果不是Ajax请求则会重定向到login命名路由
可以通过更新Authenticate.php中文件的redirectTo函数来改变这一行为
protected function redirecteTo($request) {
	return route('login');
}
2.指定一个Guard
添加auth中间件到路由后，可以指定使用哪个guard来实现认证，指定的guard对应配置在config/auth.php中guards数组的某个键
public function __construct() {
	$this->middleware('auth:api');
}
# 登录失败次数限制
如果使用Laravel自带的LoginController，就已经启用了内置的ThrottlesLogins trait来限制用户登录失败次数。
# 手动认证用户
通过Auth门面来访问认证服务，需要确保在类的顶部导入Auth门面
class LoginController extends Controller {
	public function authenticate() {
		if (Auth::attempt(['email' => $email, 'password' => $password]) {
			return redirect()->intended('dashboard');
		}
	}
}
attempt方法接受键值对作为第一个参数，数组中的值被用于从数据表中查找对应用户。通过email查找用户信息，在将password加密后和找到的用户密码对比。如果匹配就为这个用户设置一个认证Session，表示用户登录成功。
认证成功attempt返回true，否则返回false
intended方法将用户重定向到用户想要访问的URL，无效则使用传入的URL
1.指定额外条件
Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])
除了password之外，所有其他字段都作为条件进行查询
2.访问指定Guard实例
使用Auth门面的guard方法指定想要使用的guard实例。
用于登录认证的模型类需要继承Illuminate\Foundation\Auth\User基类
传递给guard方法的guard名称对应配置文件auth.php中guards配置的admin键
if (Auth::guard('admin')->attempt($credentials)) {

}
这种方式认证的用户在后续操作需要传递guard时也要传递相匹配的guard
$this->middleware('auth:admin');
Auth::guard('admin')->user();
3.退出
使用Auth门面的logout方法，会清除用户Session中的认证信息
Auth::logout()
# 记住用户
将是否记住我boolean参数作为第二个参数传递到Auth::attempt([], $remember_me),不传默认是false。这样用户登录认证状态就会一直保持到手动退出。users表中必须包含remember_token字段，用于存储记住我令牌
使用记住我功能，通过Auth门面的viaRemember方法来判断用户是否通过记住我Cookie进行认证
if (Auth::viaRemember()) {
	//
}
# 其他认证方法
1.认证一个用户实例
需要将一个已存在的用户实例直接登录到应用，调用Auth门面的login方法并传入用户实例，传入的实例必须是Illuminate\Contracts\Auth\Authenticatable契约的实现。
Auth::login($user);
Auth::login($user, true); // 记住我
也可以指定想要使用的guard实例
Auth::guard('admin')->login($user);
2.通过ID认证用户
需要通过用户ID登录到应用，使用loginUsingId方法，接受想要认证用户的主键作为参数
Auth::loginUsingId(1)
Auth::loginUsingId(1, true)
3.一次性认证用户
使用Auth门面的once方法只在单个请求中将用户登录到应用，而不存储任何session和cooke，构建无状态API时很有用
if (Auth::once($credentials)) {

}
# 基于HTTP的基本认证
HTTP基本认证能够帮助用户快速实现登录认证而不用设置专门的登录页面，要在路由上使用auth.basic中间件。
Route::get('', function() {

})->middleware('auth.basic');
中间件加到路由器之后，访问该路由时，会自动提示认证信息，默认使用email字段作为用户名
1.FastCGI注意点
如果你使用 PHP FastCGI，HTTP 基本认证将不能正常工作，需要在 .htaccess 文件加入如下内容：

RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
2.无状态的HTTP基本认证
可以在使用HTTP基本认证时不再Session中设置用户标识Cookie，在API认证中非常有用。要实现这个功能，需要定义一个调用onceBasic方法的中间件，如果没有返回任何响应，请求继续进行。
class AuthenticateOnceWithBasicAuth {
	public function handle($request, $next) {
		return Auth::once() ?: $next->handle($request);
	}
}
# 退出
如果要手动退出应用，可以使用Auth上的logout方法，会清空用户Session中的认证信息
Auth::session()
1.让其他设备上的Session失效
确保AuthenticateSession中间件在web中间组中，使用Auth门面的logoutOhterDevices方法
Auth::logtouOtherDevices($password)
# 添加自定义Guard驱动
Auth门面的extend方法定义自己的认证guard驱动，需要在某个服务提供者的boot方法中实现，自带一个AuthServiceProvider，将代码放到其中
1.闭包请求Guard
实现一个自定义的、基于HTTP请求的日志系统最简单的方式就是使用Auth::viaRequest(),接受一个guard名称作为第一个参数，第二个参数是一个闭包，接受HTTP请求并返回一个用户实例，如果日志失败返回null
public function boot() {
	Auth::viaRequest('custom-token', function($request) {
		return User::where('token', $request->token)->first();
	});
}
定义好guard后，就可以在auth.php配置文件中作为driver使用了
# 添加自定义用户提供者
Auth门面的provider方法
public function boot() {
	Auth::provider('riak', function($app, array $config) {
		return new RiakUserProvider($app->make('riak.connection'));
	});
}
1.User Provider契约
UserProvider实现只负责从持久化存储系统中获取Authenticatable实现。允许Laravel认证机制继续其作用而不管用户数据如何存储或者怎么实现

interface UserProvider {

	// 一个代表用户的键获取用户
    public function retrieveById($identifier);
	// 通过唯一标识和存储在remember_token字段中的令牌获取用户
    public function retrieveByToken($identifier, $token);
	// 更新用户记住我令牌
    public function updateRememberToken(Authenticatable $user, $token);
	// 通过多个字段获取用户
    public function retrieveByCredentials(array $credentials);
	// 验证字段有效性来认证用户
    public function validateCredentials(Authenticatable $user, array $credentials);

}
2.Authenicatable契约
interface Authenticatable {
	// 主键名
    public function getAuthIdentifierName();
	// 主键值
    public function getAuthIdentifier();
	// 密码
    public function getAuthPassword();
	// 记住我令牌
    public function getRememberToken();
	// 设置记住我令牌
    public function setRememberToken($value); 
	// 获取记住我对应名称
    public function getRememberTokenName();
}
# 事件
支持在认证过程中触发多种事件，可以在EventServiceProvider中监听这些事件

## API认证解决方案 Laravel Passport
# OAuth2概述
1.什么是OAuth协议
是Open Authorization的简写，为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同,OAuth授权不会使第三方触及到用户的账号信息，即第三方无需使用用户的用户名和密码就可以申请获得用户资源的授权。
OAuth本身不存在标准的实现 实现步骤一般如下
1）客户端要求用户授权
2）用户同意授权
3）根据上一步获得授权 向认证服务器请求令牌（token）
4）认证服务器对授权进行认证 确认无误后发放令牌
5）客户端使用令牌向资源服务器请求资源
6）资源服务器使用令牌向认证服务器确认令牌的正确性，无误后提供资源
服务方不信任用户，所以需要用户提供密码或其他可信凭据；

服务方不信任第三方，所以需要第三方提供自已交给它的凭据（通常的一些安全签名之类的就是）；

用户部分信任第三方，所以用户愿意把自已在服务方里的某些服务交给第三方使用，但不愿意把自已在服务方的密码交给第三方；

在 OAuth 的流程中，用户登录了第三方的系统后，会先跳去服务方获取一次性用户授权凭据，再跳回来把它交给第三方，第三方的服务器会把授权凭据以及服务方给它的的身份凭据一起交给服务方，这样，服务方一可以确定第三方得到了用户对此次服务的授权（根据用户授权凭据），二可以确定第三方的身份是可以信任的（根据身份凭据），所以，最终的结果就是，第三方顺利地从服务方获取到了此次所请求的服务。
# 安装
composer require laravel/passport
php artisan migrate
php artisan passport:install
生成记录存放在数据表oauth_clients
添加HasApiToken到User模型类中,会为模型类提供一些辅助函数用于检查用户的token和scope
*
未看完 需要仔细看了解过程
*

## API认证
默认Laravel通过为应用中的每个用户分配一个随机的令牌这种方式提供非常简单的API认证解决方案。
# 配置
1.数据库准备
php artisan make:migration alert_users_table --table=users
$table->string('api_token', 80)->after('password')->unique();
# 生成令牌
在RegisterController中
User::create([
	...,
	'api_token' => Str::random(60),
]);
# 哈希令牌
auth.php中
'api' => [
	'driver' => 'token',
	'provider' => 'users',
	'hash' => true,
]
1.生成令牌
$request->user()->forceFill([
	'api_token' => hash(Str::random(60)),
])->save();
# 路由保护
在路由上应用中间件
Route::middleware('auth:api')->get('', function(){});
# 在请求中传递令牌
'api_token='.$token

## 授权
除了认证之外，还有管理授权逻辑以便控制对资源的访问权限，主要设计Gate和Policy
# Gate
1.编写Gate
用于判断用户是否有权进行某项操作的闭包，通常使用Gate门面定义在AuthServiceProvider类中
public function boot() {
	Gate::define('update-post', function($user, $post) {
		return $user->id == $post->user_id;
	});
}
还可以通过Class@method风格的回调字符串定义和控制器一样
2.资源Gate
Gate::resource('posts', 'PostPolicy');
相当于
Gate::define('posts.view', 'App\Policies\PostPolicy@view');
Gate::define('posts.create', 'App\Policies\PostPolicy@create');
Gate::define('posts.update', 'App\Policies\PostPolicy@update');
Gate::define('posts.delete', 'App\Policies\PostPolicy@delete');
默认会定义view create update delete,通过传入数组作为第三个参数来覆盖或添加其他权限。
3.授权动作
Gate::allows('', )
Gate::denies('', )
使用forUser()为指定用户授权
Gate::forUser($user)->allows('', )
Gate::forUser($user)->denies('', )
4.拦截Gate检查
Gate::before(function($user, $ability){
	
});
Gate::before(function($user, $ability){
	
});
在所有授权检查之前/后调用，返回非null 则直接作为检查结果返回
# Policy
1.生成Policy类
php artisan make:policy PostPolicy --model=Models/Post
2.注册Policy
AuthServieProvider包含一个policies属性来映射Eloquent模型及其对应的Policy类。
3.自动发现
Policy在app/Polices目录下，实体类在app目录下，自动关联
# 编写Policy
public function update($user, $post) {
	return $user->id == $post->user_id;
}
1.不带模型的方法
public function create(User $user) {

}
2.访客用户
如果传入HTTP请求由访客用户发起，所有Gate和Policy检查都会返回false，不过可以通过声明认证用户参数可选或者默认值为null来允许访客用户请去通过授权检查
public function(?User $user, Post $post) {
	
}
3.策略过滤器
public before($user, $ability) {
	if ($user->isSuperAmidn()) {
		return true;
	}
}
# 使用Policy授权动作
1.通过User模型
提供两个方法用于授权动作can和cant，can方法接受想要授权的动作和对应的模型作为参数
if ($user->can('update', $post)) {

}
如果对应的策略已经注册，则can方法会自动调用相应的策略并返回布尔结果，没有策略注册，则尝试调用与动作名称相匹配的Gate闭包
2.不依赖模型的动作
有些动作不依赖与给定模型实例，可以传递一个类名到can方法，会在进行授权时判断使用哪一个策略
if ($user->can('create', Post::class)) {

}
3.通过中间件
Authorize中间件，分配了can的别名
Route::put('', function() {

})->middleware('can:update, post');
第一个参数是授权动作名，第二个参数是模型实例，如果没有授权返回一个403响应
4.不依赖模型的动作
Route::put('', function() {

})->middleware('can:create, App\Models\Post');
5.通过控制器辅助函数
Controller基类的所有控制器提供了authorize方法和can方法类似。接受想要授权的方法和模型实例作为参数，如果没有授权抛出AuthorizationException，默认异常处理器将其转化为状态码403的HTTP响应
$this->authorize('update', $post);
6.不依赖模型
$this->authorize('create', Post);
7.授权资源控制器
public function __construct() {
	$this->authorizeResource(Post::class, 'post');
}
8.通过Blade模板
@can @cannot指令
@can('update', $post)
@elsecan('create', Post::class)
$endcan
@cannot('update', $post)
@elsecannot('create', Post::class)
@endcannot
可以看做是@if @elseif @else @endif的简写

## 邮箱验证
1.模型准备
需要实现MustVerifyEmail契约
User extends Authenticatable implements MustVerifyEmail {

}
2.数据库配置
邮箱验证字段
必须包含email_verified_at字段
3.路由
内置Auth\VerificationController类来包含发送验证连接和验证邮箱的必要逻辑。为这个控制器注册相关路由则传递verify=true到Auth::routes方法
保护路由
未注册用户不能访问，已经提供了中间件EnsureEmailIsVerified,别名verified
->middleware('verified')
4.视图
执行make:auth之后，视图位于resources/views/auth/verify.blade.php
5.验证邮箱后
用户重定向到/home页面
在VerificationController中定义redirectTo方法或属性来自定义重定向路径
6.事件

## 加密
加密器使用OpenSSL来提供AES-256和AES-128加密。
# 配置
必须在配置文件app.php中设置可以选项为32位随机字符串，可以使用php artisan key:generate命令来生成这个key
# 使用加密器
1.加密
encrypt($str) 
所有加密值都使用OpenSSL和AES-256-CBC密码进行加密，此外所有加密值都通过一个消息认证码（MAC）来进行签名一繁殖对加密字符串的任何修改
2.不进行序列化的加密
加密值在加密期间都会经过序列化函数serialize进行处理，从而允许对对象和数组的加密。非PHP客户端接受的加密数据需要unserialize反序列化。如果不想进行序列化操作，可以使用Crypt门面提供的encryptString和decryptString方法
3.解密
decrypt($str)

## 哈希
Hash门面为存储用户密码提供了安全的Bcrypt和Argon2哈希算法，如果使用自带的LoginController和RegisterController控制器，将会自动在注册和认证时使用默认的Bcrypt算法
#配置
在config/hashing.php文件中，目前支持两种驱动Bcrypt和Argon2
# 基本使用
Hash门前的make方法对密码进行哈希
Hash::make($password)
1.调整Bcrypt工作因子
Hash::make($password, ['rounds'=>12])
2.调整Argon2工作因子
Hash::make($password, [
	'memory' => 1024,
	'time' => 2,
	'threads' => 2,
])
3.通过哈希验证密码
Hash::check($toVerifyPassword, $password)
4.检查密码是否需要重新哈希
Hash::needRehash($hashedPassword)

## 重置密码
必须使用Notifiable trait
# 数据库相关
需要实现CanResetPassword trait来包含实现该接口需要的方法
1.生成重置令牌表迁移



### 数据库
## 快速入门
# 简介
Laravel让连接不同数据库以及对数据库进行增删改查操作变得非常简单。无论使用原生SQL、还是查询构建起，还是Eloquent ORM。目前支持4种
1.MySQL
2.Postgres
3.SQLite
4.SQL Server
# 配置
应用的数据库配置位于config/database.php（但是数据库用户及密码等敏感信息位于.env文件）在该文件中可以定义所有的数据库连接，并指定哪个连接是默认连接。提供了所有支持数据库系统的配置实例。
默认情况下使用MySQL作为数据库引擎
1.SQLite配置
2.读写分离
'mysql' => [
	'read' => [
		'host' => ['192.168.1.1', '192.169.2.1'],
	],
	'write' => [
		'host' => '192.168.1.2',
	],
	'sticky'    => true,
    'driver'    => 'mysql',
    'database'  => 'database',
    'username'  => 'root',
    'password'  => '',
    'charset' => 'utf8mb4',
    'collation' => 'utf8mb4_unicode_ci',
    'prefix'    => '',
]
多个host会随机选择一个进行读写
3.sticky项
是一个可选配置，可用于在当前请求生命周期内允许立即读取写入数据库的记录。如果启动并且写操作在当前声明周期内发生，则后续所有读操作都会使用这个写操作（必须在同一个声明周期中）
4.使用不同数据库连接
使用多个数据库连接的时候，可以通过DB门面上的connection方法访问不同连接。传递给connection方法的name对应配置文件config/database.php中设置的某个连接
$users = DB::connection('read')->select(...);
甚至可以指定数据库和连接名 使用::分隔
$users = DB::connection('mysql::read')->select(...);
还可以使用连接实例上的getPdo方法访问底层原生的PDO实例
$pdo = DB::connection('read')->getPdo();
# 运行原生SQL查询
配置好数据库连接之后，就可以使用DB门面来运行查询。DB门面为每种操作提供了相应的方法：select、update、insert、delete和statement
1.运行select查询
$users = DB::select('select * from users where active = ?', [1]);
第一个参数是原生SQL语句，?表示占位符，第二个参数则是绑定到查询的参数绑定 参数绑定可以避免SQL注入攻击
select方法以数组形式返回结果集，数组中的每个结果都是一个PHPstdClass对象
2.使用命名绑定
DB:select('SELECT * FROM users WHERE id = :id', ['id' => 1]);
3.运行插入语句
DB::insert('INSERT INTO users(id, name) VALUES(?, ?)', [1, 'A'])
4.运行更新语句
DB::update('UPDATE users SET votes = 100 WHERE name = ?', ['A'])
5.运行删除语句
DB::delete('DELETE FROM users WHERE id = ?', [1])
6.运行通用语句
DB::statement('DTOP TABLE users');
# 监听查询事件
如果想要获取每次SQL语句的执行，可以使用listen方法，对查询日志和调试非常有用。可以在服务提供商中注册查询监听器
class AppServiceProvider extends ServiceProvider {
	public function boot() {
		DB::listen(function($query) {
			// 
		});
	}
}
# 数据库事务
开启使用使用DB门面的transaction方法，无需手动回滚或提交。当事务闭包中抛出异常，事务自动回滚，如果闭包执行成功则自动提交
DB::transaction(function() {
	DB::table('users')->update(['votes' => 1]);
	DB::table('posts')->delete();
});
1.处理死锁
transaction接收一个可选参数作为第二个参数，用于定义死锁发生时事务最大的重试次数。
2.手动使用事务
DB::beginTransaction()
DB::rollback()
DB::commit()
## 查询构建器
# 简介
数据库查询构建器提供了一个方便的流接口用于创建和执行数据库查询。查询构建器可以用于执行应用中绝大部分数据库操作，并且能够在Laravel支持的所有数据库系统的上工作。
也使用PDO参数绑定来避免SQL注入攻击，不再需要过滤以绑定方式传递的字符串。
# 获取结果集
1.从一张表中取出所有行
DB门面的table方法开始，table方法为给定表返回一个流式查询构建器实例。允许在查询上链接多个约束条件并返回最终查询结果。
然后使用get()方法取出所有行
DB::table('users').get()
2.从一张表中取出一行/一列
可以使用first()方法，返回单个stdClass对象
$user = DB::table('users')->where('id', 1)->first()
如果需要指定查询列
DB::table('users')->where('name', 'A')->value('email')->first()
3.获取数据列值列表
使用pluck方法
$titles = DB::table('roles').pluck('title')
foreach($titles as $title) {
	echo $title;
}
可以指定键值(必须是该表中其他列）
$titles = DB::table('roles').pluck('title', 'name');
foreach($titles as $name => $title) {
	echo $name.'-'.$title;
}
4.组块结果集
如果需要处理成千上百条数据库记录，可以考虑使用chunk方法，该方法一次获取结果集的一小块，然后传递每一小块数据到闭包函数进行处理。
DB::table('users')->orderBy('id')->chunk(100, function($users) {
	foreach($users as $user) {
		//
	}
});
可以在闭包函数中return false来终止组块运行
最好使用chunkById方法自动基于记录的主键对结果集进行分页
DB::tables('users').chunkById(100, function($users) {
	//
});
5.聚合函数
count()
max()
min()
avg()
sum()
6.判断记录是否存在
exists()
doesntExist()
# 查询
1.指定查询子句
不需要查询所有列 使用select方法指定查询子句
DB::table('users').select('name', 'email')->get()
distinct()方法允许强制查询返回不重复的结果集
DB::table('users').distinct()->get()
如果已有一个查询构建器实例并希望添加一个查询列 可以使用addSelect()方法
$query = DB::table('users')->select('name');
$users = $query->addSelect('email')->get()
2.原生表达式
使用raw()方法
DB::table('users')->select(DB::raw('count(*) AS user_count, status'))->groupBy('status')->get();
3.原生方法
selectRaw()方法
DB::table('users')->selectRaw('price * ? AS price_with_tax', [1.0825])->get();
whereRaw() orWhereRaw()
DB::table('users')->whereRaw('price > IF(state = 'TX', ?, 100)', [200])->get()
havingRaw orHavingRaw
$orders = DB::table('orders')
                ->select('department', DB::raw('SUM(price) as total_sales'))
                ->groupBy('department')
                ->havingRaw('SUM(price) > 2500')
                ->get();
orderByRaw
$orders = DB::table('orders')
                ->orderByRaw('updated_at - created_at DESC')
                ->get();
# 连接
1.内连接 Inner Join
DB::table('users')->join('contacts', 'users.id', '=', 'contacts.user_id')
2.左/右连接
DB::table('users')->leftJoin('posts', 'users.id', '=', 'posts.user_id')
DB::table('users')->rightJoin('posts', 'users.id', '=', 'posts.user_id')
3.交叉连接
DB::table('users')->crossJoin('colours');
4.高级连接语句
DB::table('users')->join('contacts', function($join) {
	$join.on('users.id', '=', 'contacts.user_id');
})
可以使用where和orWhere方法 用于列和值的比较
DB::table('users')->join('contacts', function($join) {
	$join.on('users.id', '=', 'contacts.user_id')
		.where('contacts.user_id', '>', 5);
})
5.子查询连接
将查询和子查询进行链接，每个方法都接受3个参数-子查询，表别名和关联字段的闭包
$latestPosts = DB::table('posts')
                   ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
                   ->where('is_published', true)
                   ->groupBy('user_id');

$users = DB::table('users')
        ->joinSub($latestPosts, 'latest_posts', function($join) {
            $join->on('users.id', '=', 'latest_posts.user_id');
        })->get();
6.联合
$first = DB::table('users')->whereNull('first_name')
$users = DB::table('users')->whereNull('last_name')->union($first)->get();
# Where子句
1.简单Where子句
where方法可以添加where子句到查询中，调用where最基本的方式需要传递三个参数，第一个是列名，第二个参数任意一个数据库系统支持的操作符，第三个参数是列要比较的值
DB::table('users')->where('votes', '=', 100)->get()
默认判断是否相同 可以省略=，将数值作为第二个参数
可以传递一个数组到where函数中
DB:table('users')->where([
	['status' '=', '1'],
	['subscribed', '<>', '1'],
])->get();
2.or语句
orWhere方法
$users = DB::table('users')
                ->where('votes', '>', 100)
                ->orWhere('name', 'John')
                ->get();
3.更多where子句
whereBetween('votes', [1, 100]) // 在范围内
whereNotBetween('votes', [1, 100]) // 不再范围内
whereIn('id', [1, 2, 3]) // 在数组中
whereNotIn('id', [1, 2, 3]) // 不在数组中
whereNull('updated_at') // 给定列的值为Null
whereNotNull('updated_at') // 给定列的值不为Null
whereDate('craeted_at', '2019-09-09')
whereMonth('craeted_at', '9')
whereDay('craeted_at', '9')
whereYear('craeted_at', '2019')
whereTime('craeted_at', '=', '11:20')
whereColumn('first_name', 'last_name') // 两个字段是否相同 可以传递比较符到这个方法 可以传入一个数组到这个方法 实际sql用and连接
whereColumn([
	['first_name', '=', 'last_name'],
	['updated_at', '>', 'created_at'],
])
4.参数分组
使用闭包
DB::table()->where(function($query) {
	$query->where()->where();
})->orWhere(function($query) {
	$query->where()->where();
})->get();
5.where exists子句
whereExists方法允许编写where existsSQL子句，接受一个辩驳参数，获取一个查询构建器实例从而允许定义防止在exists子句中的查询
DB::table('uses')->whereExists(function($query) {
	$query->select(DB:raw(1))->from('orders')->whereRaw('orders.user_id = users.id');
})->get();
6.JSON where子句
还支持提供JSON字段类型的数据库
未看完
# 排序、分组、限定
1.orderBy
orderBy('name', 'desc')
2.latest/oldest
通过日期对结果集进行排序
latest()->first()
3.inRandomOrder
用于对结果集进行随机排序
4.groupBy/having
对结果集进行分组
DB::table('users')->groupBy('account_id')->having('account_id', '>', 100)->get();
5.skip/take
限定查询返回结果集的数目
DB::table('users')->skip(10)->take(5)->get()
作为替代可以使用limit offset
DB::table('users')->offset(10)->limit(5)->get()
# 条件子句
某些条件为true的时候才将条件子句应用到查询 使用when方法
DB::table('users')->when($role, function($query) use ($role) {
	return $query->where('role_id', $role);
});
when方法只有在第一个参数为true时才执行第二个参数传入的闭包
还可以传入第三个参数闭包 作为第一个参数为false时执行
# 插入
DB::table('users')->insert([
	'name' => '',
	'email' => '',
]);
可以传入二维数组 一次插入多条数据
DB::table('users')->insert([
	[
		'name' => '',
		'email' => '',
	],
	[
		//
	]
]);
1.自增ID
需要使用insertGetId()方法来插入记录并返回ID
# 更新
DB::table('users')->here('id', 1)->update([
	'name' => '',
])
1.更新或插入
DB::table('users')
    ->updateOrInsert(
        ['email' => 'john@example.com', 'name' => 'John'],
        ['votes' => '2']
    );
会先尝试使用第一个参数数组作为where子句的条件第二个参数为更新的数据。如果更新不存在，则合并两个数组做插入
2.更新JSON字段
未看
3.增加/减少
DB::table('users')->increament('votes')
DB::table('users')->increament('votes', 5)
DB::table('users')->decreament('votes')
DB::table('users')->decreament('votes', 5)
第二个参数可选，默认+/-1
还可以传入第三个数组参数 作为额外更新
DB::table('users')->increment('votes', 1, ['name' => 'John']);
# 删除
DB::table('users')->delete()
DB::table('users')->where('id', 1)->delete()
# 悲观锁 & 乐观锁
悲观锁 每次获取数据就会上锁
乐观锁 获取数据不会上锁，只有在更新时才会查看是否有修改过
1.悲观锁
DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();
2.乐观锁
大多基于数据版本Version，给表加一个Version字段，更新即+1

## 分页
# 基本使用
1.基于查询构建器进行分页
使用构建器或Eloquent查询提供的paginate方法，唯一参数是每页显示数量，会根据HTTP请求查询字符串参数page的值判断，自动检测并自动插入分页器生成的链接中
groupBy的分页操作不能被Laravel有效执行，如果需要使用groupBy，推荐手动查询数据库然后创建分页器
简单分页
simplePaginate() 不产生页码时使用
2.基于Eloquent结果集进行分页
App\Models\User::paginate(15)
App\Models\User::simplePaginate(15)
3.手动创建分页器
Illuminate\Pagination\Paginator 不需要传入结果集数据项的总数 对应simplePaginate方法
Illuminate\Pagination\LengthAwarePaginator 需要传入结果集数据项的总数 对应paginate方法
# 显示分页结果
@foreach($users as $user) 
	{{ $user->name }}
@endforeach
{{ $users->links() }}
links方法将结果集中的其他页面链接渲染出来，每个连接以及包含了page查询字符串变量
1.自定义分页链接
withPath方法允许生成分页链接时自定义分页器使用的URL
$users->withPath('custom/url');
此时分页器生成形如http://example.com/custom/url?page=N
2.添加参数到分页链接
{{ $users->appends(['sort' => 'votes'])->links()
append()方法将 &key=value添加到url中
想要添加类似#foo的哈希片段，使用fragment方法
$users->fragment('foo')->links()
3.调整分页链接窗口
可以控制每个分页URL[窗口](分页器)中除当前页面链接之外显示几个额外链接，默认是3个。可以使用onEachSide方法来修改这个默认值
{{ $users->onEachSide(5)->links() }}
4.将结果转化为JSON
分页器结果类实现了JsonableInterface契约并提供了toJson方法
从分页器转化来的JSON包含元信息如total、current_page、last_page等等
例子
{
   "total": 50,
   "per_page": 15,
   "current_page": 1,
   "last_page": 4,
   "first_page_url": "http://laravel.app?page=1",
   "last_page_url": "http://laravel.app?page=4",
   "next_page_url": "http://laravel.app?page=2",
   "prev_page_url": null,
   "path": "http://laravel.app",
   "from": 1,
   "to": 15,
   "data":[
        {
            // Result Object
        },
        {
            // Result Object
        }
   ]
}
# 自定义分页视图
{{ $paginator->links('view.name', ['foo' => 'bar'] }}
自定义分页视图的最简单方式是使用vendor:publish命令导出视图文件到resources/views/vendor目录
php artisan vendor:publish --tag=laravel-pagination
会将视图放到resources/views/vendor/pagination目录 default.blade.php文件对于默认的视图文件 编辑即可自定义
想要指定其他文件作为默认分页视图，在AppServiceProvider中使用分页器的defaultView和DefaultSimpleView方法
public function boot() {
	Paginator::defaultView('pagination::view');
	Paginator::defaultSimpleView('pagination::view');
}
# 分页器实例方法
$results->count()			获取当前页的项目数
$results->currentPage()		获取当前页的页码
$results->firstItem()		获取结果集分片中第一项的编号
$results->getOptions()		获取分页选项
$results->getUrlRange($start, $end)	创建分页 URL 的范围
$results->hasMorePages()	判断是否还有足够多的项目用于分页
$results->lastItem()		获取结果集分片中最后一项的编号
$results->lastPage()		获取最后一页的页码(使用 simplePaginate 时无效)
$results->nextPageUrl()		获取下一页的 URL
$results->onFirstPage()		判断是否在第一页
$results->perPage()			每页显示的项目数
$results->previousPageUrl()	获取上一页的 URL
$results->total()			判断存储器中匹配的所有项目总数(使用 simplePaginate 时无效)
$results->url($page)		获取给定页码的分页 URL

## 迁移
# 生成迁移
php artisan make:migration create_users_table
--create 	是否创建一个新的数据表
--table 	指定表名
# 迁移结构
up方法用于新增表、列或索引到数据库
down方法则是up的逆操作
# 运行迁移
php artisan migrate
php artisan migrate --force // 强制运行迁移 而不提示
# 回滚迁移
php artisan migrate:rollback // 回滚上一批迁移操作
php artisan migrate:rollback --step=5 // 回滚五条迁移
php artisan migrate:reset // 回滚所有的应用迁移

*
未看完
*

## 数据填充
未看

## Redis
composer require predis/predis
还可以通过PECL安装PHP扩展PhpRedis，安装麻烦但是性能好
# 配置
也在config/database.php中
# 与Redis交互
使用Redis门面 基本Redis中的命令都有相同名的门面方法
Redis::get() // Redis中的get命令
Redis::set()
Redis::lrange()
还可以使用
Redis::command('lrange', ['name', 5, 10]);
直接发送命令到Redis
2.使用多个Redis连接
$redis = Redis::connection('')
3.管道命令
Redis::pipeline(function ($pipe) {
	for ($i = 0; $i < 1000; $i++) {
		$pipe->set("key:$i", $i);
	}
})
# 发布/订阅
Redis::subscribe('channel_name', function($meesage) {

});
第一个参数是订阅的频道名 第二个则是收到发布的消息后出发的回调函数
Redis::publish('channel_name', $message)

### Eloquent ORM
## 快速入门
# 简介
内置的Eloquent提供了一个美观的、简单的与数据库打交道的ActiveRecord实例，每张表都对应一个与该表进行交互的模型（Model）。通过模型类，可以对数据表进行查询、插入、更新和删除等操作
# 定义模型
php artisan make:model Flight
默认在app目录下
如果希望在生成模型时生成数据库迁移，可以使用--migration或者-m选项
# Eloquent模型约定
1.表名
默认使用小写模型类名的复数格式作为表名 Flight默认使用flights作为表名
可以使用table属性自定义表名
$table = 'my_flight'
2.主键
默认使用主键名id，可以使用primaryKey属性自定义主键名
Eloquent默认主键字段是自增长的整数数据，会被自动转化为int类型。如果想要使用非自增或非整型主键，应该将$incrementing属性设置为false 如果不是整型 还需要将$keyType设置为string
$incrementing = false;
$keyType = string;
3.时间戳
默认Eloquent机器created_at和updated_at已经存在于数据表中，如果不想要Laravel自动管理的数据列，在模型类中设置$timestamps属性为false
$timestamps = false;
如果需要自定义时间戳格式，使用dateFormat属性，决定日期如何存储到数据库中，以及模型被序列化为数组或JSON时日期的格式
$dateFormat = 'U';
如果需要自定义用于存储时间戳的字段名称 可以设置CREATED_AT和UPDATED_AT常量
const CREATED_AT = 'creation_date';
const UPDATED_AT = 'last_update';
4.数据库连接
为模型指定不同的连接使用connection属性
$connection = 'mysql';
5.默认属性名
如果想要定义某些模型属性的默认值 可以在模型上定义attributes属性
$attributes = [
	'delayed' => false,
]
# 获取模型
创建完模型及其关联的数据表后，就可以从数据库中获取数据了。将Eloquent模型看做功能强大的查询构建器。
例如
Flight::all()
1.添加额外的月数
Flight::where('active', 1)->orderBy('name', 'desc')->take(10)->get()
Eloquent模型本质上就是查询构建器 可以使用查询构建器的所有方法
2.刷新模型
可以使用fresh和refresh方法刷新模型，fresh方法将会从数据库中重新获取模型，已存在的模型实例不受影响
$flight = Flight::where('number', 'FR 900')->first();
$freshFlight = $flight->fresh()
refresh方法使用数据库中后去的新数据重新水合现有模型，所有加载的关联关系也会被重新刷新
3.集合
Eloquent中获取多个结果的方法（比如all和get）而言，其返回值是Collection的一个实例，Collection类提供了多个有用的函数来处理Eloquent结果集
4.组块结果集
如果需要处理数据量很大的Eloquent结果集，可以使用chunk方法，获取一个指定数量的模型组块，并将其填充到给定闭包进行处理。可以减少内存消耗
Flight::chunk(100, function($flights) {
	//
});
5.使用游标
cursor一次只执行单个查询，在处理大批量数据时，cursor方法可大幅度减少内存消耗
foreach (Flight::all()->cursor() as $flight) {
	//
}
# 获取单个模型/聚合结果
Flight::find(1) // 通过主键查找
Flight::where('active', 1).first() // 结果集的第一条数据
还可以传递主键数组来调用find方法，这将会返回匹配记录集合
Flight::find([1, 2, 3])
1.Not Found异常
在模型找不到时抛出异常
findOrFail()
firstOrFail()
没有查询到结果时会抛出NotFoundException
如果没有捕获异常则会返回404给用户。
2.获得聚合结果
count()
min()
max()
sum()
avg()
# 插入/更新模型
设置模型的属性 然后调用save方法
1.更新
save方法还可用于更新数据库中已存在的模型，先获取，设置更新值，再调用save方法 同时updated_at字段也会被同时更新
2.批量更新
Flight::where('active', 1)->update(['delayed' => 1]);
批量更新时，saved和updated模型事件没有触发，因为没有先获取模型
3.批量赋值
可以使用create方法保存一个新的模型，该方法返回被插入的模型实例。但是，在此之前，需要指定模型的fillable或guarded属性，因为所有Eloquent模型都通过批量赋值进行保护，这两个字段分别定义
fillable  可以批量赋值
guarded	  受保护，不能显式的批量赋值
Flight::create('name' => 'Flight 10'])
Flight::fill(['name' => 'Flight 22]) // 已有模型实例 填充数据
4.黑名单属性
$guarded包含不想被赋值的属性数组，不被包含在其中的属性都是可以被赋值的。和$fillable两个只能选择一个而不能一起使用
5.其他创建方法
firstOrCreate/firstOrNew
firstOrCreate 尝试使用给定的属性/值对在数据库中查找记录，如果没有找到的话通过给定属性创建一个新的记录
firstOrNew 尝试使用给定的属性/值对在数据库中查找记录，如果没有找到的话通过给定属性创建一个新的对象实例，并未持久化到数据库中，需要手动调用save保存到数据库
6.updateOrCreate
使用给定键值对查询记录，有则使用给定值更新字段，没有则合并条件和更新值然后使用合并后的数组新建记录
# 删除模型
$flight = Flight::find(1)
$flight->delete()
1.通过主键删除模型
Flight::destory([1, ,2, 3])
2.通过查询删除模型
$deleteRows = Flight::where('active', 0)->delete()
3.软删除
软删除并没有从数据库中物理删除，而是设置一个deleted_at属性并插入数据库，如果有一个非空的deleted_at值，就表示已经软删除了 启动软删除需要use SoftDeletes并添加deleted_at到$dates属性
use SoftDeletes;
$dates = [
	deleted_at,
	
];
$table->softDeletes() // 迁移中
是否软删除通过trashed方法
4.查询被软删除的模型
1）包含软删除的模型
Flight::withTrashed()
2）值获取软删除的模型
Flight::onlyTrashed()
3）恢复软删除的模型
$flight->restore()
4）永久删除模型
$flight->forceDelete()
# 查询作用域
1.全局作用域
为给定模型的所有查询添加条件约束 自带的软删除功能就使用全局作用域从数据库中获取未软删除的模型
1）编写全局作用域
定义Scope接口的类，实现apply方法
class AgeScope implements Scope {
	public function apply(Builder $builder, Model $model) {
		return $builder->where('', '', '');
	}
}
2.应用全局作用域
给定模型的boot方法中添加addGlobalScope()方法
public User extends Model {
	public function boot() {
		parent::boot();
		static::addGlobalScope(new AgeScope);
	}
}
3.匿名的全局作用域
public User extends Model {
	public function boot() {
		parent::boot();
		static::addGlobalScope('age', function(Builder $builder) {
			$builder->where('', '', '');
		});
	}
}
4.移除全局作用域
User::withoutGlobalScope()->get()
# 本地作用域
允许定义通用的约束集合以便在应用中复用，在对应Eloquent模型方法前加上scope前缀
public function scopePopular($query) {
	return $query->where('votes', '>', 100);
}
public function scopeActive($query) {
	return $query->where('active', 1);
}
1.使用本地作用域
$users = User::popular()->active()->get();
可以使用orWhere配合闭包
$users = User::popular()->orWhere(function(Builder $query) {
	$query->active();
})->get();
2.动态作用域
需要接受参数的作用域，只需要将额外的参数添加到作用域即可。作用域参数应该被定义在$query之后
public function scopeOfType($query, $type) {
	return $query->where('type', $type);
}
# 比较模型
使用is方法可以快速验证两个模型是否拥有相同的主键、数据表以及数据库连接
if ($post->is($anotherPost)) {
	//
}
# 事件
Eloquent模型可以触发事件，允许在模型生命周期中的多个时间点调用如下方法
retrieved			获取已存在的数据模型时触发
creating			首次保存时
created				首次保存时
updating			已存在 更新时
updated				已存在 更新时
saving				保存更新时
saved				保存更新时
deleting			删除时
deleted				删除时
restoring			restore方法 刷新数据模型时
restored			刷新数据模型时
事件允许在一个指定模型类每次保存或更新的时候执行代码
使用$dispatchesEvents属性
$dispatchesEvents = [
	'saved' => UserSaved::class,
];
# 观察者
1.定义观察者
给定模型监听多个事件，可以使用观察者来对所有监听器分组到一个类中，观察者类拥有反射想要监听的Eloquent事件对应的方法名。每个方法接受模型作为唯一参数
php artisan make:observer UserObserver --model=User
观察者会生成到App/Observers目录下
注册观察者，需要在某个服务提供商的boot方法中注册
public function boot() {
	User::observe(UserObserver::class);
}

## 关联关系
一对一
一对多
多对多
远层一对一
远层一对多
一对一（多态）
一对多（多态）
多对多（多态）
# 定义关联关系
1.一对一
加入User模型都有一个与之相关的Phone模型，想要定义这种关联关系，需要将phone方法置于User模型中，phone方法会调用HasRelationships中的hasOne方法并返回其结果
class User extends Model {
	public function phone() {
		return $this->hasOne('App\Models\Phone');
	}
}
关联关系定义之后，可以使用动态属性获取关联记录。动态属性允许访问关联方法，向属性一样。
$phone = User::find(1)->phone;
默认关联关系的外键基于模型名称，Phone中有一个user_id外键。如果需要覆盖，可以传递第二个参数作为外键名到hasOne方法中
return $this->hasOne('App\Models\Phone', 'foreign_key');
此外，还需要一个与外键匹配的主键，默认是id。如果想要覆盖，将主键名作为第三个参数传入hasOne方法
return $this->hasOne('App\Models\Phone', 'user_id', 'id')
. 定义相对关联
可以从User中访问Phone模型，也可以从Phone中获取User。可以使用belongsTo方法定义与hasOne关联关系相对的关联
class Phone extends Model {
	public function user() {
		return $this->belongsTo('App\Models\User');
	}
}
同样的可以将外键名作为第二个参数，主键名作为第三个参数传入belongsTo方法传入
2.一对多
使用hasMany方法
class Post extends Model {
	public function comments() {
		return $this->hasMany('App\Models\Comment');
	}
}
也可以将外建明、主键名作为第二、三个参数传入方法
Post::find(1)->comments
关联同时也是查询构建器
Post::find(1)->comments()->where('')->first();
.一对多（逆向）
class Comment extends Model {
	public function post() {
		return $this->belongsTo('App\Models\Post');
	}
}
也可以将外建明、主键名作为第二、三个参数传入方法
3.多对多
有三张表users roles role_user(含有user_id role_id)两个外键
class Role extends Model {
	public function users() {
		return $this->belongsToMany('App\Models\User')
	}
}
可以传入中间表名作为第二个参数 本表的外键名和关联模型表的外键名作为第三四个参数
动态属性也是一个查询构建器
.定义相对的关联关系
class User extends Model {
	public function roles() {
		return $this->belongsToMany('App\Models\Role');
	}
}
.获取中间表字段
使用模型上的pivot属性访问中间表
默认只有主键才能用在pivot上，如果包含额外的属性，需要在定义关联关系是指定
$this->belongsToMany()->withPivot('column1', 'columns2')
如果想要pivot表自动包含created_at和updated_at，需要在定义关联关系时指定
$this->belongsToMany()->withTimestamps();
.自定义privot属性名
$this->belongsToMany()->as('middle_table_name');
.通过中间表字段过滤关联关系
belongsToMany()->wherePivot('approved', 1)
belongsToMany()->wherePivotIn('priority', [1, 2])
4.自定义中间表模型
$this->belongsToMany()-using('App\Pivots\UserRole')
中间表模型需要继承自Pivot类
class UserRole extends Pivot {
	
}
.自定义中间模型和自增ID
protected incrementing = true;
5.远层一对一
通过单移中间关系链接模型。比例，供应商对应一个用户，用户有一个用户历史记录，那么供应商就可以通过用户来访问用户的历史
class Supplier extends Model {
	public function userHistory() {
		return $this->hasOneThrough('App\Models\Histroy', 'App\Models\User');
	}
}
第一个参数远层模型
第二个参数中间模型
第三个参数中间表模型对应本模型的外键
第四个参数远层模型对应中间表模型的外键
第五个参数本模型的主键
第六个参数中间表模型的主键
6.远层一对多
比如Country模型通过中间表User模型可能拥有多个Post模型
class Country extends Model {
	public function userPosts() {
		return $this->hasManyThrough('App\Models\Post', 'App\Models\User')
	}
}
第一个参数远层模型
第二个参数中间模型
第三个参数中间表模型对应本模型的外键
第四个参数远层模型对应中间表模型的外键
第五个参数本模型的主键
第六个参数中间表模型的主键
# 多态关联
1.一对一 （多态）
Post和User可以共享与Image模型的多态关联
1)表结构
posts
    id - integer
    name - string

users
    id - integer
    name - string

images
    id - integer
    url - string
    imageable_id - integer
    imageable_type - string
2)模型结构
class Image extends Model
{
    /**
     * Get all of the owning imageable models.
     */
    public function imageable()
    {
        return $this->morphTo();
    }
}

class Post extends Model
{
    /**
     * Get the post's image.
     */
    public function image()
    {
        return $this->morphOne('App\Image', 'imageable');
    }
}

class User extends Model
{
    /**
     * Get the user's image.
     */
    public function image()
    {
        return $this->morphOne('App\Image', 'imageable');
    }
}
3)获取关联关系
Post::find(1)->image
Image::find(1)->imageable // 将返回User或Post类的实例
2.一对多（多态）
1)表结构
posts
id - integer
title - string
    body - text

videos
  id - integer
  title - string
  url - string

comments
    id - integer
    body - text
    commentable_id - integer
    commentable_type - string
2)模型结构
class Comment extends Model {
	public function commentable() {
		return $this->morph();
	}
}
class Post extends Model {
	public function comments() {
		return $this->morphMany('App\Models\Comment', 'commentable');
	}
}
class Video extends Model {
	public function comments() {
		return $this->morphMany('App\Models\Comment', 'commentable');
	}
}
3.多对多（多态）
1)表结构
posts
    id - integer
    name - string

videos
    id - integer
    name - string

tags
    id - integer
    name - string

taggables
    tag_id - integer
    taggable_id - integer
    taggable_type - string
2)模型结构
class Post extends Model
{
    /**
     * 获取指定文章所有标签
     */
    public function tags()
    {
        return $this->morphToMany('App\Tag', 'taggable');
    }
}

class Tag extends Model
{
    /**
     * 获取所有分配该标签的文章
     */
    public function posts()
    {
        return $this->morphedByMany('App\Post', 'taggable');
    }

    /**
     * 获取分配该标签的所有视频
     */
    public function videos()
    {
        return $this->morphedByMany('App\Video', 'taggable');
    }
}
# 关联查询
User::find(1)->posts()->where('')->get();
1.关联方法 vs 动态属性
2.查询存在的关联关系
Post::has('comments')->get();
3.无关联结果查询
Post::doesntHave('comments')->get()


# 渴求式加载
以属性方式访问Eloquent关联关系时，是懒惰式加载的。
1.渴求式加载多个关联关系
Book::with('author', 'publisher')->get()
2.嵌套渴求式加载
Book::with('author.contacts')->get()
3.渴求式加载指定字段
Book::with('author:id,name')->get()

# 插入&更新关联模型
1.save方法
$post->comments->save()
$post->comments->saveMany()
2.递归保存模型&关联关系
$post = Post::find(1)
$post->comments[0]->message = '';
$post->comments[0]->author->name = '';
$post->push();
3.create方法
$post->comments->create()
$post->comments->createMany()
4.从属关联关系
$account = Account::find(10)
$user->account()->associate($account) // 设置外键
$user->save() 
$user->account()->dissociate() // 将外键设置为null
5.默认模型
belongsTo关联关系允许在给定关联关系为null的情况下定义一个默认的返回模型，称为空对象模式。
public function user() {
	return $this->belongsTo('App\Models\User')->withDefault(function($user) {
		$user->name = '';
	});
}
# 多对多关联
$user = User::find(1);
$user->roles->attach($roleId);
$user->roles->attach($roleId, [$key => $value]);
$user->roles->detach($roleId) // 清除指定角色
$user->roles->detach() // 清除所有角色


## 集合
Eloquent返回的包含多条记录的结果集都是Collection对象的实例。包括通过get方法或者通过访问关联关系获取的结果。
# 可用方法
1.集合基类
所有Eloquent集合继承自Laravel集合对象基类
集合方法查看文档
# 自定义集合
重写模型类上的newCollection方法


## 访问器和修改器
允许在获取模型属性或设置其值时格式化Eloquent属性。
# 访问器 & 修改器
1.定义访问器
需要在模型中创建一个getFooAttribute方法，其中Foo是想要访问的字段名（使用驼峰式命名规则）。
public function getFullNameAttribute() {
	return "{$this->first_name} {$this->last_name}";
}
2.定义修改器
定义setFooAttribute方法，Foo是想要修改的字段（采用驼峰命名规则）
public function setFirstNameAttribute($value) {
	$this->attributes['first_name'] = strtolower($value);
}
# 日期修改器
默认情况下，Eloquent将会转换日期为Carbon实例，继承自PHP原生的Datetime类。
如果字段是日期格式时，可以将其值设置为UNIX时间戳，日期字符串（Y-m-d），日期-时间字符串，Datetime/Carbon实例。日期的值将会以正确格式存储到数据库中
当获取被罗列在$dates数组中的属性时，自动转换为Carbon实例，允许在属性上使用任何Carbon类方法
1.日期格式化
默认情况下，时间戳的格式为Y-m-d H:i:s，如果需要自定义时间戳格式，设置$dateFormat属性 决定日期属性存储在数据库以及序列化为数组或JSON时的格式
# 属性转换
模型中的$casts属性为属性字段转换到通用数据类型提供了便利方法。$casts属性是数组格式，键时要被转换的属性名称，值时想要转换的类型。目前支持的转换类型包括:integer、real、float、double、decilmal:<digits>、string、boolean、object、array、collection、date、datetime和timestamp
例如
$casts = [
	'is_admin' => 'boolean', // 将数据库中的1或0 转换为 true和false
]
1.数组 &　JSON转换
array类型转化在处理被存储为序列化JSON格式的字段时特别有用。
2.日期转换
date或datetime转换类型时 可以指定日期的格式
$casts = [

];

## API资源类
构建API时，Eloquent模型和最终返回给应用用户的JSON响应之间可能需要一个转化层。资源类允许以简单优雅的方式将模型和模型集合转化为JSON格式数据
# 生成资源类
使用
php artisan make:resource User
默认情况下，资源类放在应用的app/Http/Resources目录下， 资源都继承自JsonResource基类
1.资源集合
除了生成转化独立模型的资源类之外，还可以生成转化模型集合的资源类。响应就可以包含链接和其他与整个给定资源集合相关的元信息。
创建资源集合处理类，在创建资源类的时候使用--collection标记，或者在资源名称中包含单词Collection已告知Laravel需要创建一个资源集合类。资源集合类继承自ResourceCollection基类
php artisan make:resource User --collection
php artisan make:resouce UserCollection
# 核心概念
一个资源类表示一个单独的需要被转化为JSON数据结构的模型
class User extends JsonResource {
	pulbic function toArray($request) {
		return [
			'id' => $this->id,
			'name' => $this->name,
			'email' => $this->email,
			'created_at' => $this->created_at,
			'updated_at' => $this->updated_at,
		];
	}
}
每个资源类都包含一个toArray方法用来返回在发送响应时需要被转化JSON的属性数组。可以直接使用$this访问模型属性，因为资源类是一个代理，可以访问底层对应模型提供的属性和方法。资源类定义好之后，可以从路由或控制器返回
use App\Http\Resources\User as UserResource;
Route::get("/user/{id}", function($id) {
	return new UserResource(User::get($id));
});
# 资源集合
需要返回资源集合或者分页响应，可以在路由或控制器中创建资源实例时使用collection方法。
当然，这种方式不能添加出模型外的其他需要和集合一起返回的元数据。此时需要创建专用的资源类来表示集合
php artisan make:resource UserCollection
# 保留集合键
当从路由返回资源集合时，Laravel会重置集合的键以便按照数字索引排序。可以添加preserveKeys属性到资源类来标识对应集合键是否保留
$preserveKeys = true;
UserResource::collection(User::all()->keyBy->id);
true时返回有键值数组 false返回所有数组
# 自定义底层资源类
通常资源集合的$this->collection属性会被自动填充，填充结果是将集合的每个项目映射到对应的单一资源类中。这个单一资源类被假设为不带Collection后缀的集合类名
例如UserCollection会尝试映射给定用户实例的User资源，如果需要自定义，可以覆盖$collection属性
$collections = 'App\Http\Resources\Member';
# 编写资源类
资源类的作用就是将给定模型转化为数组，都包含toArray方法。用于将模型属性转化为一个可以返回给用户的API友好的数组
1.关联关系
可以关联关系添加到数组中
public function toArray($request) {
	return [
		'id' => $this->id,
		'posts' => PostResource::collection($this->posts),
	];
}
2.资源集合
资源类用于将单个模型转化为数组，资源集合类用于将模型集合转化为数组，但不是每个模型都需要定义一个资源集合类，因为资源类提供了一个collection方法立马生成一个特定的资源集合
3.数据包装
默认情况下，资源响应被转化为JSON时，最外层的资源都会包裹到一个data键中
如果想要禁止包装，可以调用资源基类提供的withoutWrapping方法，需要在AppServiceProvider或者其他每个请求都会加载的服务提供者中调用这个方法
class AppServiceProvider extends Provider {
	public function boot() {
		Resource::withoutWrapping();
	}
}
withoutWrapping值影响最外层资源，并不会移除手动添加的data键
4.包装嵌套资源
可以自行决定包装资源的关联关系，如果想要所有资源集合包裹到data键里，而不管之间的嵌套，就需要为每个资源定义一个资源集合类并通过data键返回这个集合。
class CommentsCollection extends ResourceCollection {
	public function toArray($request) {
		return ["data" => $this->collection];
	}
}
5.数据包装和分页
{
    "data": [
        {
            "id": 1,
            "name": "Eladio Schroeder Sr.",
            "email": "therese28@example.com",
        },
        {
            "id": 2,
            "name": "Liliana Mayert",
            "email": "evandervort@example.com",
        }
    ],
    "links":{
        "first": "http://example.com/pagination?page=1",
        "last": "http://example.com/pagination?page=1",
        "prev": null,
        "next": null
    },
    "meta":{
        "current_page": 1,
        "from": 1,
        "last_page": 1,
        "path": "http://example.com/pagination",
        "per_page": 15,
        "to": 10,
        "total": 10
    }
}
1)传递分页器实例到资源类的collection方法或者自定义的资源集合类
UserResource::collection(User::paginate());
new UserCollection(User::paginate());
2)带条件的属性
如果希望只有在满足给定条件的情况下才在资源响应中包含某个属性 使用when方法
return [
	'secret' => $this->when($this->isAdmin(), 'secret-value'),
]
可以传入闭包作为第二参数
6.合并带条件的属性
可能有多个属性基于同一条件才会包含到资源响应中
return [
	$this->mergeWhen(Auth::user->isAdmin(), [
		'first-secret' => 'value',
		'second-secret' => 'value',
	])
];
false 属性将被移除而不是显示null
# 带条件的关联关系
还可以基于给定关联关系是否在模型上加载的条件在资源响应中包含关联关系
return [
	'posts' => PostResource::collection($this->whenLoaded('posts')),
];
只有posts属性已经加载过才会包含在资源响应中，否则被移除
1.带条件的中间表信息
return [
	'expires_at' => $this->whenPivotLoaded('role_users', function() {
		return $this->pivot->expires_at;
	}),
];
# 添加元数据
需要返回额外元数据，可以在toArray方法中包含
自定义的额外键都会合并而不是被覆盖
1.顶层元数据
希望只在资源最外层被返回数据的情况下包含元数据，需要添加一个with方法到资源类中。
public function with($request) {
	reutrn [
		'meta' => [
			'key' => 'value'
		]
	]
}
2.构造资源类时添加元数据
return (new UserResource(User::find(1)))->additional(['a' => 'b']);
# 资源响应
可以从路由或控制器中返回
有时候可能需要发送到客户端之前自定义输出HTTP响应，两种方法
1.连接response方法到资源类
return (new UserResource(User::find(1)))->response()->header('', '');
2.在资源类中定义withResponse方法
public function withReponse($request, $response) {
	$reponse->header('', '');
}

## 序列化
# 序列化为数组
$user->toArray()
# 序列化为JOSN
$user->toJson(); 
(string) $user; // 自动调用toJson方法
# 在JSON中隐藏属性
$hidden 属性
protected $hidden = ['password']; // 隐藏
protected $visiable = ['first_name', 'last_name']; // 显示
2.临时暴露隐藏属性
$user->makeVisiable('attr')
# 追加值到JSON
先定义一个访问器
再使用$appends属性 会遵循hidden visiable数组
2.运行时追加
$user->append('')
# 日期序列化
1.自定义每个属性的日期格式
$casts = [
	'updated_at' => 'date:Y-m-d',
	'joined_at' => 'datetime:Y-m-d H:00',
]
2.通过Carbon全局自定义
public function boot()
{
	Carbon::serializeUsing(function ($carbon) {
		return $carbon->format('U');
	});
}



### 进阶
## Artisan控制台
# 简介
Artisan是Laravel自带的命令行接口，提供了很多有用的命令
php artisan list  // 查看所有可用的Artisan命令
每个命令都可以使用help指令显示命令描述及命令参数和选项。
php artisan help migrate
1.Tinker(REPL)
允许通过命令行与整个Laravel应用进行交互，包括Eloquent ORM、任务、事件等等。要进入tinker环境，运行tinker命令即可
php artisan tinker
可以使用vendor:publish 命令发布Tinker的配置文件
php artisan verdor:publish --provider="Laravel\Tinker\TinkerServiceProvider"
2.命令白名单
判断哪些artisan命令可以在Shell中运行，默认情况下，可以运行clear-compiled、down、env、inspire、migrate、optimize和upmingl，需要更多则在config/tinker.php配置文件中的commands数组中添加
3.别名黑名单
Tinker会根据需要自动为类设置别名，可能希望永远不为某些类添加别名。在dont_alias数组中添加这些类
# 编写命令
1.生成命令
使用make:command命令在app/Console/Commands目录下创建新的命令类
php artisan make:command SendEmails
2.命令结构
需要填写
signature
description
在调用list实现命令的时候会被用到
handle方法在命令执行时调用
可以在构造函数和handle方法中注入任何需要的依赖
3.闭包命令
基于闭包的命令和闭包路由之于控制器一样，以类的方式定义控制台命令提供了可选方案。
在app/Console/Kernel.php文件中的commands方法中，加载routes/console.php文件
在这个console.php文件中使用Artisan::command方法定义所有基于闭包的路由 接受两个参数-命令标识和接收命令参数和选项的闭包
Artisan::command('build {project}', function($project) {
	$this->info("Building {$project}!");
});
4.类型提示依赖
还可以根据类型提示服务容器之外解析的额外依赖
5.闭包命令描述
Artisan::command('', function() {

})->describe('');
# 定义期望输入
signature属性通过一个优雅的、路由风格的语法允许定义命令的名称、参数以及选项
1.参数
protected $signature = 'email:send {user}';
protected $signature = 'email:send {user?}'; // 可选
protected $signature = 'email:send {user=foo}'; // 默认
2.选项
protected $signature = 'email:send {user} {--queue}'; // 传入选项为true 否则false
3.带值的选项
protected $signature = 'email:send {user} {--queue}'
protected $signature = 'email:send {user} {--queue=default}' // 默认
4.选项简写
protected $signature = 'email:send {user} {--Q|queue}'
5.输入数组
protected $signature = 'email:send {user*}';
protected $signature = 'email:send {user*} {--I|id=*}';
6.输入描述
protected $signature = 'email:send {user : 说明} {--queue : 说明}'
# 命令IO
1.获取输入
public function handle() {
	$this->argument(''); 指定名称参数
	$this->arguments(); 所有参数
	$this->option(''); 指定名称选项
	$this->options(); 所有选项
}	
2.输入提示
可能还在命令执行期间要用户提供输入ask方法
$name = $this->ask('What is your name?');
secret方法 输入不可见
3.让用户确认
confirm方法 默认返回false 输入y则返回true
4.自动完成
anticipate方法提供选项自动完成，用户仍然可以自行输入
5.让用户选择
choice('', [], 0)
# 编写输出
$this->line/info/comment/question/error
$this->table($th, $tb) // 表格
进度条
$bar = $this->output->createProgressBar($count);
$bar->start(); // 开始计时
for($index = 0; $index < 10000; $index++) {
	$bar->advance(); // 计时+1 
}
$bar->finish();
# 注册命令
Console Kernel自动调用load方法，所有app/Console/Commands目录下的命令都会通过Artisan自动注册，可以额外调用load注册其他目录下的命令
# 通过代码调用命令
Artisan::call('command_name', [$argument => $value, --$option=>$value]);

## 广播
# 简介
Laravel事件提供了简单的观察者模式实现。允许订阅和监听应用中的事件。事件类通常存放在app/Events目录，监听器存放在app/Listeners。
为应用功能解耦提供了行之有效的解决办法,因为单个事件可以有多个监听器而这些监听器之间并不相互依赖。
# 注册事件/监听器
Laravel自带的EventServiceProvider为事件监听器注册提供了方便之所，其中的listen属性包含了事件(键)和对应监听器(值)数组。多个添加多个事件到该数组。
1.生成事件/监听器类
只需要添加监听器和事件到EventServiceProvider然后运行event:generate命令。会生成罗列在EventServiceProvider中的所有事件和监听器，已存在的不会重复创建
php artisan event:generate
2.手动注册事件
通常通过$listen数组注册事件，还可以在boot方法中手动注册基于闭包的事件。
public function boot() {
	parent::boot();
	Event::listen('event.name', function($foo, $bar) {
	
	});
}
3.通配符事件监听器
可以使用通配符*来注册监听器，这样可以通过同一个监听器捕获多个事件，通配符监听器接受整个事件数据数组作为参数
$events->listen('event.*', function($eventName, array $data) {

});
# 定义事件
事件类是一个处理与事件相关的简单数据容器，例如OrderShipped事件接受一个Eloquent ORM对象
class OrderShipper {
	use SerializeModels;
	
	public $order;
	
	public function __construct(Order $order) {
		$this->order = $order;
	}
}
事件类可以不包含任何特定逻辑，只是一个存放被购买的Order对象的容器，如果事件对象被序列化的话，使用的SerializeModels trait将会使用PHP的serialize函数序列化所有Eloquent模型
# 定义监听器
事件监听器在handle方法中接受事件实例，event:generate命令将会自动在handle方法中导入相应的事件类和类型提示事件。
class SendShipmentNotification {
	public function __construct() {
	
	}
	
	public function handle(OrderShipped $event) {
		// $event->order
	}
}
可以在构造函数中类型提示任何需要的依赖，所有事件监听器通过服务容器解析，依赖会自动注入
1.停止事件继续往下传播
可以通过在handle方法中return false来实现
# 事件监听器队列
如果监听器将要执行耗时任务比如发送邮件或者发送HTTP请求，可以放入监听器队列，需要确保已经配置好队列并且在服务器或本地环境启动一个队列监听器。
要指定某个监听器需要放到队列，需要让监听器类实现ShouldQueue接口，event:generate命令已经导入接口
实现接口的监听器调用时，将会使用队列系统通过事件分发器自动推送到队列，如果通过队列执行监听器没有抛出异常，则在执行后自动删除
1.自定义队列连接 & 队列名称
定义$connect $queue和$delay属性
$connection = 'sqs'; // 任务推送到的连接名称
$queue = 'listeners'; // 任务推送到的队列名称
$delay =60; // 任务被处理之前的延迟时间(s)
1.手动访问队列
如果需要手动访问底层队列任务的delete和release方法，在生成的监听器中，默认导入的InteractsWithQueue提供了访问方法
$this->release()
2.处理失败任务
监听器上的failed方法
public function failed(OrderShipper $event, $exception) {

}
# 分发事件
使用event辅助函数，这个辅助函数会分发事件到所有注册的监听器，event辅助函数全局有效
event(new OrderShipper($order));
# 事件订阅者
指在类本身中订阅多个事件的类，通过事件订阅者可以在单个类中定义多个事件处理器。订阅者需要定义一个subscribe方法，传入一个事件分发器实例，可以在给定的分发器中调用listen方法注册事件监听器
class UserEventSubscriber {
	public function handleUserLogin($event) {
	
	}
	public function handleUserLogout($event) {
	
	}
	public function subscribe($events) {
		$events->listen('事件类的命名空间', '订阅者的命名空间@订阅者的处理方法');
	}
}
class EventServiceProvider extends ServiceProvider {
	$subscribe = [
		'订阅者类的命名空间',
	];
}


## 文件存储
PHP包FlySystem提供文件系统驱动。
# 配置
文件系统配置位于config/filesystem.php，可以配置所有磁盘，每个磁盘描述了特定的存储驱动和存储路径。
# 公共磁盘
public磁盘用于存储可以被公开访问的文件，默认情况下，public磁盘使用local驱动并将文件存储在storage/app/public目录下，要让这些文件可以通过Web浏览器访问，需要创建一个软连接，将public/storage指向storage/app/public，这种方式可以将公开访问的文件保存在一个很容易被不同部署环境共享的目录。
创建软链接 使用
php artisan storage:link
文件被存储并且已经被创建的情况下，可以使用辅助函数asset创建一个指向该文件的URL
asset('storage/file.txt')
# 本地驱动
使用local驱动的时候，所有文件操作都相对于定义在配置文件的root目录，默认情况下，设置为storage/app目录。
Storage::disk('local')->put('file.txt', 'Contents');
# 驱动预备知识

# 获取硬盘实例
使用Storage门面和配置的任意磁盘进行交互
Storage::put('', ); // 使用默认磁盘
Storage::disk()->put('', ); // 指定磁盘存放数据到文件
# 获取文件
Storage::get()
Storage::disk()->get()
Storage::exists()
1.下载文件
Storage::download('',$name,$headers);
2.文件URL
Storage::url('');
3.临时URL
4.自定义本地主机URL
添加url选项到磁盘配置数组
'public' => [
	'url' => env('APP_URL').'/storage',
]
5.文件元信息
Storage::size('') // 文件大小
Storage::lastModified('') // 最后修改时间
# 存储文件
put方法可以用于存储原生文件内容到磁盘，还可以传递一个PHP资源到put方法，将会使用FlySystem底层的流支持
Storage::put('file', $contents)
1.自动文件流
Laravel自动将给定文件流输出到对应存储路径，可以使用putFile或putFileAs方法，该文件接收File或UploadedFile实例，然后自动将文件流保存到期望的路径
Storage::putFile('newPath', new File($oldFile)) // putFile会基于文件内容自动生成文件名，实现原理是对文件内容进行MD5哈希运算。会返回文件路径，包含文件名
Storage::putFile('newPath', new File($oldFile), 'newFileName') // 使用指定名称存储文件
putFile和putFileAs还可以传入用于指定可见度的参数
2.添加内容到文件开头/结尾
Storage::append('fileName', $content)
Storage::prepend('fileName', $content)
3.拷贝 &  移动文件
Storage::copy('old', 'new')
Storage::move('old', 'new')
# 文件上传
$request->file('uploadFileName')->storage('storageFilePath')
默认会根据上传文件内容自动生成文件名，
Storage::putFile('newPath', $request->file(''))
1.指定文件名
$request->file('')->storageAs('newPaht', '')
Storage::putFileAs('newPaht', $request->file(''), 'newFileName')
2.指定磁盘
$request->file('')->storage('newfilePath', 'newFileName', 'disk')
# 文件可见度
Storage::put('filename', $content, 'public);
Storage::setVisibility('filename', 'private')
# 删除文件
Storage::delete('')
Stroage::delete([])
# 目录
1.获取一个目录下的所有文件
files方法返回给定目录下的所有文件数组，包括子目录下的文件则需要使用allFiles方法
Storage::files('path')
Storage::allFiles('path')
2.获取一个目录下的所有子目录
Storage::directories($paht)
Storage::allDirectories($path)
3.创建目录
Storage::makeDirectory('')
4.删除目录
Storage::deleteDirectory('')
# 自定义文件系统

## 辅助函数
*****  暂时未看比较多 **********

## 邮件
# 生成可邮寄类
应用发送的邮件都可以表示为可邮寄类，存放在app/Mail目录下
php artisan make:mail OrderShipped

# 编写可邮寄类
所有可邮寄类都在build方法中完成，可以调用多个方法，例如from、subject、view和attach来配置邮件的内容和发送
1.from方法
配置发件人，两种方法
1）在可邮寄类的build方法中使用from方法
public function build() {
	$this->from('example@example.com').view('');
}
2）使用全局的from地址
如果应用所有邮件都使用相同的发送地址，可以在config/mail.php中指定一个全局的发送地址，可用于在所有可邮寄类中没有指定发送地址的场景下（默认发件人）
'from' => ['address' => 'example@example.com', 'name' => 'App Name']
此外还可以在配置文件中定义全局的回复地址
'reply_to' => ['address' => 'example@example.com', 'name' => 'App Name']
# 配置视图
在可邮寄类的build方法中使用view方法来指定渲染邮件内容的视图模板，通常使用Blade 模板来渲染内容，可以在构建邮件HTML使用Blade模板引擎提供的所有功能
1.纯文本邮件
定义纯文本格式的邮件，可以使用text方法，和view方法一样，接受一个用于渲染邮件内容的模板名。
# 视图数据
1.通过公共属性
在可邮寄类中的公共属性在视图中自动生效。
2.通过with方法
通过with方法手动传递数据到视图，一般情况下，还需要通过构造器传递数据。不过，这里需要设置数据为protected或private属性，这些数据不会在视图中自动生效。当调用with方法时，传递数组数据到该方法以便数据在视图模板中生效。
3.附件
如果需要添加附件，可以在可邮寄类的build方法中使用attach方法，接受完整文件路径作为第一个参数
public function build() {
	$this->view('')->attach('/path');
}
附加文件到消息时，还可以通过传递一个数组作为attach方法第二个参数来指定文件显示名或MIME类型
public function build() {
	$this->view('')->attach('/path', [
		'as' => 'name.jpg',
		'mime' => 'application/jepg',
	]);
}
4.添加磁盘文件
使用attachFromStorage
return $this->view('')->attachFromStorage('')
同时第二个数组参数用于指定文件名和MIME类型
return $this->view('')->attachFromStorage('', [
	'as' => 'test.jpg',
	'mime' => 'application/jepg',
])
5.指定磁盘而不是默认磁盘中的文件
使用attachFromStorageDisk
return $this->view('')->attachFromStorage('', '', [
	'as' => 'test.jpg',
	'mime' => 'application/jepg',
])
第一个参数是指定磁盘名称 第二个是文件名 第三个指定附件名和MIME类型
6.原生数据附件
attachData方法可用于添加原生的字节字符串作为附件，第一个参数为数据字节，第二个参数是附件文件名，第三个参数则是可选数组
return $this->view('')->attachData(byteArr, 'fileName', [])
7.内联附件
在模板中使用$meesage变量的embed方法
{{ $message->embed('') }}
8.嵌入原生数据附件
在模板中使用$message变量的embedData方法
{{ $message->embedData($data, $name) }}
# 自定义SwiftMailer消息
Mailable基类上的withSwiftMessage方法允许注册一个在发送消息之前可以被原生SwiftMailer消息实例调用的回调，赋予了在发送消息之前定制消息的机会
public function build() {
	$this->view('');
	$this->withSwiftMessage(function($message) {
		$message->getHeaders()->addTextHeader('', '');
	});
}
# Markdown邮件类
Markdown邮件消息允许在可邮寄类中利用预置模板和邮件通知组件。以Markdown格式编写，Laravel可以渲染出良好的HTML模板，同时自动生成纯文本副本
1.生成Markdown邮件类
php artisan make:mail OrderShipped --markdown=email.orders.shipped
调用可邮寄类的build方法 使用markdown方法取代view方法。markdown方法接收Mardown模板的名称和一个可选的模板中生效的数组数据
2.编写Markdown消息
Markdown邮件类组合使用Blade组件和Markdown语法，
@component('mail::message')
# Order Shipped

Your order has been shipped!

@component('mail::button', ['url' => $url])
View Order
@endcomponent

Thanks,<br>
{{ config('app.name') }}
@endcomponent
3.按钮组件
渲染一个居中的按钮链接，接收两个参数，url和可选的color，支持的color有primary、success和error，可以添加任意数量的按钮到消息中
@component('mail::button', ['url' => '', 'color' => ''])
4.面板组件
将给定的文字区块渲染到一个面板中，并且与周围的消息区分
@component('mail::panel')
5.表格组件
允许将Markdown表格转化为HTML表格
@component('mail::table')
| Laravel       | Table         | Example  |
| ------------- |:-------------:| --------:|
| Col 2 is      | Centered      | $10      |
| Col 3 is      | Right-Aligned | $20      |
@endcomponent
6.自定义组件
php artisan vendor:publish --tag=laravel-mail
将Markdown邮件组件到resources/views/vendor/mail目录下。包含html和text目录，每个子目录中有包含各自的所有有效组件
7.自定义css
# 发送邮件
使用Mail门面上的to方法，to方法接受邮箱地址、用户实例或用户集合作为参数。如果传递的是对象或者对象集合，在设置邮件人的时候邮件会自动使用email和name属性，实现要确保这些属性在相应类上有效。指定收件人之后，传递一个可邮寄类实例到send方法
Mail::to('xxx@xx.com')->send(new OrderShipped());
发送邮件不仅限于单个收件人，还可以通过单个方法链调用设置to、cc以及bcc方法
# 渲染可邮寄类

# 邮件队列
1.邮件消息队列
由于发送邮件会大幅度延长应用的响应时间，使用后台发送。可以使用内置的统一队列API来实现这一功能。要将邮件消息推送到队列，可以在指定消息的接受者后使用Mail门面的queue方法。
Mail::to('')->queue(new OrderShipped());
自动将邮件任务推送到队列以便后台发送，需要配置队列
2.延迟消息队列
指定延迟时间发送，使用later方法
Mail::to('')->later($time, new OrderShipped())
3.推送到指定队列
使用make:mail命令生成的可邮寄类使用Queueable trait，可以调用onQueue和onConnection方法，以便为消息指定连接和队列名称
$message = (new OrderShipped())->onConnection('')->onQueue('');
Mail::to('')->queue($message);
4.默认队列
实现了ShouldQueue契约，即使调用send方法也会被推送到队列中。

# 事件
在发送邮件消息前触发两个事件，MessageSending事件在消息发送前触发，MessageSent在消息发送后触发。是在邮件被发送前后触发，而不是推送到队列时触发。

## 通知
除了发送邮件，还支持多种传输通道发送通知。
# 创建通知
php artisan make:notification InvoiePaid
# 发送通知
1.使用Notifiable Trait
use Notifiable;
$user->notify(new InvoicePaid());
2.使用Notification门面
Notification::send($users, new InvoicePaid())

## 队列
为不同的后台队列服务提供了统一的API
配置文件在config/queue.php中
# 连接 VS 队列
配置中有connections配置项，定义了后台队列服务的特定连接。
每个连接配置示例都有queue属性，新队列任务被添加到指定连接时，该配置项的值就是默认监听的队列。
支持优先级排序
php artisan queue:work --queue=high,default
# 驱动预备知识
1.数据库
php artisan queue:table
php artisan migrate
2.redis
需要在database中配置Redis数据库连接

# 创建任务
1.生成任务类
php artisan make:job ProcessPodcast
2.任务类结构
通常只包含处理该任务的handle方法
# 分发任务
可以通过任务自身的dispatch方法将其分发到队列中，
ProcessPodcast::dispatch($podcast);
1.延迟分发
ProcessPodcast::dispatch($podcast)->delay(now()->addMinutes(10));
2.同步分发
ProcessPodcast::dispatchNow($podcast);
对应任务不会被推送到任务队列，而是立即执行
3.任务链
在一个序列中执行的队列任务列表，如果某个任务失败，则其他任务不再运行，使用withChain方法
ProcessPodcast::withChain([
	Podcast1,
	Podcast2,
])->dispatch();
4.链接连接 & 队列
allOnConnection和allOnQueue方法
5.自定义队列 & 连接
分发到指定的队列
通过推送任务到不同队列，可以将队列任务进行分类，甚至根据优先级来分配每个队列的进程数
onQueue方法
分发到指定的连接
onConnection方法
6.指定最大失败次数/超时时间
php artisan queue:work --tries=3
可以在任务类自身定义最大失败次数来实现更加细粒度的控制
public $reties = 5;
7.基于时间的尝试次数
添加retryUntil方法
public function retyUntil() {
	return now()->addSecods(5);
}
8.超时
php artisan queue:work --timeout=30
可以在任务类中定义细粒度的超时时间
public $timeout = 120;
9.频率限制
要求应用可以与Redis进行交互
***** 未看 *************
10.处理错误
如果任务在处理的时候有异常抛出，则该任务将会自动释放会队列以便尝试执行。任务会持续被释放直到尝试次数达到应用允许的最大次数。
# 队列闭包
$podcast = App\Podcast::find(1);
dispatch(function() as ($podcast) {
	$podcast->publish();
});
# 运行队列进程
php artisan queue:work
1.指定连接和队列
php artisan queue:work database // 使用指定连接
php artisan queue:work --queue=emails // 只处理单一队列
php artisan queue:work --onve // 只处理队列中的单一任务
php artisan queue:work --stop-when-empty // 处理全部任务后退出
2.队列优先级
dispatch((new Job)->onQueue('high'))
php artisan queue:work --queue=high,low
# 队列进程 & 部署
php artisan queue:restart
完成正在进行的任务后，结束该进程，避免队列任务的丢失或错误。
# 任务过期 & 超时
1.任务过期
queue.php配置文件中每个连接配置retry_after项，定义任务在执行后多少秒后释放会队列。
2.队列进程超时
php artisan queue:work --timeout=60
队列进程中每个任务最长执行时间，如果超时就关闭进程。
3.进程休眠时间
php artisan queue:work --sleep=3
可以使用sleep配置项来指定没有新的有效任务产生时的休眠时间，休眠期队列不会处理新任务直到队列醒来。
# 配置Supervisor
Linux中常见的守护程序。
# 处理失败的任务
如果执行次数达到限定次数，任务将会被插入failed_jobs表
php artisan queue:failed-table
php artisan migrate
1.清理失败任务
可以在任务类中定义failed方法，在失败发生时执行指定的动作，比如发送任务失败的通知，记录日志等。导致任务失败的Exception会被传递到failed方法中。
public function failed(Exception $exception) {

}
2.任务失败事件
如果希望在任务失败时触发某个事件，可以使用Queue::failling方法
Queue::failling(function(JobFailed $event) {
	
});
3.重试失败的任务
php artisan queue:failed // 列出失败任务
php artisan queue:retry 5 // 重试id为5的任务
php artisan queue:retry all // 重试所有任务
php artisan queue:forget 5 // 删除id为5的任务
php artisan queue:flush // 删除所有失败任务

# 任务事件
Queue门面提供的before和after方法可以在任务被处理之前和之后指定要执行的回调，可以用于记录日志或者记录统计数据。
Queue::before(function (JobProcessing $event) {
	// $event->connectionName
	// $event->job
	// $event->job->payload()
});

Queue::after(function (JobProcessed $event) {
	// $event->connectionName
	// $event->job
	// $event->job->payload()
});

## 任务调度
Cron
# 定义调度
在App\Console\Kernel类的schedule方法中定义所有调度任务
1.调用Artisan命令
$schedule->command('email::send --force')->daily();
$schedule->command(EmailsCommand ,['--force'])->daily();
2.调度队列任务
$schedule->job(new Heartbeat, 'heartbeats')->everyFiveMinutes();
3.调用shell命令
$schedule->exec('node /home/forge/script.js')->daily();
4.调度常用选项
->cron('* * * * *');	在自定义Cron调度上运行任务
->everyMinute();	每分钟运行一次任务
->everyFiveMinutes();	每五分钟运行一次任务
->everyTenMinutes();	每十分钟运行一次任务
->everyFifteenMinutes();	每十五分钟运行一次任务
->everyThirtyMinutes();	每三十分钟运行一次任务
->hourly();	每小时运行一次任务
->hourlyAt(17);	每小时第十七分钟运行一次任务
->daily();	每天凌晨零点运行任务
->dailyAt('13:00');	每天13:00运行任务
->twiceDaily(1, 13);	每天1:00 & 13:00运行任务
->weekly();	每周运行一次任务
->monthly();	每月运行一次任务
->monthlyOn(4, '15:00');	每月4号15:00运行一次任务
->quarterly();	每个季度运行一次
->yearly();	每年运行一次
->timezone('America/New_York');	设置时区
可以和额外的约束一起联合起来创建一周特定时间运行的、更加细粒度的调度
->weekdays();	只在工作日运行任务
->weekends();	只在周末运行任务
->sundays();	每个星期天运行任务
->mondays();	每个星期一运行任务
->tuesdays();	每个星期二运行任务
->wednesdays();	每个星期三运行任务
->thursdays();	每个星期四运行任务
->fridays();	每个星期五运行任务
->saturdays();	每个星期六运行任务
->between($start, $end);	基于特定时间段运行任务
->when(Closure);	基于特定测试运行任务
->environments($env);	只在指定环境运行任务














