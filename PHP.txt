********** PHP ********************
### 初识PHP
## 概述
PHP语法结构简单，易于入门，很多功能只需要一个函数即可
# 什么是PHP
是一种服务器端、跨平台、HTML嵌入式的脚本语言，独特的语法混合了C语言、Java语言和Perl语言的特点，广泛应用的开源式的多用途脚本语言，尤其适合Web开发
# PHP的优势
1.安全性高
2.跨平台性
3.支持广泛的数据库
4.易学性
5.执行速度快
6.免费
7.模板化
8.支持面向对象与过程
9.内嵌Zend加速引擎


### PHP语言基础
## PHP标记风格
XML风格
<?
/*
 PHP代码
*/
?>
脚本风格
<script language="php">
/* 
PHP代码
*/
</script>
简短风格
<? /*PHP代码*/ ?>
ASP风格
<%
/*
PHP代码
*/
%>
## PHP注释的应用
单行注释 //
多行注释 /**/
文档注释 /****/
#风格的注释 # 
## PHP的数据类型
PHP支持8种原始类型，包括4种标量类型，即boolean、integer、fload/double和string，2种符合类型，即array和object，2种特殊类型resource和null
# 标量数据类型
标量数据类型是数据结构汇总最基本的单元，只能存储一个数据。
boolean 		最简单的类型，只有两个值true/false
string			字符串就是连续的字符序列，可以是计算机所能表示的一切字符的集合
integer			整数数据类型只能包含整数，可以是正数和负数
float			浮点数据类型用于存储数字，和整型不同的是有小数位
1.boolean
$param = true;
除了false之外，还有0、0.0、"0"、空白字符串""、只声明未赋值的数组等
2.string
连续的字符序列，由数字、字母和符号组成。字符串中的每个字符只占用一个字节。PHP中有3种定义字符串的方式，单引号、双引号和定界符(<<<)
*
注意
对非转义字符使用\，在输出时将输出\
在定义简单的字符时，应该使用单引号，双引号PHP将花费一定时间来处理字符串的转义和变量解析。
*
$string = <<<str 
	字符串
	可以多行
str // str表示标识符 指定开始和结束 结束时必须另起一行并且不能包含空格
3.integer
32位系统中 范围为-2^31 ~ 2^31-1
可以用二进制、八进制、十进制和十六进制。八进制需要0前缀，十六进制需要0x前缀
如果超出了integer类型的范围，则会获得float类型
4.float
可以存储数字，也可以存储小数，提供的精度比整数大的多。在32位系统中，有效的范围是1.7E+308(PHP4.0版本之前是double)
两种书写方式
标准格式
3.1415
科学计数法
3.58E1
849.72E-3
浮点型的数值只是一个近似值，尽量避免浮点整数型之间的比较大小，这样的结果往往是不准确的
# 符合数据类型
array 			一组类型相同的变量的集合
object			对象是类的实例，使用new命令来创建
1.array
一组数据的集合，形成一个可操作的整体。
每个数据成为一个元素，包括索引和键值两个部分，元素的索引可以由数字或字符串支持。值则可以是多种数据类型
定义数组的语法格式
$array = array(value1, value2....);
$array[key] = value;
$array = array(key1 => value1, key2 => value2, ...);
声明之后可以自由更改，只要给数组赋值就会自动增长。
2.object
之后详解
# 特殊数据类型
resource			资源是一种特殊变量，保存了到外部资源的一个引用，资源是通过专门的函数来建立和使用的
null				特殊的值，表示变量没有值，唯一的值就是null
1.resource
PHP4引入，使用资源时，系统会自动启用垃圾回收机制，释放不再使用的资源，避免内存消耗殆尽。因此，资源很少需要手工释放
2.null
表示没有设置任何值 不区分大小写
被赋予空值的情况
还没有赋值
被赋值null
被unset()函数处理过的变量
is_null()函数用于判断变量是否为null 返回一个boolean
unset()函数用于销毁指定的变量
# 数据类型转换
(boolean)$param # null、0、未赋值的变量或数组转为false 其他true
(string)$param
(integer)$param # false转为0 true转为1 浮点型小数位直接舍去 如果以数字开头截取到数字费 否则为0
(float)$param
(array)$param
(object)$param
还可以借助settype()函数
bool settype(mixed var, string type) # 成功转换为true 失败为false
# 检测数据类型
is_bool
is_string
is_float/is_double
is_integer/is_int
is_null
is_array
is_object
is_numeric # 是否是数组组成的字符串
## PHP常量
# 声明和使用常量
常量可以理解为值不变的量。
define()函数来定义常量
define(string constant_name, mixed value, case_sensitive=false)
                常量名         值           是否大小写敏感 false敏感 true不敏感
使用常量可以使用$constant_name或者constant()函数
mixed constant(string constant_name)
判断常量是否定义defined()函数
bool defined(string constant_name)
# 预定义常量
__FILE__              默认常量 PHP程序文件名
__LINE__              默认常量 PHP程序行数
PHP_VERSION         内建常量 PHP程序版本
PHP_OS              内建常量 执行PHP解析器的操作系统名称
TRUE                真值true
FALSE               假值false
NULL                空值null
E_ERROR             指到最近的错误处
E_WARNING           指到最近的警告处
E_PARSE             指向解析语法有潜在问题处
E_NOTICE            发生不寻常处的提示但不一定是错误处
## PHP变量
# 变量声明及使用
PHP4之后无需先声明再使用 只需给变量赋值即可
$param = value; # 变量间的赋值各自使用各自的内存互不干扰
$param1 = & $param2 # 内存地址赋值
*
引用和复制的区别在于
复制将原内容复制下来 开辟一个新的内存空间来保存
而引用则是给变量的内容起个别名
*
# 变量作用域
局部变量        函数内部定义的变量 作用域在函数内部
全局变量        定义在所有函数之外的变量 作用域是整个PHP文件 但是在用户自定义函数内部不可用 如果希望在用户自定义函数内部使用全局变量 则需要使用global关键字声明
静态变量        在函数调用结束后依然保留变量值，再次回到作用域时 又可以继续使用原来的值 使用static关键字声明
# 可变变量
$a = 'b';
$b = '123';
$$a # 就指向了$b
# PHP预定义变量
详情查看资料
## PHP运算符
# 算术预算福
+ - * / %
# 字符串运算符
.将两个字符串串联起来
# 赋值运算符
=
+=
-=
*=
/=
.= # 串联字符 将右边的字符串连接到左边的变量上
%=
# 递增和递减运算符
--
++
# 位运算符
&
|
^
~
<<
>>
# 逻辑运算符
&& 或 and
|| 或 or
xor （异或)
!
# 条件运算符
?: // 三项表达式
# 运算符的优先级
详情看PDF
## PHP表达式
可以连续赋值 $a=$b=$c=1;
记住在每个表达式结尾添加分号;
## PHP函数
# 定义和调用函数
function func_name($p1, $p2, $p3...) {
    <statements>
}
# 在函数间传递参数
1.按值传递
function func_name($param1, ....) {
    func_body;
}
函数内部对参数修改不影响外部 是局部变量
2.按引用传递
function func_name(& $param1, ....) {
    func_body;
}
函数内部修改影响外部 对引用内存的修改
3.默认参数
function func_name($param1=default1, ...) {
    func_body;
}
*
有默认值的参数必须在非默认参数的右边
*
# 返回值
function func_name($param1, ...) {
    func_body;
    return xxx;
}
# 变量函数
$func = 'func_name'; # 给一个变量赋值为一个函数
$func(); # 通过变量调用对应的函数
## 编码规范
# PHP命名规则
1.类命名
使用大写字母作为词的分隔，其他字母均使用小写
名字的首字母大写
不要使用下划线
class Name {

}
2.类属性命名
属性命名应该以字符m为前缀
前缀m后采用与类命名一致的规则
m总是在名字开头起修饰作用
$mName
3.方法命名
命名规范与类命名规范一致
4.方法中参数命名
第一个字符使用小写
首字符后的所有字符都按照类命名规则首字符大写
5.变量命名
所有字母小写
使用_作为每个词的分界
6.引用变量
带有r前缀
7.全局变量
带有g前缀
8.常量/全局变量
应该全部使用大写 单词之间用_分隔
9.静态变量
带有s前缀
10.函数命名
所有名称都使用小写，多个单词以_分隔

### 流程控制语句
## 条件控制语句
# if-else if-else语句
if (expression) {
	语句1;
	语句2;
} else if (expression) {
	语句1;
	语句2;
} else {
	语句;
}
# swtich语句
swtich (变量或表达式) {
	case 常量表达式1:
		语句1;
		break;
	case 常量表达式2:
		语句2;
		break;
	case 常量表达式3:
		语句3;
		break;
	default:
		语句n+1;
		break;
}
## 循环控制语句
# while循环
whlile (表达式) {
	语句
}
# for循环
for (初始化语句; 判断语句；迭代表达式语句) {
	语句;
}
# foreach循环
foreach ($array as $item) {
	语句;
}
foreach ($array as $key => $value) {
	语句;
}
foreach用于未初始化的数组或其他类型的变量会报错 应该先使用is_array判断一下
## 跳转语句
# break
可以终止当前循环，包括while do...while for foreach和switch在内的所有控制语句
break不仅可以跳出当前循环 还可以指定跳出几重循环
break $num;
# continue
只能终止本次循环进入下一次循环中，也可以指定跳出几层循环
### 字符串操作
## 字符串的定义方法
# 使用单引号或双引号定义字符串
双引号中的内容是通过PHP的语法分析器解析过的，任何变量在双引号中都会被转换为实际的值输出显示
而单引号则是所见即所得，直接输出不经过转换
# 使用定界符<<<
与双引号一样，变量会被替换为实际的值。
## 字符串操作
# 去除字符串首尾空格和特殊字符
1.trim函数
用于去除字符串首尾处的空白字符（或其他字符）
trim(string str[, string charlist]);
charlist可选，为所有希望过滤的字符，可以使用..列出一个字符范围。如果不设置该参数，则所有的可选字符都将被删除。
不指定charlist参数是的trim()函数去除的字符
\0
\t
\n
\x0B
\r
" "
2.ltrim()
用于去除字符串左边的空白字符(或其他字符)
3.rtrim()
用于去除字符串右边的空白字符（或其他字符）
# 转义、还原字符串数据
1.手动转义、还原字符串数据
\是转义符，紧跟之后的第一个字符将变得没有意义或者特殊意义。
2.自动转义、还原字符串数据
string addslashes(string str)函数 输入需要转义的字符串 返回转义后的字符串
string stripslashes(string str) 输入转义后的字符串 返回还原的字符串（即去除反斜杠\)
string addcslashes(string str, string charlist) 在指定的字符串前加上反斜杠 如果参数charlist中包含\n\r等字符，将以C语言风格转换 而其他非字母数据且ASCII低于32以及高于126的字符均转换为八进制表示
string stripcslashes(string str) 将转义后的字符串还原
# 获取字符串的长度
int strlen(string str) 函数
汉字占用两个字符，数字、英文、小数点、下划线和空格占一个字符
也可以用于检测字符串的长度
# 截取字符串
string substr(string str, int start[, int length])
start从0开始
# 比较字符串
1.按字节进行字符串比较
int strcmp(string str1, string str2) // 区分字符大小写 相等则返回0 str1大于str2则返回大于0 小于则返回小于0
strcasecmp(string str1, string str2) // 不区分字符大小写
2.按自然排序法进行字符串比较
int strnatcmp(string str1, string str2) // 从左向右进行比较，如果数字比较则按照自然排序法 其他则根据字符的ASCII码值进行比较
3.指定从源字符串的位置开始比较
int strncmp(string str1, string str2, int len) // 比较字符串的前n个字符
# 检索字符串
1.strstr()函数查找指定的关键字
获取一个指定字符串再另一个字符串中首次出现的置为到后者末尾的子字符串，有则返回剩余字符串，没有返回false
string strstr(string haystack, string needle) // 区分大小写
string strrchr(string haystack, string needle) // 后序开始搜索
2.substr_count()搜索子串出现的次数
int substr_count(string haystack, string needle) 
# 替换字符串
1.str_ireplace() 
mixed str_ireplace(mixed search, mixed replace, mixed subject[, int count])
search 可以是数组 要搜索的值
replace 替换的值
subject 可以是数组 被搜索的值
count 替换的数量
str_treplace() 不区分大小写 str_replace 区分
2.substr_replace()函数
用于将指定字符串的部分字符串进行替换
mixed substr_replace(mixed string, mixed repl, mixed start[, mixed length])
string 可以是数组 要操作的原始字符串
repl 指定替换后的字符串
start 开始位置
length 长度
# 格式化字符串
string number_format(float number[, int decimals[, string dec_point[, tring thousands_sep]]])
number 要格式化的数字
decimals 要保留的小数位
dec_point 小数点显示的字符
thousands 千位分隔的字符
# 分割、合成字符串
1.分割字符串
array explode(string delimiter, string str[, int limit])
delimiter 分割符
str 	被分割的字符串
limit 返回的数组中最多包含limit个元素
2.合成字符串
string implode(string glue, array pieces)
glue 分隔符
pieces 合成的数组
### 正则表达式
## 什么是正则表达式
描述字符串结构的语法规则，是一个特定的格式化模式，可以匹配、替换、裁取匹配的子串。
## 正则表达式语法规则
# 行定位符
^
$
# 单词分解符
\b // \btm\b 表示需要匹配的是一个完整的单词而不是一部分
\B // \Btm\B 表示需要匹配的是一部分而不是完整的单词
# 字符类
[] 出现在括号内的都匹配
[:digit:] 十进制数字集合 [0-9]
[[:alnum:]] 字母和数字的集合 [a-zA-Z0-9]
[[:alpha:]] 字母集合 [a-zA-Z]
[[:blank:]] 空格和制表符
[[:xdigit:]] 十六进制数字
[[:punct:]] 特殊字符集合 如@!#$?等
[[:print:]] 可打印字符 包括空格
[[:space:]] 空白字符
[[:graph:]] 可打印字符 不包括空格
[[:upper:]] 大写字符 [A-Z]
[[:lower:]] 小写字符 [a-z]
[[:cntrl:]] 控制字符
# 选择字符
| 或
# 连字符 
- 表示字符的范围
# 排除字符
[^] 匹配不匹配括号内的其他字符
# 限定符
?
*
+
{n, m}
# 点号字符
除换行符以外的任意字符
# 转义字符
\ 将特殊意义的字符转换为普通字符
# 反斜线
1.将不可打印的字符显示出来
\a
\b
\e
\f
等
2.指定预定义字符集
\d 一个十进制数字
\D 非十进制数字
\s 空白字符
\S 非空白字符
\w 单词
\W 非单词
3.断言的限定符
# 括号字符
(xxx|yyy) 表示匹配xxx或yyy
第二个作用是分组
# 反向引用
# 模式修饰符
设定模式，规定正则表达式应该如何解释和应用
i		忽略大小写
M		多文本模式 即字符串内部有多个换行符时 影响^$的匹配
s		单文本模式 .可以匹配换行符 其他模式下不行
X		忽略空白字符
## PCRE兼容正则表达式
# preg_grep()函数
array preg_grep(string pattern, array input)
使用数组input中的元素一一匹配表达式pattern，返回匹配元素组成的数组
# preg_match() preg_match_all()
int preg_match/preg_match_all(string pattern, string subject[, array matches])
字符串subject中匹配表达式pattern，如果有数组则每次匹配都存储到matches数组中
返回值是0或1 preg_match匹配到第一个就返回 preg_match_all则匹配全部 array matches对preg_match_all是必须的
# preg_quote()函数
string preg_quote(string str[, string delimiter])
将字符串str中的所有特殊字符进行自动转义 如果有delimiter则对应的子串也将转义
# preg_replace()函数
mixed preg_replace(mixed pattern, mixed replacement, mixed subject[, limit])
在字符串subject中匹配表达式pattern， 将匹配项替换成子串repleacement
在replacement中使用$1 $2获取匹配的分组字符串
# preg_replace_callback() 函数
mixed preg_replace_callback(mixed pattern, callback callback, mixed subject[, int limit])
使用回调函数而不是字符串来替换 
function func($arr) { // 传入的参数是一个数组 需要留意
	return $str;
}
# preg_split()函数
array preg_split(string pattern, string subjec[, int limit])
### PHP数组
## 什么是数组
一组数据的集合
## 声明数组
array array([mixed ...])
mixed语法为 key => value 如果没有指定key 则自动生成从0开始的整数索引
print_r($arr) 迭代输出一个数组
## 数组的类型
PHP支持两种数组 索引数组（indexed array)和联合数组(associative array)前者使用数字作为key，后者使用字符串作为key
# 数字索引数组
数字索引一般表示数组元素在数组中的位置，有数字组成，下标从0开始，数字索引数组默认索引值从0开始。也可以从指定位置开始保存数据
# 关联数组
关联数组使用字符串索引来访问存储在数组中的值 对于数据库层交互非常有用
## 输出数组
bool print_r(mixed expression)
##数组的构造
# 一维数组
数组元素时变量
# 二维数组
数组元素时一维数组
##　遍历数组
1.使用foreach结构遍历数组
foreach ($arr as $item) {

}
foreach ($arr as $key => $value) {


}
2.list()函数
void list(mixed ....) 仅用于数字索引的数组
## 字符串与数组的转换
1.explode()函数 将字符串转换为数组
array explode(string delimiter, string str[, int limit]);
2.implode()函数 将数组转换为字符串
string implode(string glue, array piceces)
## 统计数组元素个数
int count(mixed array[, int mode])
mode 可选参数 COUNT_RECURSIVE(或者1)递归的对数组计算 默认0
## 查询指定元素
mixed array_search(mixed needle, array haystack[, bool strict])
找到指定值则返回键名，否则返回false  strict为true时还将检查类型是否符合
## 获取数组中最后一个元素
mixed array_pop(array array)
获取并返回数组的最后一个元素，数组长度减一 数组为空或不是数组时返回null
## 添加元素
int array_push(array array, mixed var[, mixed ....])
将传入的变量压入数组的尾部，数组长度加一，并返回数组元素总数
## 删除数组中重复元素
array array_unique(array array)
用于将值作为字符串排序，然后每个只保留第一个键名，忽略后面所有的键名，即删除重复元素

### PHP与Web页面交互
## 表单
# 创建表单
<form action="" method="" enctype="" target="">
target _blank 新窗口 _self 当前窗口 _parent 父窗口 _top 顶级窗口
# 表单元素
1.<input>
2.<select><option>
3.<textarea>
## 在普通Web也中插入表单
## 获取表单数据的两种方法
#POST
#GET
## PHP参数传递的常用方法
# $_POST[]全局变量
通过post方法提交过来的数据
有些可以直接使用$<参数名>来获取数据 与php.ini的配置有关 register_globals=ON/OFF ON则可以取的到 但存在安全隐患 推荐使用OFF
# $_GET[]全局变量
通过GET方法提交过来的数据
# $_SESSION[]变量
获取表单元素的值 使用$_SESSION传参方法获取的变量值，保存之后可以在任何页面中使用 但很耗费系统资源
## 在Web页面中嵌入PHP脚本
# 在HTML标记中添加PHP脚本
可以随时添加<?php ?>PHP脚本标记，标记中的所有文本将被解释为PHP，标记之外的则被认为是普通的HTML
# 对表单元素value属性赋值
value="<?php  echo 123;?>"
## PHP中获取表单数据
# 获取文本框、密码域、隐藏域、按钮、文本域的值
<form>标签中的name是所有表单元素都具备的属性，即为这个表单元素的名称，在使用时使用name属性来获取相应的value值。
# 获取单选按钮的值
radio一般成组出现，具有相同的name和不同value
# 获取复选框的值
checkbox 相同的name 不同的value 可以是多个值 name一般以数组的命名以[]结尾
# 获取下拉列表框/菜单列表框的值
select option
# 文件
file
## URL传递的参数进行编解码
# 对URL传递的参数编码
string urlencode(string str)
对服务器而言，可以自动识别
# 对URL传递的参数解码
string urldecode(string str) 
## PHP与Web表单的综合应用
move_upload_file($_FILES['name']['tmp_name'], 目的地包括保存的文件名);

### PHP与JavaScript交互
如同在HTML中一样使用即可

### 日期和时间
## 系统时区设置
# 时区划分
24个时区 UTC
# 时区设置
1.修改php.ini配置文件中的;date.timezone=选项 Asia/Shang_Hai
2.在应用程序中使用date_defualt_timezone_set(timezone)
## PHP日期和时间函数
# 获得本地化时间戳
mktime()函数将一个时间转换为UNIX时间戳
int mktime(int hour, int minute, int second, int month, int day, int year,int [is_dst]) 默认-1（不确定）夏令1 不是0
# 获取当前时间戳
int time(void)
# 获取当前日期和时间
date(string format[, int timestamp = time()])
返回按照指定格式产生的字符串 timestamp为可选值 不提供则为当前时间戳
预定义的format
DATE_ATOM			原子钟格式
DATE_COOKIE			HTTP Cookie格式
DATE_ISO8601		ISO8601格式
DAtE_RFC822
DATE_RFC850
DATE_RSS
DATE_W3C			World wide web Consortium格式
# 获取日期信息
array getdate([int timestamp]);
# 检验日期的有效性
bool checkdate(int month, int day, int year)
# 输出格式化的日期和时间
a			小写的上午或下午 am或pm
A			大写的上午或下午 AM或PM
B			Swatch Internet标准时间 返回值为000~999
d			月份中的第几天 有前导的0 范围1~31
D			星期中的第几天 文本格式 3个字母 Mon~Sun
F			月份 完整的文本格式 January~December
h			小时 12小时格式
H			小时 24小时格式
i			有前导零的分钟数
I			判断是否为夏令
j			月份中的第几天 没有前导0
l			星期数 完整的文本格式 返回
L			是否是闰年 是为1 不是为0 
m			数字表示的月份 有前缀0
M			3个字母缩写表示的月份 Jan~Dec
n			数字表示的月份 没有前导0
O			与格林威治时间相差的小时数 如+0200
r 
s			描述 有前导0
S			每月天数后面的英文后缀 两个字符 如st nd等
t			每月应有天数 28~31
T 			所在时区
U			从UNIX纪元1970-01-01 00:00:00+0000开始至今的秒数
w			星期中的第几天 0~6
W			第几周 每周从周一开始
y			两位数字表示的年份 如88
Y			四位数字表示的年份 如1988
z			年份中的第几天 1~366
Z 			时差偏移量的秒数
# 显示本地化的日期和时间
1.setlocale()函数
改变PHP默认的本地化环境
string setlocale(string category, string locale)
category可选项
LC_ALL					包含以下所有设置本地化规则
LC_COLLATE				字符串比较
LC_CTYPE				字符串分类和转换
LC_MONTARY				本地化环境的货币形式
LC_NUMERIC				本地化环境的数值形式
LC_TIME					本地化环境的时间格式
locale为空 就会使用环境变量的locale或lang的值 en_US美国 chs简体中文 cht繁体中文
2.strftime()桉树
根据本地化环境设置来格式化输出日期和时间
string strftime(string format, int timestamp)
# 将日期和时间解析为UNIX时间戳
int strtotime(string time[, int now])
# 实现倒计时功能
# 页面脚本的运行时间


******************* 核心技术 *****************
### Cookie和Session
## Cookie管理
# 了解Cookie
1.什么事Cookie
是一种远程浏览器端存储数据并以此来跟踪和识别用户的机制，简单的说，Cookie是Web服务器暂时存储在用户硬盘上的一个文本文件，并随后被Web浏览器读取。用户再次访问Web网站时，通过读取Cookie文件记录这位访客的特定信息。
文本文件的命令格式
用户名@网站地址[数字].txt
2.Cookie的功能
Web服务器可以应用Cookie包含信息的任意性来筛选并经常性维护这些信息 常用于这些方面
A.记录访客的某些信息 如访问次数 登录的用户名等
B.在页面之间传递变量
C.将所查看的Internet页存储在Cookie的临时文件夹中 提高浏览速度
# 创建Cookie
bool setcookie(string name[, string value[, int expire[, string path[, string domain[, int secure]]]]])
name 		Cookie的变量名 $_COOKIE['<cookie_name>']获取Cookie
value		变量值 保存在客户端
expire		过期时间 标准的UNIX时间戳 如果不设置过期时间将永远有效 除非手动删除
path		Cookie在服务器端的有效路径	如果/则在整个domain中有效 如果/ll则在domain下的/ll目录及其子目录中有效 默认是当前目录
domain		Cookie的游侠域名	如果要在所有xxx.com域名下的子域都有效 则应该设置为xxx.com
secure		指明Cookie是否仅通过安全的HTTPS 值为0或1	1则只在HTTPS连接上有效 0则都有效
# 读取Cookie
通过超级全局数组$_COOKIE[]来读取浏览器端的Cookie值
# 删除Cookie
1.使用setCookie()函数删除
setcookie('name', '', time() - 1);
2.手动删除Cookie
# Cookie的生命周期
不设定时间，就表示生命周期是浏览器会话的期间，关闭就消失，称为会话Cookie，一般不保存在硬盘上，而是在内存中
设置了过期时间就会保存在硬盘中直到超时
浏览器存储的cookie有上线，最大容量有限制，每个域名的cookie有最大数量限制，达到后会自动删除.
## Session管理
# 了解Session
1.什么是Session
会话，本义是指有始有终的一系列动作/消息。
计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统所经过的时间。
2.Session工作原理
启动一个Session会话时，会生成一个随机且唯一的session_id,也就是session的文件名，此时session_id存储在服务器的内存中，关闭页面时id自动注销。重新登录页面会再次生成一个随机且唯一的id
3.Session的功能
Web技术中非常重要，由于网页是一种无状态的连接程序，因此无法得知用户的浏览状态。通过Session则可记录用户的有关信息，以供用户再次以此身份对Web服务器提交要求时确认身份。
Session适用于存储信息量较少的情况。
# 创建会话
1.启动会话
session_start() 会话变量被登录到$_SESSION中
bool session_start()
使用session_start()前不能有任何输出
使用session_register()函数 不需要调用session_start()函数 会在注册变量后隐含地调用session_start()
2.注册会话
session_start();
$_SESSION['admin'] = null;
3.使用会话
if (!empty($_SESSION['session_name'])) {
	$myparam = $_SESSION['session_name'];
}
4.删除会话
1)删除单个会话
unset($_SESSION['session_name']);
2)删除多个会话
$_SESSION = array();
3)结束会话
session_destory();
# Session设置时间
1.客户端没有禁止Cookie
1)
session_set_cookie_params($time);
必须在session_start()之前调用
2)
session_start()
setcookie(session_name(), session_id(), time() + $time, '/');
2.客户端禁止Cookie
1)登录之前提醒用户打开Cookie
2)设置php.ini中 session.use_trans_sid=1 或者编译时打开 -enable-trans-sid选项 让PHP自动跨页面传递session_id
3)通过GET方法，隐藏表单传递session_id
4)使用文件或者数据库存储session_id,在页面传递中手动调用
Session原理为请求页面之后产生一个session_id，如果禁止Cookie就无法传递session_id，就会重新产生一个session_id，造成session传递失效
# 通过Session判断用户的操作权限


## Session高级应用
# Session临时文件
服务器中，如果所有用户的Session都保存到临时目录中，会降低服务器的安全性和效率，打开服务器存储的站点非常慢
使用session_save_path()存储Session临时文件
session_save_path()应该在session_start()之前调用
# Session缓存
将网页中的内容临时存储到IE客户端的Temporaty Internet Files文件夹下，并且设置缓存时间。
string session_cache_limiter([string cache_limiter])
cache_limiter 为private或public
int session_cache_expire([int new_cache_expire])
设置缓存时间 单位是分钟
以上两个函数需要在session_start()前调用
# Session数据库存储
bool session_set_save_handler(string open, string close, string read, string write, string destroy, string gc)
open(save_path, session_name) 	找到存储地址，取出变量名名称
close()							关闭数据库
read(key)						读取session键值 key对应session_id
write(key, data)				data对应设置的session变量
destroy(key)					注销session对应的Session键值
gc(expire_tiem)					清除过期Session记录
function _session_open($save_path, $session_name) {
	global $handle;
	$handle = mysql_connect('localhost', 'root', ''root') or die('数据库连接失败');
	mysql_select_db('db_database', $handle) or die('没有此库名');
	return (true);
}
function _session_close() {
	global $handle;
	mysql_close($handle);
	return (true);
}
function _session_read($key) {
	global $handle;
	$time = time();
	$sql = "select session_data from tb_session where session_key = '$key' and session_time > $time";
	$result = mysql_query($sql, $handle);
	$row = mysql_fetch_array($result);
	if ($row) {
		return ($row['session_data']);
	} else {
		return (false);
	}
}
function _session_write($key, $data) {
	global $handle;
	$time = 60 * 60;
	$lapse_time = time() + $time;
	$handle = mysql_connect('localhost', 'root', 'root') or die ('数据库连接失败');
	mysql_select_db('db_database', $handle) or die('没有此库');
	$sql = "select session_data from tb_session where session_key = '$key' and session_time > $lapse_time";
	$result = mysql_query($sql, $handle);
	if(mysql_num_rows($result) == 0) {
		$sql = "insert into tb_session values ('$key', '$data', $lapse_time)";
		$result = mysql_query($sql, $handle);
	} else {
		$sql = 'update tb_session set session_key = '$key', session_data = '$data', session_time = $lapse_time where session_key = '$key'";
		$result = mysql_query($sql, $handle);
	}
	return ($result);
}
function _session_destroy($key) {
	global $handle;
	$sql = "delete from tb_session where session_name = '$key'";
	$result = mysql_query($sql, $handle);
	return ($result);
}
function _session_gc() {
	global $handle;
	$lapse_time = time();
	$sql = "delete from tb_session where session_tiem < $lapse_time";
	$result = mysql_query($sql, $handle);
	return ($result);
}

### 图形图像处理技术

### 文件系统
## 文件处理
包括读取、关闭、重写等。
# 打开/关闭文件
打开/关闭文件使用fopen()和fclose()函数，小心防止错误操作。
1.打开文件
resource fopen(string filename, string mode[, bool use_include_path]);
filename是要打开的包含路径的文件名，可以是相对路径或绝对路径，如果没有前缀表示打开的是本地文件。mode是打开文件的方式。use_include_path在php.ini中指定的参数，希望PHP在此路径下打开文件。
mode 可取值
r		只读		读模式 进行读取 文件指针位于文件开头
r+		只读		读写模式 文件指针位于文件的开头 在现有文件内容的末尾之前进行写操作将会覆盖原有内容
w		只写		写模式 文件指针指向文件开头 如果文件存在则所有文件内容删除 否则将会创建一个新的文件
w+		只写		读写模式 文件指针指向文件卡头 如果文件存在则所有文件内容删除 否则将会创建新的文件
x		谨慎写		写模式 文件指针指向文件开头 如果文件已存在则不会打开文件 并返回false产生警告
x+		谨慎写		读写模式 文件指针指向文件开头 如果文件已存在则不会打开文件 并返回false产生警告
a		追加		追加模式 文件指针指向文件尾部，已有内容则追加到文件尾部 没有则创建新文件
a+		追加 		读写模式 文件指针指向文件开头 已有内容则追加到文件尾部 没有则创建新文件
b		二进制
t		文本
2.关闭文件
bool fclose(resource handle)
# 读写文件
1.读取数据
可以一次读取一个字符，一行字符或整个文件，还可以读取任意长度的字符串
（1）读取整个文件 readfile file file_get_contents
1)readfile()
用于读取一个文件并将其写入到输出缓冲中，如果出现错误则返回false
int readfile(string filename)
使用readfile不需要fopen/fclose，不需要echo/print等输出语句，直接写出文件路径即可
2)file()
可以用于读取整个文件内容，只是将文件内容按行存放到数组中，包括换行符在内，如果失败则返回false
array file(string filename)
3)file_get_contents()
将文件内容读入一个字符串，如果有offset和maxlen则从指定位置读取指定长度的字符串，如果失败返回false
string file_get_contents(string filename[, int offset[, int maxlen]])
此方法适用于二进制对象，是将整个文件内容读入一个字符串中的首选方式
（2）读取一行数据 fgets() fgetss()
1)fgets()
string fgets(int handle[, int length])
handle是打开的文件，函数能够实现从handle指定文件中读取一行数据并返回长度最大值为length-1个字节的字符串。在遇到换行符、EOF或者读取了length-1个字节之后停止。如果没有length参数，则读取到行结束
2)fgetss()
是fgets()函数的变体，用于读取一行数据，同时会过滤掉内容中的HTML和PHP标记
string fgetss(reource handle[, int length[, string allowable_tags]])
过滤掉任何HTML和PHP标记，allowable_tags用于控制哪些标记不被过滤
（3）读一个字符 fgetc()
string fgetc(resource handle)
（4）读取任意长度的字符串 fread()
fread()可以从文件中读取任意长度的字符串 
string fread(int handle, int length)
length是要获取的字符串
2、写入数据
fwrites() fputs() file_put_contents()向文件写入数据
int fwrite(resource handle, string string[, int length])
把内容sring写入文件，如果指定了length则在写入指定字节后停止。
int file_put_contents(string filename, string data[, int flags]);
flags可取值 FILE_USE_INCLUDE_PAth FILE_APPEND LOCK_EX LICK_EX为独占锁定s
file_put_contents和依次调用fopen() fwrites() fclose()功能一样
# 操作文件
对文件本身进行操作 如复制、重命名、查看修改日期等
bool copy(string path1, string path2)			将文件从path1复制到path2 如果成功返回true 如果失败返回false
bool rename(string filename, string filename2) 	把filename1重命名为filename2
bool unlink(string filename) 					删除文件 成功返回true 失败返回false
int fileatime(string filename) 					返回文件最后一次被访问的时间，时间以UNIX时间戳的方式返回
int filemtime(string filename)					返回文件最后一次被修改的时间，时间以UNIX时间戳的方式返回
int filesize(string filename)					返回文件filename的大小(bytes)
array pathinfo(string name[, int options])		返回一个数组，包含文件name的路径信息，有datetime，basename和extension，可以通过options指定返回的信息有PATHINFO_DIRNAME,PATHINFO_BASENAME,PATHINFO_EXTENSION,默认全部返回
string realpath(string filename) 				获取文件的绝对路径
array stat(string filename)						获取一个数组，包含文件的相关详细信息
## 目录处理
目录是一种特殊的文件，要浏览目录下的文件，首先要打开目录，浏览完毕后，同样要关闭目录。目录处理包含打开目录、浏览目录和关闭目录
# 打开/关闭目录
1.打开目录
resource opendir(string dirpath)
合法的目录路径，成功执行之后返回目录的指针。如果不是合法的目录或者因为权限或文件系统错误而不能打开目录，则返回一个false并产生一个E_WARNING级别的错误信息，可以在opendir()前加上@符号来抑制错误信息的输出
2.关闭目录
void closedir(resource handle)
# 浏览目录
array scandir(string directory[, int sorting_order])
返回一个数组，包含directory中的所有文件和目录，参数sorting_order指定排序顺序，默认按照字母升序排序。如果添加了该参数，则变为降序排序。
# 操作目录
目录是特殊的文件，因此对文件的操作多数同样适用于目录
bool mkdir(string pathname) 				新建一个指定的目录
bool rmdir(string dirname)					删除指定的目录，该目录必须为空的
string getcwd(coid)							获取当前工作的目录
bool chdir(string directory)				改变当前目录为directroy
float disk_free_space(string directory)		返回目录中可用空间（bytes），检查的文件必须通过服务器的文件系统访问
float disk_total_space(string directory)	返回目录的总空间大小(bytes)
string readdir(resource handle)				返回目录中下一个文件的文件名（必须使用opendir()打开）
void rewinddir(resource handle)				将指定的目录重新指定到目录的开头
## 文件处理的高级应用
# 远程文件的访问
支持URL格式的文件调用，需要在php.ini中配置一下，allow_url_fopen: ON
# 文件指针
1.rewind()函数
将文件指针指向文件流的开拓
bool rewind(resource handle)
如果以a的mode打开文件则无论指针在哪都在文件尾部追加内容
2.fseek()函数
实现文件指针的定位
int fseek(resource handle, int offset[, int whence])
handle 打开的文件
offset 为指针位置或相对whence的偏移量 可以是负值
whence 包括3种 SEEK_SET 位置等于offset字节 SEEK_CUR	位置等于当前位置加上offset字节 SEEK_END 位置等于文件尾部加上offset字节 如果忽略whence 系统默认为SEEK_SEt
3.feof()函数
该函数判断文件指针是否在文件尾
bool feof(resource handle)
如果文件指针到达文件结束的位置，返回true，否则返回false
4.ftell()函数
返回当前指针的位置
# 锁定文件
向一个文本文件写入内容时，需要先锁定该文件，以防止其他用户同时修改此文件内容。使用flock()函数
bool flock(resource handle, int operation)
handle是一个已打开的文件，operation可选值为
LOCK_SH		取得共享锁定 （读取程序）
LOCK_EX		取得读取锁定 （写入程序）
LOCK_UN		释放锁定	
LOCK_NB		防止flock()在锁定时阻塞
## 文件上传
需要修改$_FILES中的配置，并了解$_FILES[]全局变量 最后使用move_uploaded_file()实现上传
# 配置php.ini文件
file_uploads		如果值时ON则说服务器支持文件上传 OFF则不支持
upload_tmp_dir		上传文件临时目录，成功上传之前，文件首先存放在服务器端的临时目录中，如果想要指定位置可以设置，否则使用系统默认目录即可
upload_max_filesize	服务器允许上传的文件的最大值，以MB为单位，默认2MB，可自行设置
还有一些属性可能影响文件上传
max_execution_time 	PHP中一个指令所能执行的最大时间，单位是秒
memory_limit		PHP中一个指令所分配的内存空间，单位是MB
# 预定义变量$_FILES
$_FILES变量存储的是上传文件的相关信息，这些信息对于上传功能有很大的作用。该变量是一个二维数组。
$_FILE[filename][name]				上传文件的文件名
$_FILE[filename][size]				存储了文件大小 单位为字节
$_FILE[filename][tmp_name]			文件上传时，首先在临时目录中被保存成一个临时文件，该变量为临时文件名
$_FILE[filename][type]				上传文件的类型
$_FILE[filename][error]				存储了上传文件的结果如果返回0说明文件上传成功
# 文件上传函数
bool move_uploaded_file(string filename, string destination) 
将上传文件存储到指定的位置，如果成功返回true 如果失败返回false filename是上传文件的临时文件名
使用move_uploaded_file()函数上传文件时，需要设置enctype="multipart/form-data"属性
# 多文件上传
将name设置为xxx[] 则在$_FILES[xxx][name/tmp_name/error/...] 都变为数组

### 面向对象
## 面向对象的基本概念
# 类
# 对象
# 面向对象编程的三大特点
继承
封装
多态
## PHP与对象
# 类的定义
class MyObject {

}
# 成员方法
类中的函数称为成员方法，函数和成员方法唯一的区别即使，函数实现的是某个独立的功能，而成员方法是实现类中的一个行为，是类的一部分。
class MyObject {
	function func($param1, $param2) {
		echo $param1;
	}
}
# 类的实例化
使用类的方法需要先实例化类，通过new关键字来声明一个对象。再使用以下格式调用成员方法
对象 -> 成员方法
# 成员变量
类中的变量也称为成员变量（也有称为属性或字段的）。成员变量用来保存信息数据，或与成员方法进行交互来实现某项功能。
public/private/protected/static/final 成员变量
调用的方式和成员方法一样
对象 -> 成员变量 （此处的变量是没有$前缀的)
$this -> 成员变量 调用本实例的成员变量
# 类常量
const PI = 3.1415927;
使用
类名::类常量
# 构造方法和析构方法
1.构造方法
当一个类实例化一个对象时，可能需要随着对象初始化一些成员变量。
构造方法就是生成对象时自动执行的成员方法，作用就是初始化对象，可以没有参数，也可以有多个参数。
格式
void __construct([mixed args[,...]])
没有显式声明构造函数，PHP会自动生成一个没有参数的构造函数，并且内部没有任何操作。
2.析构方法
在对象被销毁时调用，作用是释放内存。
void __destruct(void)
PHP使用垃圾回收机制，自动清除不再使用的对象，释放内存。即使不调用unset()方法，析构方法也会自动调用。
# 继承和多态的实现
1.继承
子类继承父类所有的成员变量和方法，包括构造函数，当子类创建时，PHP会先在子类中查找构造方法，如果子类有自己的构造方法，PHP会先调用子类的构造方法，没有则调用父类的构造方法。
class SubClass extends SuperClass {

}
2.多态
存在两种形式 重写和重载
1)重写就是子类中重写父类的方法，不同子类调用同名的方法得到的结果是不同的
2)重载就是通过参数数量或类型来将同名的函数区分开，调用不产生混淆,好处是可实现代码重用
# $this->和::的使用
PHP通过伪变量$this->和作用域操作符::来实现
1.$this->
在定义类是，想要调用类中的方法或变量，用伪变量$this-> $this的意思就是本身 所以只能在类的内部使用
get_class()函数返回对象所属类的名字，如果不是对象则返回false
2.操作符::
可以在没有声明任何实例的情况下访问类中的成员方法或成员变量
关键字::变量名/常量名/方法名
关键字分为
parent::  可以调用父类中的成员变量、成员方法和常量
self::	  可以调用当前类中的静态成员和常量
类名::		可以调用本类中的变量、常量和方法
# 数据隐藏
1.public （默认的 没有显式声明就是public的）
公开，没有隐藏的数据信息。可以在程序的任何位置被其他的类和对象调用。子类可以继承和使用父类中的所有公共成员。
2.private
只能在所属类的内部被调用和修改，不可以在类外被访问。在子类中也不可以
3.protected
对本类和子类可见，在类外不可见。
# 静态变量/方法
不是所有的变量方法都要通过创建对象来调用，可以通过给变量方法加上static关键字来直接调用，调用静态成员的格式为
关键字::静态成员
关键字
self::	类内部调用静态成员时使用
类名::	在类外调用类内部的静态成员使用
静态方法中，只能调用静态变量，不能调用普通变量，普通方法中可以调用静态变量
还有一个好处就是对象销毁之后，静态成员依然存在，可以下次继续使用
## 面向对象高级应用
# final关键字
final class class_name {

}
表示这个类不能被继承 也不能有子类
如果有一个方法被final修饰
final function func_name()
表示这个方法不能被子类重写 也不能被覆盖
# 抽象类
abstract class AbstractClass {

}
抽象类是一个不能被实例化的类，只能作为其他类的父类来使用，抽象类使用abstract关键字来声明
抽象类和普通类相似，包含成员变量，成员方法，区别在于抽象类至少包含一个抽象方法，抽象方法没有方法体，其功能的实现只能在子类中完成。抽象方法也是使用abstract关键字声明的
abstract function func_name(); // 分号不能少
# 接口的使用
interface inter_name {

}
PHP只支持单继承，想要实现多重继承需要使用接口
不能用public以外的关键字来修饰接口中的类成员，对于方法，不写关键字也可以。
子类通过implements关键字来实现接口，如果需要实现多个接口，需要使用逗号分隔，并且所有未实现的方法需要在实现类中实现。
# 克隆对象
1.关键字clone
PHP4之前对象赋值是复制一个备份，PHP5之后则是传递引用。如果想要得到一个备份 可以使用clone关键字来实现
2.__clone方法
除了单纯的克隆对象外，还需要克隆出的对象可以拥有自己的属性和行为。需要使用__clone方法来实现。作用是在克隆过程中，调用__clone方法。
# 对象比较
== 比较对象内容
=== 比较对象地址
# 对象类型检测
ObjectName instanceof ClassName
# 魔术方法
以 __ 开头的方法
__construct
__destruct
__clone
1.__set和__get方法
当程序视图写入一个不存在或不可见的成员变量时，PHP就会执行__set方法，__set方法包含两个参数，分表表示变量名称和变量值，参数不可省略。
当程序试图调用一个未定义或不可见的成员变量时，可以通过__get方法来获取变量，有一个参数，表示要调用的变量名
2.__call方法
当程序试图调用不存在或不可见的成员方法时，会先调用__call来存储方法名及其参数，包含两个参数，方法名和参数数组
3.__sleep和__wakeup方法
使用serialize()函数可以实现序列化对象，将对象中的变量全部保存下来。如果包含__sleep()方法则先执行__sleep 目的是关闭对象可能具有的数据库连接等类似的善后工作 return array("field_name") 只有在这个数组中的成员变量会被序列化
unserialize()函数反序列化对象，__wakeup方法则是在恢复可能丢失的工作
4.__toString方法
当使用echo和print输出对象时，将对象转化为字符串
5.__autoload方法
将一个独立、完整的类保存到一个PHP页中，并且文件名和类名保持一致，__autoload方法可以自动实例化需要使用的类


### PHP加密技术
## PHP加密函数
# 使用crypt()函数进行加密
string crypt(string str[, string salt])
str是需要加密的字符串 salt是加密时使用的干扰字符串 如果省略第二个参数 则会随机生成一个干扰字符串
crypt()函数支持4种算法和salt参数的长度
CRYPT_STD_DES			2-character(默认)
CRTPT_EXT_DES			9-character
CRYPT_MD5				12-character $1$开头 
CRYPT_BLOWFISH			16-character $2$开头
默认情况下，PHP使用一个或两个字符的DES干扰字符串 如果使用MD5 则会使用12个字符 通过CRYPT_SALT_LENGTH变量来查看当前所使用的干扰字符串的长度
加密是单向了 密文不能还原成明码
# 使用md5()函数进行加密
md5()函数使用MD5算法 作用是把不同长度的数据信息结果一系列的算法计算成一个128位的数值，就是把一个任意长度的字节串转换为一定长的大整数。
string md5(string str[, bool raw_outptu])
str加密的明文 raw_output如果true返回一个二进制的密文 默认为false
# 使用sha1()函数进行加密
string sha1(string str,[bool raw_output])
返回一个40位的十六进制数，如果raw_output为true 返回一个20位的二进制
## PHP加密扩展库
# Mcrypt扩展库
1.Mcrypt库安装

*
Mcrypt在PHP7.2之后过时 
*

### MySQL数据库基础
## MySQL概述
## 启动和关闭MySQL
## 操作MySQL
## MySQL数据类型

### PHP操作MySQL数据库 (需要打开php.ini中配置 extension_dir=/ext和extension=mysqli)
## PHP操作MySQL数据库的方法
# 连接MySQL服务器
mysqli mysqli_connect([string server[, string username, [string password[, string dbname[, int port[, string socket]]]]]])
mysqli_connect函数用于打开一个MySQL服务器的连接 如果成功返回一个MySQL连接标识 失败返回false
servver		MySQL服务器地址
username	用户名 默认值是服务器进程所有者的用户名
password 	密码 默认值空
dbname		连接的数据库名称
port		Mysql服务使用的端口号
socket 		UNIX域的socket
# 选择MySQL数据库
在mysqli_connect中指定数据库或者mysqli_select_db
bool mysqli_select_db(mysqli link, string dbname)
*
实际开发中 将MySQL服务器的连接和数据库的选择存储于一个单独文件中，需要使用的脚本中通过require语句包含这个文件即可，即有利于程序维护也避免代码冗余。
*
# 执行SQL语句
mixed mysqli_query(mysqli_link, string query[, int resultmode])
link 为必选参数 mysqli_connect返回的连接标识
query 必选参数 只要执行的查询语句
resultmode 可选参数 取值有MYSQLI_USE_RESULT和MYSQL_STORE_RESULT,MYSQLI_STORE_RESULT默认，大量返回数据则使用MYSQLI_USE_RESULT
select 查询成功返回查询结果集 否则返回false；update insert delete则执行成功返回true 失败返回false
# 将结果集返回到数组中
array mysqli_fetch_array(resource result[, int result_type])
result 			资源类的参数 传入的是由mysqli_query函数返回的数据执行。
result_type		可选项 设置结果集数组的表述方式
				MYSQLI_ASSOC	关联数组 数组下标由表的字段组成
				MYSQLI_NUM		索引数组 数组下标由数组组成
				MYSQLI_BOTH		返回一个同时包含关联和数字索引的数组 默认值
*
mysqli_fetch_array返回的字段名区分大小写
*
# 从结果集中获取一行作为对象
object mysqli_fetch_object(resource result)
使用$row->col_name获取数据
# 从结果集中获取一行作为枚举数组
mixed mysqli_fetch_row(resource result)
# 从结果集中获取一行作为关联数组
mixed mysqli_fetch_assoc(resource result)
# 获取查询结果集中的记录数组
int mysqli_num_rows(resource result)
# 释放内存
void mysqli_free_result(resource result);
# 关闭连接
bool mysqli_close(mysqli link)
# 连接和关闭MySQL服务器的最佳时机
MySQL服务器连接应该及时关闭，但并不是说每一次数据库操作后都需要立即关闭MySQL连接
## 管理MySQL数据库中的数据
# 添加数据
mysqli_query("insert table_name (col_name1, ...) values (val1, ...)")
# 编辑数据
mysqli_query("update table_name set col_name1 = val1, ... where condition")
# 删除数据
mysqli_query("delete from table_name where condition")

### PDO数据库抽象层
## 什么是PDO
PHP Data Object 支持的数据库包括MySQL Oracle常用书出具
PHP6中默认使用PDO
# 特点
数据库访问抽象层，作用是同一各种数据库的访问接口
通过一种轻型、清晰、方便的函数，统一各种不同RDBMS的共有特性
PDO扩展是模块化的，能够在运行时为数据库后端加载驱动宏程序
打开php.ini中的extension=pdo_<dbms_name>
## PDO连接数据库
$pdo = new PDO("<dbms_name>:host=<host>:<port>?dbname=<dbname>", <username>, <password>);
# DSN详解
Data Source Name，提供联结数据库需要的信息，包括3部分POD驱动名称（如mysql/sqlite等）:和驱动特定的语法
## PDO中执行SQL语句
# exec方法
int PDO::exec(string statement)
返回影响的行数
# query方法
PDOStatement PDO::query(string statement)
返回一个PDOStatemetn
# 预处理语句prepare和execute
PDOStatement PDO::prepare(string statement[, array driver_options])
bool PDO::execute([array input_parameters])
## PDO中获取结果集
# fetch方法
mixed PDOStatement::fetch([int fetch_style[, int cursor_orientation[, int cursor_offset]]])
fetch_style控制结果集返回形式
PDO::FETCH_ASSOC		关联数组
PDO::FETCH_NUM			索引数组
PDO::FETCH_BOTH			两种形式都有 默认
PDO::FETCH_OBJ			对象形式
PDO::FETCH_BOUND		布尔值的形式
PDO::FETCH_LAZY			关联数组、索引数组和对象数组 3种都有
cursor_orientation 		PDOStatement对象的一个滚动游标 用于获取指定一行
cursor_offset 			游标的偏移量
# fetchAll方法
array PDOStatement::fetchAll([int fetch_style[, int column_index])
# fetchColumn方法
string PDOStatement::fetchColumn([int column_number])
数字化行中列的索引值，从0开始，默认从第一行开始取值
## PDO中捕获SQL语句中的错误
# 默认模式-PDO:ERRMODE_SILENT
设置PDOStatement中的errorCode属性 需要手动检测代码错误
# 警告模式-PDO::ERRORMODE_WARNING
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING)
产生一个PHP警告，设置errorCode属性，除非明确检查错误，否则程序继续运行
# 异常模式-PDO:ERRORMODE_EXCEPTION
创建一个PDOException，并设置errorCode属性可以将执行代码封装到一个try catch语句块中，未捕获的异常将会导致脚本终端，并使用堆栈跟踪显示哪里出现的问题
## PDO中错误处理
# errorCode方法
用于获取再操作数据库句柄时所发生的错误代码
int PDOStatement::errorCode(void)
返回一个SQLSTATE由5个数字和字母组成的代码
# errorInfo方法
用于获取操作数据库句柄时发生的错误信息
返回一个数组，包含了相关的错误信息
## PDO中事务处理
1.开启事务
beginTransaction
关闭自动提交 直到事务提交或回滚后才恢复
2.提交事务
commit
提交事务 成功返回true 否则false
3.事务回滚
rollback
执行事务回滚操作
## PDO中存储过程
call 




### Laravel 
************************** 5.8 ***********************
## 配置Laravel
# 初始化配置
1.公共目录
public目录下的index.php作为前端控制器（应用的唯一入口），所有HTTP请求都会通过该文件进入应用
2.配置文件
config目录下包含所有配置
3.目录权限
需要配置一些目录（如storage和boostrap/cache）的读写权限给Web服务器指定用户
4.应用key
需要先将.env.example复制一份作为.env,如果使用命令创建的应用已经包含则无需这两步操作
php artisan key:generate生成应用key，用于保护用户Session和其他加密数据的安全性
5.更多配置
可以看看config/app.php文件，包含一些基于应用可能需要改变的配置，比如locate和timezone作为本地化
# 环境配置
基于应用运行环境不同设置不同的配置值能够给开发带来极大的方便，比如通常在本地和线上环境配置不同的缓存驱动。
使用PHP扩展库DotEnv来实现这一功能。
不要将.env提交到版本控制系统中，一方面不同环境不同配置，一方面.env文件包含有敏感信息，需要小心对待。
可以将一些环境配置值以占位符的方式放在.env.example中，辅助其他开发者了解应用需要配置的环境变量
可以通过创建.env.testing文件，在执行PHPUnit或带有--env=testing选项的Artisan命令时覆盖.env中的配置值
.env文件所有变量都可以被外部环境变量覆盖，例如服务器级别或系统级别的环境变量
.env文件中所有变量都会被解析为字符串 因此有一些保留值作为转换
比如
true(string) -> true(boolean)
empty(string) -> ""(string)
null(string) -> null(null)
需要包含空格的字符串使用双引号包括整个字符串
获取环境变量配置值
env(<key>, <default>)
判断应用环境
App::environment()
访问配置值
config(<key>)
缓存配置文件
php artisan config:cache 将所有配置文件的配置缓存到单个文件中 从而被框架快速加载
维护模式
php artisan down
## 目录结构
# 简介
可以自行组织目录结构，只要Composer可以自动载入即可
# 根目录
1.App目录
包含应用的核心代码，不是框架的核心代码（框架的核心代码在/vendor/laravel/framework）里。为应用编写的绝大多数代码应该在这里。基于Composer做PHP组件开发的话，只有入口性的代码
2.Bootstrap目录
包含少量文件，app.php用于框架的启动和自动载入配置，还有一个cache文件夹，里面包含框架为提升性能所生成的文件，比如路由和服务缓存文件。
3.Config目录
包含了应用所有的配置文件。
4.Database目录
包含了数据库迁移文件以及填充文件，如果使用SQLite则可以作为SQLite数据库存放目录
5.Public目录
包含了应用入口文件index.php和前端资源文件，该目录也应该是Apache或Nginx等Web服务器所指向的应用根目录。优点在于隔离应用核心文件
6.Resources目录
resources目录包含了应用视图和未编译的原生前端资源文件（LESS、SASS、Javascript），以及本地化语言文件
7.Routes目录
包含了应用定义的所有路由，默认提供了四个路由文件用于不同的入口使用
web.php
包含的路由通过RouteServiceProvider引入，都被约束在web中间件组中，支持Session、CSRF保护以及Cookie加密功能，如果用于无需提供无状态的、RESTful风格的API，那么路由基本都要定义在web.php文件中
api.php
包含的路由通过RouteServiceProvider引入，都被约束在api中间件组中，支持频率限制功能，这些路由是无状态的，请求通过这些路由进入应用需要通过token进行验证并不能访问Session状态
console.php
用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行IO方法进行交互，尽管文件并不定义HTTP路由，但定义了基于控制台的应用入口
channels.php
用于注册应用支持的所有时间广播频道
8.Storage目录
包含编译后的Blade模板，基于文件的Session、文件缓存，以及其他由框架生成的文件，细分为app、framework和logs子目录，app目录用于存放应用生成的文件，framework目录用于存放框架生成的文件和缓存，logs存放应用的日志文件
storage/app/public目录用于存储用户生成的文件，比如可以被公开访问的用户头像，需要在应用根目录的public下生成一个软链接storage指向这个目录 php artisan storage:link
9.Tests目录
包含自动化测试文件，其中默认提供一个开箱即用的PHPUnit示例，每个测试类都要以Test开头，可以通过phpunit或php verdor/bin/phpunit命令来运行测试
10.Vendor目录
包含了应用所有通过Composer加载的依赖
# App目录
应用的核心代码位于app目录下，默认情况下，目录位于命名空间App下，并且被Composer通过PSR-4自动载入标准自动加载
app目录下包含多个子目录 如Console、Http、Providers等。Console和Http目录提供了进入应用核心的API、HTTP协议和CLI是和应用进行交互的两种机制，但实际上并不包含逻辑。换句话说，只是向应用发送命令的方式，Console目录包含了所有编写的Artisan命令，Http目录包含了控制器、中间件和请求等。
其他目录会在Artisan命令make生成相应类的时候自动生成到app目录下
php artisan list make 查看所有artisan生成命令
1.Broadcasting目录
包含了应用所需的所有广播频道类，通过make:channel命令生成。默认不存在。
2.Console目录
包含所有自定义的Artisan命令，通过make:command命令生成。还有Console/Kernel类，可以注册自定义的Artisan命令以及定义调度任务。
3.Events目录
存放事件类，默认不存在。通过event:generate和make:event创建，事件类用于告知应用其他部分某个事件发生情况并提供灵活的、解耦的处理机制。
4.Exceptions目录
包含应用的异常处理器，同时还是处理应用抛出的任何异常的好地方，如果想要自定义异常如何记录和渲染，需要编辑该目录下的Handler类
5.Http目录
包含了控制器、中间件和表单请求等，几乎所有通过Web进入应用的请求处理都可以在此进行
6.Jobs目录
用于存放队列任务，应用中的任务可以被推送到队列，也可以在当前请求生命周期内同步执行。同步执行的任务有时也被看做命令，因为实现了命令模式。默认不存在,make:job创建
7.Listeners目录
包含处理事件的类（事件监听器），接受一个事件并提供对该事件发生后的响应逻辑。默认不存在 event:generate和make:listener创建
8.Mail目录
包含应用所有邮件相关类，可以封装构建邮件所需的所有业务逻辑 Mail::send发送 默认不存在make:mail创建
9.Notifications目录
包含应用发送的所有通知，比如事件发生通知，通知功能将通知发送和通知驱动解耦，默认不存在，make:notification命令
10.Policies目录
包含应用所有的授权策略类，策略用于判断某个用户是否有权限去访问指定资源 默认不存在 make:prolicy
11.Providers目录
包含应用的所有服务器提供者，在应用启动过程中绑定服务到容器、注册事件以及执行其他任务为即将到来的请求处理做好准备工作
12.Rules目录
包含应用的自定义校验规则对象，用于在单个对象中封装复杂的验证逻辑 默认不存在 make:rule

### 核心
## 请求的生命周期
# 简介
# 生命周期概览
1.第一件事
所有请求入口都是public/index.php文件，所有请求都会被web服务器(Apache/Nginx)导向这个文件。index.php文件包含的代码不多，但是，这是加载框架其他部分的起点。
index.php文件载入Composer生成的自动加载设置，然后从bootstrap/app.php脚本获取Laravel应用实例，Laravel第一个动作就是创建服务容器实例
2.HTTP/Console内核
然后，请求被发送到HTTP内核或Console内核（分别用于处理Web请求和Artisan命令），取决于进入应用的请求类型。这两个内核是所有请求都要经过的中央处理器。
app/Http/Kernel.php作为HTTP内核。继承自Illuminate\Foundation\Http\Kernel类，定义了一个bootstrappers数组，这个数组中的类在请求被执行前裕兴，配置错误处理、日志、检测应用环境以及其他在请求被处理前需要执行的任务
HTTP内核还定义了一系列所有请求在处理前需要经过的HTTP中间件，这些中间件处理HTTP会话的读写、判断应用是否处理维护模式、验证CSRF令牌等等
HTTP内核的handle方法签名相当简单，获取一个request，返回一个response，可以把内核想象坐一个代表整个应用的黑盒，输入HTTP请求，返回HTTP响应。
3.服务提供者
内核启动过程中最重要的动作之一就是为应用载入服务提供者，应用的所有服务提供者都被配置在config/app.php配置文件的providers数组中。首先，所有提供者的register方法被调用，被注册后，所有boot方法被调用
服务提供者负责启动框架的所有各种各样的组件，比如数据库、队列、验证器以及路由组件等。
4.分发请求
一旦应用被启动并且所有服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，通过运行所有路由指定的中间件。
# 聚集服务提供者
服务提供者是启动Laravel应用中最关键的部分，应用实例被创建后，服务提供者被注册，请求被交给启动后的应用进行处理。
应用默认的服务提供者存放在app/Providers目录下。
默认AppServiceProvider是空的，这是添加自定义启动和服务容器绑定的最佳位置。
## 服务容器
# 简介
服务容器是一个用于管理依赖和执行依赖注入的强大工具，依赖注入本质是通过构造函数或setter方法将类依赖注入到类中。
# 绑定
1.绑定基础
几乎所有的服务容器都是在服务提供者中完成的
如果一个类没有基于任何接口那么就没有必要将其绑定到容器，会根据PHP的反射服务自动解析出具体的对象
2.简单的绑定
服务提供者中，可以通过$this->app变量访问容器，然后使用bind方法注册一个绑定，该方法需要两个参数，第一个参数是想要注册的类名或接口名称，第二个蚕食是返回类的实例的闭包
$this->app->bind(<>, function($app) {
	return <>;
}); 
3.绑定一个单例
使用singleton方法代替bind方法
$this->app->bind(<>, function($app) {
	return <>;
});
4.绑定实例
intance方法 绑定一个已存在的对象实例到容器，随后调用容器将总是返回给定的实例
$this->app->instance(<>, <>)
5.绑定原始值
可能有一个接收注入类的类，同时需要注入一个原生的数值比如整数，可以结合上下文轻松注入这个类需要的任何值
$this->app->when('<>')->needs('$variableName')->give($value);
6.绑定接口到实现
服务容器的一个非常强大的功能就是其绑定接口到实现，比如一个EventPusher接口以及其实现类RedisEventPusher，可以将这个实现类注册到容器上。
$this->app->bind('EventPusher', 'RedisEventPusher')
告诉容器当一个类需要EventPusher的实现时将注入RedisEventPusher，可以在构造器或者任何其他通过服务容器注入依赖的地方进行EventPusher接口的依赖注入
7.上下文绑定
可能有两个类使用同一个接口，希望不同类注入不同实现。
$this->app->when(PhotoController::class)->needs(Filesystem::class)->give(function () {
	return Storage::disk('local');
});
$this->app->when(VideoController::class)->needs(Filesystem::class)->give(function () {
	return Storage::disk('s3');
});
8.标签
少数情况下，需要解析特定分类下的所有绑定，在注册完之后，通过tag方法分配标签
$this->app->bind('p1', function() {
	return <>;
});
$this->app->bind('p2', function() {
	return <>;
});
$this->app->tag(['p1', 'p2'], 't1');
通过tagged方法解析标签绑定
$app->tagged('t1');
9.扩展绑定
extend方法允许对解析服务进行修改，extend方法接受一个闭包来返回修改后的服务
$this->app->extend(Service::class, function($service) {
	return new NewService($service);
});
# 解析
1.make方法
有很多方法可以从容器中解析对象，首先，make方法，接受想要解析的类名或接口名作为参数
$xxx = $this->app->make('<interface or class>')
如果所在代码位置访问不了$app变量，可以使用辅助函数resolve
$api = resolve('<>');
某些类的依赖不能通过容器来解析，可以通过关联数组方式将其传递到makeWith方法来注入
$api = $this->app->makeWith('<>', [key => value])
2.自动注入
最常用的通过在类的构造函数中对依赖进行类型提示来从容器中解析对象，控制器、事件监听器、队列任务、中间件等都是通过这种方式。
容器会自动为其解析类注入依赖。
# 容器事件
服务容器在每一次解析对象时都会触发一个事件，可以用resolving方法监听该事件。
$this->app->resolving(function($object, $app) {
	// 所有容器事件处理代码
});
$this->app->resolving(xxx::class, function($object, $app) {
	// 指定类的容器事件处理代码
});
# PSR-11
服务容器实现了PSR-11接口，可以通过类型提示PSR-11容器接口来获取Laravel容器的实例；


## 服务提供者
# 简介
是Laravel应用启动的中心，核心服务都是通过服务提供者启动。
这里的启动包括注册服务，注册服务容器绑定，事件监听器，中间件，路由
自带的config/app.php的providers数组中是应用所要加载的所有服务提供者类，启动很多是延迟脚在的，不会每次请求都加载，只有真正需要时加载
# 编写服务提供者
所有服务提供者都继承自Illuminate\Support\ServiceProvider类，大部分服务提供者都包含两个方法，register和boot。register方法中，唯一要做的就是绑定服务到容器，不要尝试在这个方法中注册事件监听器，路由或其他任何功能。
php artisan make:provider XXXServiceProvider // 生成服务提供者
1.register方法
此方法应该只用于绑定服务到服务容器。
2.bindings和singletons属性
如果服务提供者注册了很多简单的绑定，可以使用bindings和singletons属性代替手动注册方法以简化代码
public $bindlings = [
	XXX::class => XXXImpl::class
]
public $singletons = [
	XXX::class => XXXImpl:class
]
3.boot方法
在服务提供者中注册视图Composer，需要使用boot方法。此方法在所有服务提供者被注册以后才会被调用
# 注册服务提供者
所有服务提供者都是通过配置文件config/app.php中进行注册，包含列出所有服务提供者名字的providers数组。默认只列出所有核心服务提供者。
要注册自定义的服务提供者，需要将其追加到该数组中
'provirder' => [
	XXXServiceProvider
]
# 延迟加载服务提供者
如果自定义的服务提供者中只注册绑定，可以选择延迟加载该绑定的服务。
Laravel编译并保存所有延迟服务提供者的服务和类名。
想要延迟加载提供者，需要实现\Illuminate\Contracts\Supports\DeferrableProvider接口并定义一个provides方法，会返回通过服务提供者注册的服务容器绑定
class XXXSerivce extends ServiceProvider implements DeferrableProvider {

	public void provides() {
		return [
			XXX::class
		]
	}
}

## 门面(Facades)
# 简介
门面为应用服务容器中的绑定类提供了一个静态接口，内置了很多门面。门面作为服务容器中底层类的静态代理，在维护是能够提供更加易于测试、灵活、优雅的语法
所有门面定义在Illuminate\Support\Facades命名空间下
外观模式(门面模式)
隐藏系统的复杂性，并向客户端提供了可以访问系统的接口。属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或使用
比如
class CPU {
	public boot() {
	
	}
	public shutdown() {
	
	}
}
class Memory {
	public boot() {
	
	}
	public shutdown() {
	
	}
}
class Disk {
	public boot() {
	
	}
	public shutdown() {
	
	}
}
class Computer {
	public __construct(CPU $cpu, Memory $memory, Disk $disk) {
		$this->cpu = $cpu;
		$this->memory = $memory;
		$this->disk = $disk;
	}
	
	public boot() {
		echo '开始启动';
		$this->cpu->boot();
		$this->meomry->boot();
		$this->disk->boot();
		echo '启动完成';
	}
	public shutdown() {
		echo '关机开始';
		$this->cpu->shutdown();
		$this->memory->shutdown();
		$this->disk->shutdown();
		echo '关机结束';
	}
}
将CPU，memory，disk的接口集成至computer中，对外隐藏了子系统的接口，只需要调用Computer对外接口即可。
# 何时使用门面
门面有需要注意的地方，最主要的危险是类范围蠕变，由于门面好用且无需注入。在单个类中使用过多门面，会导致类越来越大。使用依赖注入则会让此类问题缓解。
1.门面 vs 依赖注入
2.门面 vs 辅助函数
# 门面工作原理
Laravel中，门面就是一个为容器中对象提供访问方式的类，该机制原理由Facade类实现。
门面类只需要实现一个方法 getFacadeAccessor，定义了从容器中解析什么，然后使用魔术方法__callStatic()从门面中调用解析对象
# 实时门面
使用实时门面，可以将应用中任意类当做门面来使用。
<class implements Facades>::<method_name>()
使用Facade接口的实现类作为前缀即可引入依赖，无需在方法参数列表中显式导入Facade实例

## 契约
是指框架提供的一系列定义核心服务的接口。
每个契约都有框架提供的相应实现。
所有Laravel契约都有其对应的GitHub库，为所有有效的契约提供了快速入门指南，同时也可以作为独立、解耦的包被包开发者使用
# 契约 vs 门面
门面为Laravel服务的使用提供了便携方式--无需从服务容器中类型提示和契约解析即可直接通过静态门面调用
不同于门面无需在构造器中进行类型提示，契约允许在类中定义显式的依赖。
# 何时使用契约
大多数情况下使用契约或者门面取决于个人或团队喜好。


### 基础组件
## 路由
# 路由入门
最基本的Laravel路由只接收一个URI和一个闭包，并以此为基础提供一个非常简单优雅的路由定义方法
Route::get('<path>', function() {
	return '<string or template>';
});
# 默认路由文件
所有Laravel路由都定义在位于routes目录下的路由文件中，通过框架自动加载，相应逻辑位于app/Providers/RouteServiceProvider类。routes/web.php文件定义了Web界面的路由，这些路由被分配到web中间件组，从而可以使用Session和CSRF保护等功能。routes/api.php中的路由是无状态的，分配到api中间件组中。
大多数应用中，都是从routes/web.php文件开始定义路由，定义在routes/web.php中的路由可以通过在浏览器中输入对应URL进行访问。
而routes/apid中的路由被嵌套在一个路由群组中，所有路由自动添加/api前缀，无需手动添加。可以通过编译app/Providers/RouteServiceProvider类来修改路由前缀以及其他路由群组选项。
# 有效的路由方法
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::delete($uri, $callback);
Route::patch($uri, $callback);
Route::options($uri, $callback);
有时还还需要注册一个路由响应多种HTTP请求动作——可以使用match()方法来实现，或者，可以使用any()方法注册一个路由来响应所有HTTP请求动作
Route::match($method_arr, $uri, $callback);
Route::any($uri, $callback);
web.php中的路由都默认收到CSRF保护检查，而api.php中的则没有限制
# CSRF保护
web.php路有文件中的所有请求方式为PUT/POST/DELETE的路由对应的HTML表单都必须包含一个CSRF令牌字段，否则请求将会被拒绝
如果不在VerifyCsrfToken中间件中排除对它的检查（也不安全），那么就需要在表单提交中带上csrf_token字段
csrf_token() 生成一个csrf_token字符串
csrf_field() 生成一个隐藏的input标签，value为csrf_token字符串
# 路由重定向
需要定义一个重定向的URI路由，使用Route::redirect方法
Route::redirect($source_uri, $destination_uri[, $status_code])
默认情况下，返回302状态码，可以添加一个可选的参数指定状态码
Route::permanentRedirect($source_uri, $destination_uri) // 指定返回301状态码
# 路由视图
如果需要返回一个视图，可以使用Route::view方法和redirect方法类似。
Route::view($uri, $view_name[, $params_arr]) // 相当于Route::get($uri, function() { return view($view_name[, $params_arr])});
第三个参数作为视图的渲染数据
# 路由参数
1.必选参数
Route::get('xxx/{param}', function($param) {
	return $param;
});
按照位置给变量赋值
2.可选参数
在path的大括号中添加?并给方法参数赋默认值
Route::get('xxx/{param?}', function($param = null) {
	
});
3.正则约束
Route::get('xxx/{param}', function($param) {
	return $param;
})->where('param', '<pattern>')
Route::get('xxx/{param}', function($param) {
	return $param;
})->where(['param', '<pattern>', ...])
使用正则表达式还有一个好处就是避免了user/{id}和user{name}的混淆
4.全局约束
如果想要路由参数在全局范围内被给定正则表达式约束，可以使用pattern方法 需要在RouteServieProvider类的boot方法中定义这种约束模式
class RouteServiceProvider extends ServiceProvider {
	public boot() {
		Route::pattern([]);
		parent::boot();
	}
}
一旦模式被应用，将自动应用到所有包含该参数名的路由中
5.编码
Laravel路由组件支持除/之外的所有字符，如果要在占位符中使用/需要通过where条件正则表达式显示允许
Route::get($uri, $callback)->where($param, '.*');
# 命名路由
命名路由为生成URL或重定向提供了方便，在路由定义之后使用name方法链的方式来定义该路由的名称
Route::get($uri, $callback)->name($router_name)
然后可以简化使用重定向
Route::get($uri, function() {
	return redirect()->route($router_name);
});
Route::get($uri, function($id) {
	$url = route($router_name, [$params_arr]);
	return $url;
})->name($router_name);
# 检查当前路由
想要判断当前请求是否被路由到给定命名路由，可以使用Router实例上的named方法
$request->route()->named($router_name)
判断当前请求是否被路由到命名为$router_name的路由上
# 路由分组
目的是可以在多个路由中共享相同的路由属性，比如中间件和命名空间等。共享属性以数组的形式作为第一个参数被传递给Route::group方法
嵌套的分组会尝试智能的将属性合并到父分组中，中间件和where条件会直接被合并，而路由命名、命名空间，以及路由前缀会被附加到父组件对应的属性之后，命名空间分隔符和URI的斜杠会被自动添加到合适的位置
1.中间件
要给某个路由分组中定义的所有路由分配中间件，可以在定义分组之前使用middleware方法，中间件会按照数组中定义的顺序依次执行
Route::middleware(['first', 'second'])->group(function() {
	Route::get($uri1, $callback1);
	Route::get($uri2, $callback2);
})
2.命名空间
使用namespace方法分配同一个PHP命名空间给该分组下的多个控制器。
Route::namespace('Admin', function() {
	// 使用 App\Http\Controllers\Admin 命名空间下的Controller
});
3.子域名路由
还可以被用于处理子域名路由，子域名可以像URI一样被分配给路由参数，从而允许捕获子域名的部分用于子路由或控制器 使用domain方法
Route::domain('{account}.blog.dev')->group(function() {
	Route::get('user/{id}', function($account, $id) {
		// http://test.blog.dev/user/1 $account => test $id => 1
	}
});
4.路由前缀
prefix方法为分组中的每个路由添加一个指定的URI前缀
Route::prefix('admin')->group(function() {
	Route::get('users', function() {
		// /admin/users 访问
	}
});
5.路由名称前缀
name方法为分组中的路由name增加前缀
Route::name('admin')->group(function() {
	Route::get('users', function() {
		
	})->name('users'); // 此路由命名为admin.users
})
# 路由模型绑定
php artisan make:migration create_table_user --create=user
上一个命令在database/migrations目录下创建<日期>_create_table_user.php文件 添加
public function up() {
	Schema::create('user', function (Blueprint $table) {
		$table->increment('id');
		$table->string('name');
        $table->string('email')->unique();
        $table->string('password');
        $table->rememberToken();
        $table->timestamps();
	});
}
再使用
php artisan migrate 创建数据库表
可能报1071 Specified key was too long; max key length is 1000 bytes错误
需要将MySQL的默认字符街变为utfmb4 然后在AppServiceProvider的boot()方法中添加
Schema::defaultStringLength(191);

注入模型ID到路由或控制器动作时，通常需要查询数据库才能获取相应的模型数据。路由模型绑定让注入模型实例到路由变得简单
1.隐式绑定
会自动解析定义在路由或控制器动作（变量名匹配路由片段）中的Eloquent模型类型声明
Route::get('users/{id}', function(App\Models\User $user) {
	return $user->email;
});
此时会自动将请求传入的UserId对应的数据模型注入到$user中
2.自定义键名
如果使用的列名不是id则需要覆盖Model的getRouteKeyName()返回需要查询的列名
getRouteKeyName() 默认返回的是主键名
3.显式绑定
在RouteServiceProvider的boot方法中使用Route的model方法绑定数据模型到指定的名称中
public function boot() {
	parent::boot();
	Route::model('user_model', App\Models\User::class);
}
Route::get('users/{user_model}', function($user) {
	// 此时也会注入对应的数据
});
如果匹配的数据模型不存在则返回404
4.自定义解析逻辑
在RouteSerivceProvider的boot方法中使用Route::bind方法，传递到bind方法的闭包会获取到URI请求参数中的值，并且返回想要在该路由中注入的类的实例
# 兜底路由
Route::fallback方法可以定义一个当所有其他路由都为匹配时所执行的路由，通常未处理请求会通过Laravel的异常处理器渲染一个404页面。定义fallback路由时，所有web中间件组的路由都会以此兜底
# 频率限制
Laravel自带一个中间件用于限制对应用路由的访问频率。throttle中间件接收两个参数用于判断给定时间内的最大请求次数
Route::middle('auth:api', 'throttle:60:1')->group(function() {

});
动态频率限制
Route::middleware('auth:api', 'throttle.rate_limit,1')->group(function() {
	Route:get($uri, $callback);
});
对包含rate_limit的模型访问添加限制
# 表单方法伪造
_method 字段
或
@method('PUT')
# 访问当前路由
可以使用Route门面上的current/currentRouteName/currentRouteAction方法来访问处理当前输入请求的路由信息

## 中间件
中间件为过滤进入应用的HTTP请求提供了一套便利的机制。
Laravel框架自带了一些中间件，包括认证、CSRF保护中间件等，位于App/Http/Middleware目录下
# 定义中间件
php artisan make:middleware CheckToken
class CheckToken 
{
	public function handle($request, Closure $next) 
	{
		if ($request->input('token') != 'xxx') {
			return redirect()->to('xxxx');
		}
		return $next.handle($request);
	}
}
请求之前的中间件
// 拦截逻辑
return $next->handle($request);
请求之后的中间件
$response = $next->handle($request);
// 拦截逻辑
return $response;
# 注册中间件
中间件分3类，全局中间件、中间件组和指定路由中间件
1.全局中间件
在每一个请求中都被执行，需要将全局中间件添加到app/Http/Kernel.php的数组属性$middleware中
除了必须，否则很少将业务级别的中间件放到全局中间件中
2.分配中间件到指定路由
app/Http/Kernel.php文件中分配给中间件一个key，默认情况下，该类的$routedMiddleware属性包含了Laravel自带的中间件，添加自定的放到最后并分配一个key
然后在Route::xxx()->middleware($route_middleware_key)
3.可以将多个中间件分配到一个键名下，方便为路由配置中间件。使用App/Http/Kernel.php中的middlewareGroups属性
Laravel已经定义了web和api两个中间件组，并在RouteServiceProvider中为web.php和api.php分配这两个中间件组。
$middlewareGroup = [
	'customMiddlewareGroup' => [
		'<middleware::class or middleware_alias>',
	],
]
注册方式
Route::group(['middleware'=>['middle_alias']], function() {
	Route::get($uri, $callback);
});
或者
Route::middleware('middleware_alias')->group(function() {
	Route:get($uri, $callback);
});
4.中间件排序
通过app/Http/Kernel.php中的$middlewarePriority属性来指定优先级
# 中间件参数
还可以接受额外的自定义参数，在$next参数之后传入中间件
class CheckRole
{
	public function handle($request, $next, $role) 
	{
		
	}
}
传入$role需要在middleware('checkRole:1') 此时$role = 1
# 终端中间件
有时候中间件可能需要在HTTP响应发送到浏览器之后做一些工作，需要定义一个终端中间件并添加terminate方法到中间件中
public function terminate($request, $response) {
	// 后台工作
}
接受街球和响应作为参数，定义了终端中间件后需要添加到Kernel.php文件的全局中间件列表中
调用terminate方法时，会从服务容器中取出一个该中间件的新实例，如果想要使用同一个，则需要使用singleton方法注册为单例

## CSRF保护
跨站请求伪造（CSRF）是一种通过伪装授权用户的请求来攻击授信网站的恶意漏洞。
Laravel通过自带的CSRF保护中间件避免被攻击。自动为每一个被应用管理的有效用户生成一个CSRF令牌，并存储到Session中。该令牌用于验证授权用户和发起请求者是否相同
任何时候在HTML表单中。都应该引入CSRF令牌字段，这样才能启动保护。@csrf可以生成包含CSRF令牌的隐藏字段
中间件组web的VerifyCsrfToken会自动为验证请求输入的token值和Session中保存的token值是否相同。如果没有传递csrf或者与session中的不同则报错
CSRF令牌 和 Javascript
可以让Javascript HTTP库自动为每个请求添加CSRF令牌 默认情况下 resources/js/bootstrap.js文件会将csrf.tokenmeta标签值注册到AxiosHTTP库中，没有则需要手动配置
# 排除指定URL不做CSRF安全校验
可以将需要排除的URL放到api.php中
也可以需要排除的中间件类中添加$except属性数组
# X-CSRF-Token
除了作为POST参数进行验证外，也可以通过设置X-CSRF-Token请求头来实现验证，VerifyCsrfToken中间件会检查X-CRSF-TOKEN请求头。
实现方式，先创建一个meta标签并将Crsf令牌保存到该meta标签中
<meta name="csrf-token" content="{{ csrf_token() }}">
然后在js库(以下为jQuery)中添加早所有请求头
$.ajaxSetup({
	headers: {
		'X-CSRF-TOKEN': $('meta[name="csrf-token"]).attr('content')
	}
})
# X-XSRF-Token
Laravel还会将CSRF令牌保存到名为XSRF-TOKEN的Cookie中，可以使用该Cookie值来设置X-CSRF-Token请求头。
有些JavaScript框架会自动执行上一步操作

## 控制器
组织管理相对复杂的业务逻辑处理，控制器用于将相关HTTP请求封装到一个类中进行处理，位于app/Http/Controllers中
# 控制器入门
1.定义控制器
php artisan make:controller UserController
class UserController extends Controller {
	public function show($id) {
		return view('user.profile', ['user' => User::findOrFail($id)]);
	}
}
Route::get('user/{id}', 'UserController@show'); // 使用UserController的show方法
在resource/views/user下创建profile.blade.php
{{ dd($user) }}
控制器类不一定继承自基类，但是，基类包含一些便利方法，比如middleware、validate和dispatch等
2.命名空间
web.php下的命名空间在RouteServiceProvider的mapWebRoutes()方法添加了基础的命名空间
->namespace($this->namespace) 代表app/Http/Controllers 只需要添加之后的即可使用
3.单一动作控制器
public function __invoke() 魔术方法
实现这个方法的控制器只处理一个动作，在Route中无需使用@指定调用的方法
需要快速创建单一动作控制器 使用
php artisan make:controller UserController --invokable
# 控制器中间件
可以
Route::get($uri, 'XController@method')->middleware('middleware_alias');
不过将中间件放在控制器构造函数中更加方便，使用middleware方法可以轻松分配中间件给该控制器，对所有控制器方法都有效。
public function __construct() {
	$this->middleware('');
	$this->middleware('')->only('method_name'); // 只在指定方法中使用中间件
	$this->middleware('')->except('method_name'); // 排除指定方法不使用中间件
	$this->middleware(function($request, $next) {
		return $next.handle($request);
	}); // 使用闭包匿名中间件
}
# 资源控制器
可以很边界的构建基于资源的RESTFul控制器。
php artisan make:controller XController --resource
会创建使用资源中可能会用到的大部分方法
再使用
Route::resource($uri, 'XController');
将一个资源控制器注册到一个资源路由上 这个路由包含了处理资源对应动作的多个路由
Route::reource([
	'photos' => 'PhotoController',
	'posts' => 'PostController',
])
使用数组可以一次性注册多个资源路由
资源控制器处理的动作
请求方式			URI路径				控制器方法				路由名称
GET					/posts				index					posts.index
GET					/posts/create		create					posts.create
POST				/posts				store					posts.store
GET					/posts/{posts}		show					posts.show
GET					/posts/{post}/edit	edit					post.edit
PUT/PATCH			/posts/{post}		update					posts.update
DELETE				/posts/{posts}		destory					posts.destroy
2.指定资源模型
php artisan make:controller PostController --resource --model=Post
不推荐这种模型绑定
3.伪造表单方法
<form method="post">
	@method('PUT')
</form>
4.部分资源路由
Route::resource('post', 'PostController', ['only' => ['show', 'index']]); // 只配置show和index的资源路由
Route::resource('post', 'PostController', ['except' => ['show', 'index']]); //　排除不配置show和index的资源路由
5.命名资源路由
Route::resource('post', 'PostController', ['names' => ['create' => 'posts.build']]); // 将create对应的路由名称改为posts.build 原来是posts.create
6.命名资源路由参数
Route::resource('post', 'PostController', ['parameters' => ['users' => 'admin_user']]); // 为show生成posts/{admin_user}的uri
7.本地化资源URI
在RouteServiceProvider的boot方法中添加Route::resourceVers方法 实现本地化
Route::resourceVers([
	'create' => 'xinzeng',
	'edit' => 'bianji',
]);
8.补充资源控制器
如果需要在默认资源路由之外添加额外的路由到资源控制器，应在调用Route::resource之前定义这些路由 否则可能出现覆盖
Route::get('posts/popular', 'PostController@method');
# 依赖注入
1.构造函数注入
可以在控制器的构造函数中注入任何依赖，会被自动解析并注入到控制器实例中
2.方法注入
可以在方法中进行依赖注入，也会自动解析
如果有路由参数则需要放在其他参数之后
# 路由缓存
不会作用于基于闭包的路由，必须使用控制器路由
php artisan route:cache
每次请求从缓存中读取路由，如果添加新路由需要重新生成路由缓存，则需要在项目部署阶段运行route:cache命令
清除路由缓存文件
php artisan route:clear

## HTTP请求
# 访问请求实例
class UserController extends Controller {
	public function store(Request $request) {
		$name = $request->input('name');
	}	
}
1.依赖注入和路由参数
如果还想在控制器方法中获取路由参数，只需要将路由参数置于其他依赖之后即可。
2、通过闭包访问请求
Route::get('/', function(Request $request) {

});
3.请求路径&方法
Request提供多个方法用于检测应用的HTTP请求
1)获取请求路径
$request->path() // 返回URI的path部分
$request->is(pattern) // URI的path部分是否匹配正则表达式
2)获取请求URL
$request.url() // 不包含查询字符串
$request.fullUrl() // 包含查询字符串
3)获取请求方法
$request.method()
$request.isMethod('method_name')
4.PSR-7请求
PSR-7标准指定了HTTP消息接口，包括请求和响应。
需要安装一些库，将典型的Laravel请求响应转换为兼容PSR-7接口
composer require symfony/psr-http-message-bridge
composer require zendframework/zend-diactoros
在注入是指定为Psr\Http\Message\ServerRequestInterface $request即可注入PSR-7标准的请求
# 请求字符串处理
在App/Http/Kernel中的全局中间件中引入了
TrimStrings 去除url字符串的空格
ConvertEmptyStringToNull 将空字符串转换为null
# 获取请求输入
1.获取所有输入值
$reqeust->all() 以数组形式获取所有输入值
2.获取单个输入值
$reqest->input('param_name'[, 'default_vaule'])
3.从查询字符串中获取输入
input()方法会从整个请求负载（包括查询字符串）中获取值，query则只会从查询字符串中获取数值
$request->query('param_name'[, 'default_value'])
不带参数的query方法则返回所有查询字符串的值
$request有两个属性对象存放参数值
query
request
query()方法从query中获取
post()方法从request中获取
input()方法从query和request中获取
4.通过动态属性获取输入
$name = $request->name;
实现原理是__get()魔术方法
5.获取JSON输入值
Content-Type: application/json 可以用input方法获取JSON数据
6.获取输入的部分数据
$request->only([])
$reqeust->except([])
7.判断请求参数是否存在
$requst.has([])
# 上一次请求
允许在两次请求之间保存上一次输入数据，检测校验数据失败后需要重新填充表单数据时很有用
1.将输入存储到session
$request->flash() // 将当前输入存放到一次性Session（即取出后立刻销毁）中，这样下次请求时上一次输入依然有效
$reqeust->flashOnly()
$request->flashExcept()
2.将输入存储到Session然后重定向
return redirect()->withInput()
return redirect()->withInput($reqeust.except())
return redirect()->withInput($reqeust.only())
3.取出上次请求数据
$request->old('')
old() 在blade模板中显示
# Cookie
Laravel框架创建的Cookie都经过加密并使用一个认证码进行签名
1.取出Cookie
$value = $request->cookie('name')
Cookie::get('name')
2.添加Cookie
return $response()->cookie(name, value, expire, path, domain, secure, httpOnly)
还可以使用Cookie门面将应用于附件的Cookie推送到输出响应队列，queue方法接受一个Cookie实例或者创建Cookie实例的必要参数，在响应发送到浏览器之前添加
Cookie::queue(Cookie::make())
Cookie::queue(name, value, expire, path..)'
3.生成Cookie实例
可以使用全局辅助函数cookie() 只有在添加到响应实例上才会发送到客户端
# 文件上传
1.获取上传的文件
使用Request实例提供file方法或者动态属性来访问上传文件
$file = $request->file('photo')
$file = $request->photo;
$requet->hasFile('photo')  // 是否包含文件
2.验证文件是否上传成功
$request->file('photo')->isValid()
3.文件路径 & 扩展名
UploadedFile类还提供了访问上传文件绝对路径和扩展名的方法
extension方法可以基于文件内容判断文件扩展名 可能会和客户端提供的扩展名不一致
$request->file('photo')->path()
$request->file('photo')->extension()
4.其他文件方法
1)保存上传的文件
需要配置某个文件系统 配置位于config/FileSystem.php
默认使用local配置存放上传文件，即本地文件系统。默认根目录是storage/app
public也是本地文件系统，不过存放的文件可以被公开访问，对应的根目录是storage/app/public 需要创建一个软连接
UploadedFile有一个store方法，会将上传的文件移动到相应的磁盘路径上，可以是本地文件系统的某个位置，也可以是云存储的路径
store接受一个文件保存的相对路径（相对于文件系统配置的根目录），该路径不需要包含文件名，系统会自动生成一个唯一ID作为文件名
store还接受一个可选的参数用于存储文件的磁盘名称作为第二个参数
如果不希望自动生成文件名 可以使用storeAs
storeAs(path, file_name, disk_name)
# 配置信任代理
应用运行在一个会中断TLS/SSL证书的负载均衡器之后，不会生成HTTPS链接，通常因为应用是从负载均衡器从80端口转发过来的流量。所以不知道如何生成加密链接。
使用APP/Http/Middleware/TrustProxies中间件。允许快速自定义需要被应用信任的负载均衡器或代理
$proxies属性列表中。
$headers属性列表还可以配置代理转发的带有请求来源信息的消息头
protected $proxies = [
	'',
	'',
]
2.信任所有代理
protected $proxies = "*";

## HTTP响应
# 创建响应
1.字符串 & 数组
所有路由和控制器处理完业务逻辑之后都会返回一个发送到用户浏览器的响应。提供多种不同方式来返回响应，最基本的响应是返回一个简单字符串，框架会自动转换为一个完整的HTTP响应
返回数组则会自动转换为一个JSON响应
2.Response对象
并不只是从路由动作简单返回字符串和属组，都会返回一个完整的Response实例或视图
返回一个完整的Response实例允许自定义响应的HTTP状态码和头信息，提供了一系列方法用于创建HTTP响应
return response('', 200)->header('', '');
3.添加响应头
return response($content)->header()->header()->header();
return response($content)->withHeaders([ , , ]);
4.添加Cookie到响应
return response($content)->coolie($name, $value, $expire, $path, $domain, $secure, $httpOnly)
也可以使用Cookie门面
Cookie::queue()
Cookie::queue()
return response($content);  // queue添加的cookie在响应返回前添加
5.cookie & 加密
默认被框架自动加密，如果需要不加密的cookie则修改app/Http/Middleware/EncryptCookies中间件
protected $except = []; // 需要排除的cookie
# 重定向
return redirect() // 重定向
return back()->withInput() // 返回上一个页面并带上参数
2.重定向到命名路由
redirect() 不带参数会返回一个Redirector实例，可以调用此实例上的方法。
return redirect()->route('')
return redirect()->route('', [])
3.重定向到控制器动作
retrurn redirect()->action('controller@method')
retrurn redirect()->action('controller@method', [])
4.重定向到外部域名
return redirect()->away('')
5.带一次性Session数据的重定向
return redirect('').with();
return redirect('').withInput();
# 其他响应类型
可以通过辅助函数response()方便生成其他类型的响应实例
无参数的response()会返回ResponseFactory契约的一个实现，提供了用于生成各种响应的方法，如视图响应，JSON响应，文件下载，流响应等等
1.视图响应
return response()->view('', $data, $status_code)->header('', '')
如果不需要传递自定义的状态码和头信息则使用
return view('')
2.JSON响应
return response()->json([])
如果想要返回JSONP响应可以在json方法之后调用withCallback方法
return response()->json([])->withCallback($request->input(''))
或者直接调用jsonp()方法
return response()->jsonp($request->input(''), [])
3.文件下载
download方法用于生成强制用户浏览器下载给定路径文件的想要，接受文件名作为第二个参数，决定用户下载文件的显示名称
return response()->download($pathToFile)
return response()->download($pathToFile, $name, $headers)
return response()->download($pathToFile)->deleteFileAfterSend(true)
(下载文件不能包含中文)
4.流式下载
将指定操作的字符串响应转换为可下载的响应而不用将操作内容写入磁盘，可以使用streamDownload方法，接收一个回调、文件名以及可选的头信息作为参数
return response()->streamDownload(function() {
	echo GitHub::api('repo')
		->contents()
		->readme('laravel', 'laravel')['contents'];
}, 'name', headers[]);
5.文件响应
return response()->file() 直接在用户浏览器中显示文件，而不需要下载，接收文件路径作为第一个参数，头信息数组作为第二个参数
# 响应宏
自定义的可以在多个路由和控制器中复用的响应，可以使用Response门面上的macro方法
Response::macro('caps', function($value) {
	return Response::make(strtoupper($value));
});
return response()->caps('bca');

## 视图
# 创建视图
视图文件存放在resource/views目录下
return view('greeting', ['name' => '123'])
返回resource/views/greeting.blade.php 并携带数据
使用.使用子目录和子文件
2.判断视图是否存在
View::exists('')
3.创建有效视图
return view()->first([], $data)
返回数组第一个有效的视图文件
return View::first([], $data)
# 传递数据到视图
return view($view_path, $data_arr)
可以简单通过数组将数据传递到视图
也可以使用
return view($view_path)->with($key, $value) 将独立的数据片段添加到视图
2.在视图间共享数据
需要在某个服务提供商的boot方法中使用View门面的share方法
pubic function boot() {
	View::share($key, $value);
}
# 视图Composer
是当视图被渲染时的回调函数或类方法，如果有一些数据在视图每次渲染时都做绑定，可以使用视图Composer将逻辑阻止到一个单独的地方
需要在某个服务提供商中注册视图Composer
View::composer('view_path', 'composer_path') 
不包含默认的视图Composer目录，需要自行创建任意目录作为Composer目录
2.添加Composer到多个视图
View::composer($view_arr, function or $composer_path)
View::composer('*', function or $composer_path) // 通配符 * 添加到所有视图
3.视图创建器
视图创建器与Composer类似，但是生效时间在视图实例化时
View::creator('', 'xxx/xxx/xxCreator')

## URL生成
提供来多个辅助函数来帮助在应用中生成URL
# 快速入门
1.生成URL
url辅助函数可用于为应用生成任意URL，并且生成的URL会自动使用当前请求的schema和host属性
$post = App\Post::find(1)
echo url("/posts/${post->id}")
2.访问当前URL
url->current() // 当前url 不包含请求字符串
url->full()	// 当前url 包含请求字符串
url->pervious() // 请求上一个完整的url
上述方法可以使用URL门面访问
URL::current()
URL::full()
URL::previous()
# 命名路由URL
route可用于生成指向命名路由的URL，命名路由允许生成不与实际URL耦合的URL，
route($route_name, $data_arr)
# 签名URL
将签名哈希追加到查询字符串后，以便验证URL在创建之后是否被篡改。
URL::signedRoute($route_name, $data);
URL::temporarySignedRoute($route_name, now->addMinutes(30), $data);   // 有过期时间的临时签名URL
2.验证签名路由请求
$request->hasValidSignature()
还可以分配ValidateSignture中间件到路由
先注册到Keynel.php的$routeMiddleware
在将中间件注册到路由上，验证不通过的请求自动返回403响应
# 控制器动作URL
$url = action('$controller_name@$method_name')
# 参数默认值
URL::defaults([])
设置默认值后 无需通过route辅助函数生成URL时指定传递参数

## Session
HTTP协议本身是无状态的，上下请求无任何关联，因此引入Session来存储用户请求信息以解决特定场景无状态导致的问题。通过简单API统一处理各种Session驱动，开箱即用包括Memcached、Redis和数据库
Laravel没有使用PHP的session机制
# 配置
Sessio配置在config/session.php中。默认使用file驱动，可能考虑memcached或redis获取更佳的Session性能。
'driver' => env('SESSION_DRIVER', 'file') 定义Session存储驱动
file 存储在storage/framework/session目录下
cookie 存储在加密的cookie中
database
memcached /redis 
array 存储在简单PHP数组中，多个请求之间是非持久化的
# 驱动预备知识
1.数据库
php aritsan session:table // 相当于使用php artisan make:migration create_session_table --create=session 再添加字段信息
php artisan migrate; // 建立表
2.Redis
需要使用Composer安装predis/predis依赖包，再在database配置文件中配置Redis连接。Session配置文件中，connection指定使用哪个Redis连接
需要修改
database.php
session.php
.env
# 使用Session
全局辅助函数session()，或者通过request实例，启动过程中会将Session数据设置到实例的Session属性中
$request->session() 获取session
session('key', 'default') 	// 获取session中的值
session(['key' => 'value])	// 设置session中的值
1.获取所有session数据
$request->session()->all()
$request->session()->has('') 	 	// 是否存在键 且值不为空
$request->session()->exists('')		// 是否存在键 不在乎值
# 存储数据
$request->session()->put($key, $value)
session([])
1.推送数据到数组session
$request->session()->push('', '')
2.获取&删除数据
$request->session()->pull($key, $default) // 获取数据并删除
# 一次性数据
$request->session()->flash($key, $value)
$request->session()->reflash($key) // 生存到下一次请求
$request->session()->keep([]) // 长期保存特定数据
# 删除数据
$request->session()->forget($key)
$request->session()->forget([$key, $key2])
$request->session()->reflush() // 一次清空所有数据
# 重新生成Session ID
$request->session()->regenerate()
# 添加自定义Session驱动
需要实现SessionHandlerInterface接口
class MongoSessionHandler implements SessionHandlerInterface
{
    public function open($savePath, $sessionName) {} // 基于file的存储系统 已经存在置为空即可
    public function close() {} // 同open
    public function read($sessionId) {} // 返回与给定$sessionId相匹配的Session数据的字符串版本 从驱动中获取
    public function write($sessionId, $data) {} // 将给定的$data写到存储系统中相应$sessionId
    public function destroy($sessionId) {} //删除
    public function gc($lifetime) {} // 销毁大于给定$lifetime的所有Session数据
}
注册驱动
在某个服务提供商的boot方法中使用Session门面的extend方法
Session::extend('', function($app) {
	return new XXXSessionHandler;
});

## 表单验证
控制器基类使用ValidateRequests trait提供便捷方法通过各种功能强大的验证规则来验证输入的HTTP请求
# 快速入门
1.定义路由
2.创建控制器
3.编写验证逻辑
$request->validate([
	'' => 'required|max:255'
]);
4.首次验证失败后终止后续验证
$request->validate([
	'' => 'bail|required|max:255'
]);
使用bail作为验证规则中的首规则
5.嵌套属性注意事项
$request->validate([
	'user.name' => 'bail|required|max:255'
]);
<input name="user[name]" >
6.显示验证错误信息
会被放入一次性Session中
session()->all()查看所有
总是存在一个$errors变量，是MessageBeg实例，通过web中间件组中的ShareErrorsFromSession绑定到视图
由于是一次性Session 如果别的地方用了 $errors就取不到
7.可选参数注意事项
添加nullable验证规则
8.AJAX请求&验证
不会产生重定向，而是产生一个JSON响应，附带422状态码

******************************************
暂时没看完
******************************************


## 异常错误处理
























