********** PHP ********************
### 初识PHP
## 概述
PHP语法结构简单，易于入门，很多功能只需要一个函数即可
# 什么是PHP
是一种服务器端、跨平台、HTML嵌入式的脚本语言，独特的语法混合了C语言、Java语言和Perl语言的特点，广泛应用的开源式的多用途脚本语言，尤其适合Web开发
# PHP的优势
1.安全性高
2.跨平台性
3.支持广泛的数据库
4.易学性
5.执行速度快
6.免费
7.模板化
8.支持面向对象与过程
9.内嵌Zend加速引擎


### PHP语言基础
## PHP标记风格
XML风格
<?
/*
 PHP代码
*/
?>
脚本风格
<script language="php">
/* 
PHP代码
*/
</script>
简短风格
<? /*PHP代码*/ ?>
ASP风格
<%
/*
PHP代码
*/
%>
## PHP注释的应用
单行注释 //
多行注释 /**/
文档注释 /****/
#风格的注释 # 
## PHP的数据类型
PHP支持8种原始类型，包括4种标量类型，即boolean、integer、fload/double和string，2种符合类型，即array和object，2种特殊类型resource和null
# 标量数据类型
标量数据类型是数据结构汇总最基本的单元，只能存储一个数据。
boolean 		最简单的类型，只有两个值true/false
string			字符串就是连续的字符序列，可以是计算机所能表示的一切字符的集合
integer			整数数据类型只能包含整数，可以是正数和负数
float			浮点数据类型用于存储数字，和整型不同的是有小数位
1.boolean
$param = true;
除了false之外，还有0、0.0、"0"、空白字符串""、只声明未赋值的数组等
2.string
连续的字符序列，由数字、字母和符号组成。字符串中的每个字符只占用一个字节。PHP中有3种定义字符串的方式，单引号、双引号和定界符(<<<)
*
注意
对非转义字符使用\，在输出时将输出\
在定义简单的字符时，应该使用单引号，双引号PHP将花费一定时间来处理字符串的转义和变量解析。
*
$string = <<<str 
	字符串
	可以多行
str // str表示标识符 指定开始和结束 结束时必须另起一行并且不能包含空格
3.integer
32位系统中 范围为-2^31 ~ 2^31-1
可以用二进制、八进制、十进制和十六进制。八进制需要0前缀，十六进制需要0x前缀
如果超出了integer类型的范围，则会获得float类型
4.float
可以存储数字，也可以存储小数，提供的精度比整数大的多。在32位系统中，有效的范围是1.7E+308(PHP4.0版本之前是double)
两种书写方式
标准格式
3.1415
科学计数法
3.58E1
849.72E-3
浮点型的数值只是一个近似值，尽量避免浮点整数型之间的比较大小，这样的结果往往是不准确的
# 符合数据类型
array 			一组类型相同的变量的集合
object			对象是类的实例，使用new命令来创建
1.array
一组数据的集合，形成一个可操作的整体。
每个数据成为一个元素，包括索引和键值两个部分，元素的索引可以由数字或字符串支持。值则可以是多种数据类型
定义数组的语法格式
$array = array(value1, value2....);
$array[key] = value;
$array = array(key1 => value1, key2 => value2, ...);
声明之后可以自由更改，只要给数组赋值就会自动增长。
2.object
之后详解
# 特殊数据类型
resource			资源是一种特殊变量，保存了到外部资源的一个引用，资源是通过专门的函数来建立和使用的
null				特殊的值，表示变量没有值，唯一的值就是null
1.resource
PHP4引入，使用资源时，系统会自动启用垃圾回收机制，释放不再使用的资源，避免内存消耗殆尽。因此，资源很少需要手工释放
2.null
表示没有设置任何值 不区分大小写
被赋予空值的情况
还没有赋值
被赋值null
被unset()函数处理过的变量
is_null()函数用于判断变量是否为null 返回一个boolean
unset()函数用于销毁指定的变量
# 数据类型转换
(boolean)$param # null、0、未赋值的变量或数组转为false 其他true
(string)$param
(integer)$param # false转为0 true转为1 浮点型小数位直接舍去 如果以数字开头截取到数字费 否则为0
(float)$param
(array)$param
(object)$param
还可以借助settype()函数
bool settype(mixed var, string type) # 成功转换为true 失败为false
# 检测数据类型
is_bool
is_string
is_float/is_double
is_integer/is_int
is_null
is_array
is_object
is_numeric # 是否是数组组成的字符串
## PHP常量
# 声明和使用常量
常量可以理解为值不变的量。
define()函数来定义常量
define(string constant_name, mixed value, case_sensitive=false)
                常量名         值           是否大小写敏感 false敏感 true不敏感
使用常量可以使用$constant_name或者constant()函数
mixed constant(string constant_name)
判断常量是否定义defined()函数
bool defined(string constant_name)
# 预定义常量
__FILE__              默认常量 PHP程序文件名
__LINE__              默认常量 PHP程序行数
PHP_VERSION         内建常量 PHP程序版本
PHP_OS              内建常量 执行PHP解析器的操作系统名称
TRUE                真值true
FALSE               假值false
NULL                空值null
E_ERROR             指到最近的错误处
E_WARNING           指到最近的警告处
E_PARSE             指向解析语法有潜在问题处
E_NOTICE            发生不寻常处的提示但不一定是错误处
## PHP变量
# 变量声明及使用
PHP4之后无需先声明再使用 只需给变量赋值即可
$param = value; # 变量间的赋值各自使用各自的内存互不干扰
$param1 = & $param2 # 内存地址赋值
*
引用和复制的区别在于
复制将原内容复制下来 开辟一个新的内存空间来保存
而引用则是给变量的内容起个别名
*
# 变量作用域
局部变量        函数内部定义的变量 作用域在函数内部
全局变量        定义在所有函数之外的变量 作用域是整个PHP文件 但是在用户自定义函数内部不可用 如果希望在用户自定义函数内部使用全局变量 则需要使用global关键字声明
静态变量        在函数调用结束后依然保留变量值，再次回到作用域时 又可以继续使用原来的值 使用static关键字声明
# 可变变量
$a = 'b';
$b = '123';
$$a # 就指向了$b
# PHP预定义变量
详情查看资料
## PHP运算符
# 算术预算福
+ - * / %
# 字符串运算符
.将两个字符串串联起来
# 赋值运算符
=
+=
-=
*=
/=
.= # 串联字符 将右边的字符串连接到左边的变量上
%=
# 递增和递减运算符
--
++
# 位运算符
&
|
^
~
<<
>>
# 逻辑运算符
&& 或 and
|| 或 or
xor （异或)
!
# 条件运算符
?: // 三项表达式
# 运算符的优先级
详情看PDF
## PHP表达式
可以连续赋值 $a=$b=$c=1;
记住在每个表达式结尾添加分号;
## PHP函数
# 定义和调用函数
function func_name($p1, $p2, $p3...) {
    <statements>
}
# 在函数间传递参数
1.按值传递
function func_name($param1, ....) {
    func_body;
}
函数内部对参数修改不影响外部 是局部变量
2.按引用传递
function func_name(& $param1, ....) {
    func_body;
}
函数内部修改影响外部 对引用内存的修改
3.默认参数
function func_name($param1=default1, ...) {
    func_body;
}
*
有默认值的参数必须在非默认参数的右边
*
# 返回值
function func_name($param1, ...) {
    func_body;
    return xxx;
}
# 变量函数
$func = 'func_name'; # 给一个变量赋值为一个函数
$func(); # 通过变量调用对应的函数
## 编码规范
# PHP命名规则
1.类命名
使用大写字母作为词的分隔，其他字母均使用小写
名字的首字母大写
不要使用下划线
class Name {

}
2.类属性命名
属性命名应该以字符m为前缀
前缀m后采用与类命名一致的规则
m总是在名字开头起修饰作用
$mName
3.方法命名
命名规范与类命名规范一致
4.方法中参数命名
第一个字符使用小写
首字符后的所有字符都按照类命名规则首字符大写
5.变量命名
所有字母小写
使用_作为每个词的分界
6.引用变量
带有r前缀
7.全局变量
带有g前缀
8.常量/全局变量
应该全部使用大写 单词之间用_分隔
9.静态变量
带有s前缀
10.函数命名
所有名称都使用小写，多个单词以_分隔

### 流程控制语句
## 条件控制语句
# if-else if-else语句
if (expression) {
	语句1;
	语句2;
} else if (expression) {
	语句1;
	语句2;
} else {
	语句;
}
# swtich语句
swtich (变量或表达式) {
	case 常量表达式1:
		语句1;
		break;
	case 常量表达式2:
		语句2;
		break;
	case 常量表达式3:
		语句3;
		break;
	default:
		语句n+1;
		break;
}
## 循环控制语句
# while循环
whlile (表达式) {
	语句
}
# for循环
for (初始化语句; 判断语句；迭代表达式语句) {
	语句;
}
# foreach循环
foreach ($array as $item) {
	语句;
}
foreach ($array as $key => $value) {
	语句;
}
foreach用于未初始化的数组或其他类型的变量会报错 应该先使用is_array判断一下
## 跳转语句
# break
可以终止当前循环，包括while do...while for foreach和switch在内的所有控制语句
break不仅可以跳出当前循环 还可以指定跳出几重循环
break $num;
# continue
只能终止本次循环进入下一次循环中，也可以指定跳出几层循环
### 字符串操作
## 字符串的定义方法
# 使用单引号或双引号定义字符串
双引号中的内容是通过PHP的语法分析器解析过的，任何变量在双引号中都会被转换为实际的值输出显示
而单引号则是所见即所得，直接输出不经过转换
# 使用定界符<<<
与双引号一样，变量会被替换为实际的值。
## 字符串操作
# 去除字符串首尾空格和特殊字符
1.trim函数
用于去除字符串首尾处的空白字符（或其他字符）
trim(string str[, string charlist]);
charlist可选，为所有希望过滤的字符，可以使用..列出一个字符范围。如果不设置该参数，则所有的可选字符都将被删除。
不指定charlist参数是的trim()函数去除的字符
\0
\t
\n
\x0B
\r
" "
2.ltrim()
用于去除字符串左边的空白字符(或其他字符)
3.rtrim()
用于去除字符串右边的空白字符（或其他字符）
# 转义、还原字符串数据
1.手动转义、还原字符串数据
\是转义符，紧跟之后的第一个字符将变得没有意义或者特殊意义。
2.自动转义、还原字符串数据
string addslashes(string str)函数 输入需要转义的字符串 返回转义后的字符串
string stripslashes(string str) 输入转义后的字符串 返回还原的字符串（即去除反斜杠\)
string addcslashes(string str, string charlist) 在指定的字符串前加上反斜杠 如果参数charlist中包含\n\r等字符，将以C语言风格转换 而其他非字母数据且ASCII低于32以及高于126的字符均转换为八进制表示
string stripcslashes(string str) 将转义后的字符串还原
# 获取字符串的长度
int strlen(string str) 函数
汉字占用两个字符，数字、英文、小数点、下划线和空格占一个字符
也可以用于检测字符串的长度
# 截取字符串
string substr(string str, int start[, int length])
start从0开始
# 比较字符串
1.按字节进行字符串比较
int strcmp(string str1, string str2) // 区分字符大小写 相等则返回0 str1大于str2则返回大于0 小于则返回小于0
strcasecmp(string str1, string str2) // 不区分字符大小写
2.按自然排序法进行字符串比较
int strnatcmp(string str1, string str2) // 从左向右进行比较，如果数字比较则按照自然排序法 其他则根据字符的ASCII码值进行比较
3.指定从源字符串的位置开始比较
int strncmp(string str1, string str2, int len) // 比较字符串的前n个字符
# 检索字符串
1.strstr()函数查找指定的关键字
获取一个指定字符串再另一个字符串中首次出现的置为到后者末尾的子字符串，有则返回剩余字符串，没有返回false
string strstr(string haystack, string needle) // 区分大小写
string strrchr(string haystack, string needle) // 后序开始搜索
2.substr_count()搜索子串出现的次数
int substr_count(string haystack, string needle) 
# 替换字符串
1.str_ireplace() 
mixed str_ireplace(mixed search, mixed replace, mixed subject[, int count])
search 可以是数组 要搜索的值
replace 替换的值
subject 可以是数组 被搜索的值
count 替换的数量
str_treplace() 不区分大小写 str_replace 区分
2.substr_replace()函数
用于将指定字符串的部分字符串进行替换
mixed substr_replace(mixed string, mixed repl, mixed start[, mixed length])
string 可以是数组 要操作的原始字符串
repl 指定替换后的字符串
start 开始位置
length 长度
# 格式化字符串
string number_format(float number[, int decimals[, string dec_point[, tring thousands_sep]]])
number 要格式化的数字
decimals 要保留的小数位
dec_point 小数点显示的字符
thousands 千位分隔的字符
# 分割、合成字符串
1.分割字符串
array explode(string delimiter, string str[, int limit])
delimiter 分割符
str 	被分割的字符串
limit 返回的数组中最多包含limit个元素
2.合成字符串
string implode(string glue, array pieces)
glue 分隔符
pieces 合成的数组
### 正则表达式
## 什么是正则表达式
描述字符串结构的语法规则，是一个特定的格式化模式，可以匹配、替换、裁取匹配的子串。
## 正则表达式语法规则
# 行定位符
^
$
# 单词分解符
\b // \btm\b 表示需要匹配的是一个完整的单词而不是一部分
\B // \Btm\B 表示需要匹配的是一部分而不是完整的单词
# 字符类
[] 出现在括号内的都匹配
[:digit:] 十进制数字集合 [0-9]
[[:alnum:]] 字母和数字的集合 [a-zA-Z0-9]
[[:alpha:]] 字母集合 [a-zA-Z]
[[:blank:]] 空格和制表符
[[:xdigit:]] 十六进制数字
[[:punct:]] 特殊字符集合 如@!#$?等
[[:print:]] 可打印字符 包括空格
[[:space:]] 空白字符
[[:graph:]] 可打印字符 不包括空格
[[:upper:]] 大写字符 [A-Z]
[[:lower:]] 小写字符 [a-z]
[[:cntrl:]] 控制字符
# 选择字符
| 或
# 连字符 
- 表示字符的范围
# 排除字符
[^] 匹配不匹配括号内的其他字符
# 限定符
?
*
+
{n, m}
# 点号字符
除换行符以外的任意字符
# 转义字符
\ 将特殊意义的字符转换为普通字符
# 反斜线
1.将不可打印的字符显示出来
\a
\b
\e
\f
等
2.指定预定义字符集
\d 一个十进制数字
\D 非十进制数字
\s 空白字符
\S 非空白字符
\w 单词
\W 非单词
3.断言的限定符
# 括号字符
(xxx|yyy) 表示匹配xxx或yyy
第二个作用是分组
# 反向引用
# 模式修饰符
设定模式，规定正则表达式应该如何解释和应用
i		忽略大小写
M		多文本模式 即字符串内部有多个换行符时 影响^$的匹配
s		单文本模式 .可以匹配换行符 其他模式下不行
X		忽略空白字符
## PCRE兼容正则表达式
# preg_grep()函数
array preg_grep(string pattern, array input)
使用数组input中的元素一一匹配表达式pattern，返回匹配元素组成的数组
# preg_match() preg_match_all()
int preg_match/preg_match_all(string pattern, string subject[, array matches])
字符串subject中匹配表达式pattern，如果有数组则每次匹配都存储到matches数组中
返回值是0或1 preg_match匹配到第一个就返回 preg_match_all则匹配全部 array matches对preg_match_all是必须的
# preg_quote()函数
string preg_quote(string str[, string delimiter])
将字符串str中的所有特殊字符进行自动转义 如果有delimiter则对应的子串也将转义
# preg_replace()函数
mixed preg_replace(mixed pattern, mixed replacement, mixed subject[, limit])
在字符串subject中匹配表达式pattern， 将匹配项替换成子串repleacement
在replacement中使用$1 $2获取匹配的分组字符串
# preg_replace_callback() 函数
mixed preg_replace_callback(mixed pattern, callback callback, mixed subject[, int limit])
使用回调函数而不是字符串来替换 
function func($arr) { // 传入的参数是一个数组 需要留意
	return $str;
}
# preg_split()函数
array preg_split(string pattern, string subjec[, int limit])
### PHP数组
## 什么是数组
一组数据的集合
## 声明数组
array array([mixed ...])
mixed语法为 key => value 如果没有指定key 则自动生成从0开始的整数索引
print_r($arr) 迭代输出一个数组
## 数组的类型
PHP支持两种数组 索引数组（indexed array)和联合数组(associative array)前者使用数字作为key，后者使用字符串作为key
# 数字索引数组
数字索引一般表示数组元素在数组中的位置，有数字组成，下标从0开始，数字索引数组默认索引值从0开始。也可以从指定位置开始保存数据
# 关联数组
关联数组使用字符串索引来访问存储在数组中的值 对于数据库层交互非常有用
## 输出数组
bool print_r(mixed expression)
##数组的构造
# 一维数组
数组元素时变量
# 二维数组
数组元素时一维数组
##　遍历数组
1.使用foreach结构遍历数组
foreach ($arr as $item) {

}
foreach ($arr as $key => $value) {


}
2.list()函数
void list(mixed ....) 仅用于数字索引的数组
## 字符串与数组的转换
1.explode()函数 将字符串转换为数组
array explode(string delimiter, string str[, int limit]);
2.implode()函数 将数组转换为字符串
string implode(string glue, array piceces)
## 统计数组元素个数
int count(mixed array[, int mode])
mode 可选参数 COUNT_RECURSIVE(或者1)递归的对数组计算 默认0
## 查询指定元素
mixed array_search(mixed needle, array haystack[, bool strict])
找到指定值则返回键名，否则返回false  strict为true时还将检查类型是否符合
## 获取数组中最后一个元素
mixed array_pop(array array)
获取并返回数组的最后一个元素，数组长度减一 数组为空或不是数组时返回null
## 添加元素
int array_push(array array, mixed var[, mixed ....])
将传入的变量压入数组的尾部，数组长度加一，并返回数组元素总数
## 删除数组中重复元素
array array_unique(array array)
用于将值作为字符串排序，然后每个只保留第一个键名，忽略后面所有的键名，即删除重复元素

### PHP与Web页面交互
## 表单
# 创建表单
<form action="" method="" enctype="" target="">
target _blank 新窗口 _self 当前窗口 _parent 父窗口 _top 顶级窗口
# 表单元素
1.<input>
2.<select><option>
3.<textarea>
## 在普通Web也中插入表单
## 获取表单数据的两种方法
#POST
#GET
## PHP参数传递的常用方法
# $_POST[]全局变量
通过post方法提交过来的数据
有些可以直接使用$<参数名>来获取数据 与php.ini的配置有关 register_globals=ON/OFF ON则可以取的到 但存在安全隐患 推荐使用OFF
# $_GET[]全局变量
通过GET方法提交过来的数据
# $_SESSION[]变量
获取表单元素的值 使用$_SESSION传参方法获取的变量值，保存之后可以在任何页面中使用 但很耗费系统资源
## 在Web页面中嵌入PHP脚本
# 在HTML标记中添加PHP脚本
可以随时添加<?php ?>PHP脚本标记，标记中的所有文本将被解释为PHP，标记之外的则被认为是普通的HTML
# 对表单元素value属性赋值
value="<?php  echo 123;?>"
## PHP中获取表单数据
# 获取文本框、密码域、隐藏域、按钮、文本域的值
<form>标签中的name是所有表单元素都具备的属性，即为这个表单元素的名称，在使用时使用name属性来获取相应的value值。
# 获取单选按钮的值
radio一般成组出现，具有相同的name和不同value
# 获取复选框的值
checkbox 相同的name 不同的value 可以是多个值 name一般以数组的命名以[]结尾
# 获取下拉列表框/菜单列表框的值
select option
# 文件
file
## URL传递的参数进行编解码
# 对URL传递的参数编码
string urlencode(string str)
对服务器而言，可以自动识别
# 对URL传递的参数解码
string urldecode(string str) 
## PHP与Web表单的综合应用
move_upload_file($_FILES['name']['tmp_name'], 目的地包括保存的文件名);

### PHP与JavaScript交互
如同在HTML中一样使用即可

### 日期和时间
## 系统时区设置
# 时区划分
24个时区 UTC
# 时区设置
1.修改php.ini配置文件中的;date.timezone=选项 Asia/Shang_Hai
2.在应用程序中使用date_defualt_timezone_set(timezone)
## PHP日期和时间函数
# 获得本地化时间戳
mktime()函数将一个时间转换为UNIX时间戳
int mktime(int hour, int minute, int second, int month, int day, int year,int [is_dst]) 默认-1（不确定）夏令1 不是0
# 获取当前时间戳
int time(void)
# 获取当前日期和时间
date(string format[, int timestamp = time()])
返回按照指定格式产生的字符串 timestamp为可选值 不提供则为当前时间戳
预定义的format
DATE_ATOM			原子钟格式
DATE_COOKIE			HTTP Cookie格式
DATE_ISO8601		ISO8601格式
DAtE_RFC822
DATE_RFC850
DATE_RSS
DATE_W3C			World wide web Consortium格式
# 获取日期信息
array getdate([int timestamp]);
# 检验日期的有效性
bool checkdate(int month, int day, int year)
# 输出格式化的日期和时间
a			小写的上午或下午 am或pm
A			大写的上午或下午 AM或PM
B			Swatch Internet标准时间 返回值为000~999
d			月份中的第几天 有前导的0 范围1~31
D			星期中的第几天 文本格式 3个字母 Mon~Sun
F			月份 完整的文本格式 January~December
h			小时 12小时格式
H			小时 24小时格式
i			有前导零的分钟数
I			判断是否为夏令
j			月份中的第几天 没有前导0
l			星期数 完整的文本格式 返回
L			是否是闰年 是为1 不是为0 
m			数字表示的月份 有前缀0
M			3个字母缩写表示的月份 Jan~Dec
n			数字表示的月份 没有前导0
O			与格林威治时间相差的小时数 如+0200
r 
s			描述 有前导0
S			每月天数后面的英文后缀 两个字符 如st nd等
t			每月应有天数 28~31
T 			所在时区
U			从UNIX纪元1970-01-01 00:00:00+0000开始至今的秒数
w			星期中的第几天 0~6
W			第几周 每周从周一开始
y			两位数字表示的年份 如88
Y			四位数字表示的年份 如1988
z			年份中的第几天 1~366
Z 			时差偏移量的秒数
# 显示本地化的日期和时间
1.setlocale()函数
改变PHP默认的本地化环境
string setlocale(string category, string locale)
category可选项
LC_ALL					包含以下所有设置本地化规则
LC_COLLATE				字符串比较
LC_CTYPE				字符串分类和转换
LC_MONTARY				本地化环境的货币形式
LC_NUMERIC				本地化环境的数值形式
LC_TIME					本地化环境的时间格式
locale为空 就会使用环境变量的locale或lang的值 en_US美国 chs简体中文 cht繁体中文
2.strftime()桉树
根据本地化环境设置来格式化输出日期和时间
string strftime(string format, int timestamp)
# 将日期和时间解析为UNIX时间戳
int strtotime(string time[, int now])
# 实现倒计时功能
# 页面脚本的运行时间


******************* 核心技术 *****************
### Cookie和Session
## Cookie管理
# 了解Cookie
1.什么事Cookie
是一种远程浏览器端存储数据并以此来跟踪和识别用户的机制，简单的说，Cookie是Web服务器暂时存储在用户硬盘上的一个文本文件，并随后被Web浏览器读取。用户再次访问Web网站时，通过读取Cookie文件记录这位访客的特定信息。
文本文件的命令格式
用户名@网站地址[数字].txt
2.Cookie的功能
Web服务器可以应用Cookie包含信息的任意性来筛选并经常性维护这些信息 常用于这些方面
A.记录访客的某些信息 如访问次数 登录的用户名等
B.在页面之间传递变量
C.将所查看的Internet页存储在Cookie的临时文件夹中 提高浏览速度
# 创建Cookie
bool setcookie(string name[, string value[, int expire[, string path[, string domain[, int secure]]]]])
name 		Cookie的变量名 $_COOKIE['<cookie_name>']获取Cookie
value		变量值 保存在客户端
expire		过期时间 标准的UNIX时间戳 如果不设置过期时间将永远有效 除非手动删除
path		Cookie在服务器端的有效路径	如果/则在整个domain中有效 如果/ll则在domain下的/ll目录及其子目录中有效 默认是当前目录
domain		Cookie的游侠域名	如果要在所有xxx.com域名下的子域都有效 则应该设置为xxx.com
secure		指明Cookie是否仅通过安全的HTTPS 值为0或1	1则只在HTTPS连接上有效 0则都有效
# 读取Cookie
通过超级全局数组$_COOKIE[]来读取浏览器端的Cookie值
# 删除Cookie
1.使用setCookie()函数删除
setcookie('name', '', time() - 1);
2.手动删除Cookie
# Cookie的生命周期
不设定时间，就表示生命周期是浏览器会话的期间，关闭就消失，称为会话Cookie，一般不保存在硬盘上，而是在内存中
设置了过期时间就会保存在硬盘中直到超时
浏览器存储的cookie有上线，最大容量有限制，每个域名的cookie有最大数量限制，达到后会自动删除.
## Session管理
# 了解Session
1.什么是Session
会话，本义是指有始有终的一系列动作/消息。
计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统所经过的时间。
2.Session工作原理
启动一个Session会话时，会生成一个随机且唯一的session_id,也就是session的文件名，此时session_id存储在服务器的内存中，关闭页面时id自动注销。重新登录页面会再次生成一个随机且唯一的id
3.Session的功能
Web技术中非常重要，由于网页是一种无状态的连接程序，因此无法得知用户的浏览状态。通过Session则可记录用户的有关信息，以供用户再次以此身份对Web服务器提交要求时确认身份。
Session适用于存储信息量较少的情况。
# 创建会话
1.启动会话
session_start() 会话变量被登录到$_SESSION中
bool session_start()
使用session_start()前不能有任何输出
使用session_register()函数 不需要调用session_start()函数 会在注册变量后隐含地调用session_start()
2.注册会话
session_start();
$_SESSION['admin'] = null;
3.使用会话
if (!empty($_SESSION['session_name'])) {
	$myparam = $_SESSION['session_name'];
}
4.删除会话
1)删除单个会话
unset($_SESSION['session_name']);
2)删除多个会话
$_SESSION = array();
3)结束会话
session_destory();
# Session设置时间
1.客户端没有禁止Cookie
1)
session_set_cookie_params($time);
必须在session_start()之前调用
2)
session_start()
setcookie(session_name(), session_id(), time() + $time, '/');
2.客户端禁止Cookie
1)登录之前提醒用户打开Cookie
2)设置php.ini中 session.use_trans_sid=1 或者编译时打开 -enable-trans-sid选项 让PHP自动跨页面传递session_id
3)通过GET方法，隐藏表单传递session_id
4)使用文件或者数据库存储session_id,在页面传递中手动调用
Session原理为请求页面之后产生一个session_id，如果禁止Cookie就无法传递session_id，就会重新产生一个session_id，造成session传递失效
# 通过Session判断用户的操作权限


## Session高级应用
# Session临时文件
服务器中，如果所有用户的Session都保存到临时目录中，会降低服务器的安全性和效率，打开服务器存储的站点非常慢
使用session_save_path()存储Session临时文件
session_save_path()应该在session_start()之前调用
# Session缓存
将网页中的内容临时存储到IE客户端的Temporaty Internet Files文件夹下，并且设置缓存时间。
string session_cache_limiter([string cache_limiter])
cache_limiter 为private或public
int session_cache_expire([int new_cache_expire])
设置缓存时间 单位是分钟
以上两个函数需要在session_start()前调用
# Session数据库存储
bool session_set_save_handler(string open, string close, string read, string write, string destroy, string gc)
open(save_path, session_name) 	找到存储地址，取出变量名名称
close()							关闭数据库
read(key)						读取session键值 key对应session_id
write(key, data)				data对应设置的session变量
destroy(key)					注销session对应的Session键值
gc(expire_tiem)					清除过期Session记录
function _session_open($save_path, $session_name) {
	global $handle;
	$handle = mysql_connect('localhost', 'root', ''root') or die('数据库连接失败');
	mysql_select_db('db_database', $handle) or die('没有此库名');
	return (true);
}
function _session_close() {
	global $handle;
	mysql_close($handle);
	return (true);
}
function _session_read($key) {
	global $handle;
	$time = time();
	$sql = "select session_data from tb_session where session_key = '$key' and session_time > $time";
	$result = mysql_query($sql, $handle);
	$row = mysql_fetch_array($result);
	if ($row) {
		return ($row['session_data']);
	} else {
		return (false);
	}
}
function _session_write($key, $data) {
	global $handle;
	$time = 60 * 60;
	$lapse_time = time() + $time;
	$handle = mysql_connect('localhost', 'root', 'root') or die ('数据库连接失败');
	mysql_select_db('db_database', $handle) or die('没有此库');
	$sql = "select session_data from tb_session where session_key = '$key' and session_time > $lapse_time";
	$result = mysql_query($sql, $handle);
	if(mysql_num_rows($result) == 0) {
		$sql = "insert into tb_session values ('$key', '$data', $lapse_time)";
		$result = mysql_query($sql, $handle);
	} else {
		$sql = 'update tb_session set session_key = '$key', session_data = '$data', session_time = $lapse_time where session_key = '$key'";
		$result = mysql_query($sql, $handle);
	}
	return ($result);
}
function _session_destroy($key) {
	global $handle;
	$sql = "delete from tb_session where session_name = '$key'";
	$result = mysql_query($sql, $handle);
	return ($result);
}
function _session_gc() {
	global $handle;
	$lapse_time = time();
	$sql = "delete from tb_session where session_tiem < $lapse_time";
	$result = mysql_query($sql, $handle);
	return ($result);
}

### 图形图像处理技术

### 文件系统
## 文件处理
包括读取、关闭、重写等。
# 打开/关闭文件
打开/关闭文件使用fopen()和fclose()函数，小心防止错误操作。
1.打开文件
resource fopen(string filename, string mode[, bool use_include_path]);
filename是要打开的包含路径的文件名，可以是相对路径或绝对路径，如果没有前缀表示打开的是本地文件。mode是打开文件的方式。use_include_path在php.ini中指定的参数，希望PHP在此路径下打开文件。
mode 可取值
r		只读		读模式 进行读取 文件指针位于文件开头
r+		只读		读写模式 文件指针位于文件的开头 在现有文件内容的末尾之前进行写操作将会覆盖原有内容
w		只写		写模式 文件指针指向文件开头 如果文件存在则所有文件内容删除 否则将会创建一个新的文件
w+		只写		读写模式 文件指针指向文件卡头 如果文件存在则所有文件内容删除 否则将会创建新的文件
x		谨慎写		写模式 文件指针指向文件开头 如果文件已存在则不会打开文件 并返回false产生警告
x+		谨慎写		读写模式 文件指针指向文件开头 如果文件已存在则不会打开文件 并返回false产生警告
a		追加		追加模式 文件指针指向文件尾部，已有内容则追加到文件尾部 没有则创建新文件
a+		追加 		读写模式 文件指针指向文件开头 已有内容则追加到文件尾部 没有则创建新文件
b		二进制
t		文本
2.关闭文件
bool fclose(resource handle)
# 读写文件
1.读取数据
可以一次读取一个字符，一行字符或整个文件，还可以读取任意长度的字符串
（1）读取整个文件 readfile file file_get_contents
1)readfile()
用于读取一个文件并将其写入到输出缓冲中，如果出现错误则返回false
int readfile(string filename)
使用readfile不需要fopen/fclose，不需要echo/print等输出语句，直接写出文件路径即可
2)file()
可以用于读取整个文件内容，只是将文件内容按行存放到数组中，包括换行符在内，如果失败则返回false
array file(string filename)
3)file_get_contents()
将文件内容读入一个字符串，如果有offset和maxlen则从指定位置读取指定长度的字符串，如果失败返回false
string file_get_contents(string filename[, int offset[, int maxlen]])
此方法适用于二进制对象，是将整个文件内容读入一个字符串中的首选方式
（2）读取一行数据 fgets() fgetss()
1)fgets()
string fgets(int handle[, int length])
handle是打开的文件，函数能够实现从handle指定文件中读取一行数据并返回长度最大值为length-1个字节的字符串。在遇到换行符、EOF或者读取了length-1个字节之后停止。如果没有length参数，则读取到行结束
2)fgetss()
是fgets()函数的变体，用于读取一行数据，同时会过滤掉内容中的HTML和PHP标记
string fgetss(reource handle[, int length[, string allowable_tags]])
过滤掉任何HTML和PHP标记，allowable_tags用于控制哪些标记不被过滤
（3）读一个字符 fgetc()
string fgetc(resource handle)
（4）读取任意长度的字符串 fread()
fread()可以从文件中读取任意长度的字符串 
string fread(int handle, int length)
length是要获取的字符串
2、写入数据
fwrites() fputs() file_put_contents()向文件写入数据
int fwrite(resource handle, string string[, int length])
把内容sring写入文件，如果指定了length则在写入指定字节后停止。
int file_put_contents(string filename, string data[, int flags]);
flags可取值 FILE_USE_INCLUDE_PAth FILE_APPEND LOCK_EX LICK_EX为独占锁定s
file_put_contents和依次调用fopen() fwrites() fclose()功能一样
# 操作文件
对文件本身进行操作 如复制、重命名、查看修改日期等
bool copy(string path1, string path2)			将文件从path1复制到path2 如果成功返回true 如果失败返回false
bool rename(string filename, string filename2) 	把filename1重命名为filename2
bool unlink(string filename) 					删除文件 成功返回true 失败返回false
int fileatime(string filename) 					返回文件最后一次被访问的时间，时间以UNIX时间戳的方式返回
int filemtime(string filename)					返回文件最后一次被修改的时间，时间以UNIX时间戳的方式返回
int filesize(string filename)					返回文件filename的大小(bytes)
array pathinfo(string name[, int options])		返回一个数组，包含文件name的路径信息，有datetime，basename和extension，可以通过options指定返回的信息有PATHINFO_DIRNAME,PATHINFO_BASENAME,PATHINFO_EXTENSION,默认全部返回
string realpath(string filename) 				获取文件的绝对路径
array stat(string filename)						获取一个数组，包含文件的相关详细信息
## 目录处理
目录是一种特殊的文件，要浏览目录下的文件，首先要打开目录，浏览完毕后，同样要关闭目录。目录处理包含打开目录、浏览目录和关闭目录
# 打开/关闭目录
1.打开目录
resource opendir(string dirpath)
合法的目录路径，成功执行之后返回目录的指针。如果不是合法的目录或者因为权限或文件系统错误而不能打开目录，则返回一个false并产生一个E_WARNING级别的错误信息，可以在opendir()前加上@符号来抑制错误信息的输出
2.关闭目录
void closedir(resource handle)
# 浏览目录
array scandir(string directory[, int sorting_order])
返回一个数组，包含directory中的所有文件和目录，参数sorting_order指定排序顺序，默认按照字母升序排序。如果添加了该参数，则变为降序排序。
# 操作目录
目录是特殊的文件，因此对文件的操作多数同样适用于目录
bool mkdir(string pathname) 				新建一个指定的目录
bool rmdir(string dirname)					删除指定的目录，该目录必须为空的
string getcwd(coid)							获取当前工作的目录
bool chdir(string directory)				改变当前目录为directroy
float disk_free_space(string directory)		返回目录中可用空间（bytes），检查的文件必须通过服务器的文件系统访问
float disk_total_space(string directory)	返回目录的总空间大小(bytes)
string readdir(resource handle)				返回目录中下一个文件的文件名（必须使用opendir()打开）
void rewinddir(resource handle)				将指定的目录重新指定到目录的开头
## 文件处理的高级应用
# 远程文件的访问
支持URL格式的文件调用，需要在php.ini中配置一下，allow_url_fopen: ON
# 文件指针
1.rewind()函数
将文件指针指向文件流的开拓
bool rewind(resource handle)
如果以a的mode打开文件则无论指针在哪都在文件尾部追加内容
2.fseek()函数
实现文件指针的定位
int fseek(resource handle, int offset[, int whence])
handle 打开的文件
offset 为指针位置或相对whence的偏移量 可以是负值
whence 包括3种 SEEK_SET 位置等于offset字节 SEEK_CUR	位置等于当前位置加上offset字节 SEEK_END 位置等于文件尾部加上offset字节 如果忽略whence 系统默认为SEEK_SEt
3.feof()函数
该函数判断文件指针是否在文件尾
bool feof(resource handle)
如果文件指针到达文件结束的位置，返回true，否则返回false
4.ftell()函数
返回当前指针的位置
# 锁定文件
向一个文本文件写入内容时，需要先锁定该文件，以防止其他用户同时修改此文件内容。使用flock()函数
bool flock(resource handle, int operation)
handle是一个已打开的文件，operation可选值为
LOCK_SH		取得共享锁定 （读取程序）
LOCK_EX		取得读取锁定 （写入程序）
LOCK_UN		释放锁定	
LOCK_NB		防止flock()在锁定时阻塞
## 文件上传
需要修改$_FILES中的配置，并了解$_FILES[]全局变量 最后使用move_uploaded_file()实现上传
# 配置php.ini文件
file_uploads		如果值时ON则说服务器支持文件上传 OFF则不支持
upload_tmp_dir		上传文件临时目录，成功上传之前，文件首先存放在服务器端的临时目录中，如果想要指定位置可以设置，否则使用系统默认目录即可
upload_max_filesize	服务器允许上传的文件的最大值，以MB为单位，默认2MB，可自行设置
还有一些属性可能影响文件上传
max_execution_time 	PHP中一个指令所能执行的最大时间，单位是秒
memory_limit		PHP中一个指令所分配的内存空间，单位是MB
# 预定义变量$_FILES
$_FILES变量存储的是上传文件的相关信息，这些信息对于上传功能有很大的作用。该变量是一个二维数组。
$_FILE[filename][name]				上传文件的文件名
$_FILE[filename][size]				存储了文件大小 单位为字节
$_FILE[filename][tmp_name]			文件上传时，首先在临时目录中被保存成一个临时文件，该变量为临时文件名
$_FILE[filename][type]				上传文件的类型
$_FILE[filename][error]				存储了上传文件的结果如果返回0说明文件上传成功
# 文件上传函数
bool move_uploaded_file(string filename, string destination) 
将上传文件存储到指定的位置，如果成功返回true 如果失败返回false filename是上传文件的临时文件名
使用move_uploaded_file()函数上传文件时，需要设置enctype="multipart/form-data"属性
# 多文件上传
将name设置为xxx[] 则在$_FILES[xxx][name/tmp_name/error/...] 都变为数组

### 面向对象
## 面向对象的基本概念
# 类
# 对象
# 面向对象编程的三大特点
继承
封装
多态
## PHP与对象
# 类的定义
class MyObject {

}
# 成员方法
类中的函数称为成员方法，函数和成员方法唯一的区别即使，函数实现的是某个独立的功能，而成员方法是实现类中的一个行为，是类的一部分。
class MyObject {
	function func($param1, $param2) {
		echo $param1;
	}
}
# 类的实例化
使用类的方法需要先实例化类，通过new关键字来声明一个对象。再使用以下格式调用成员方法
对象 -> 成员方法
# 成员变量
类中的变量也称为成员变量（也有称为属性或字段的）。成员变量用来保存信息数据，或与成员方法进行交互来实现某项功能。
public/private/protected/static/final 成员变量
调用的方式和成员方法一样
对象 -> 成员变量 （此处的变量是没有$前缀的)
$this -> 成员变量 调用本实例的成员变量
# 类常量
const PI = 3.1415927;
使用
类名::类常量
# 构造方法和析构方法
1.构造方法
当一个类实例化一个对象时，可能需要随着对象初始化一些成员变量。
构造方法就是生成对象时自动执行的成员方法，作用就是初始化对象，可以没有参数，也可以有多个参数。
格式
void __construct([mixed args[,...]])
没有显式声明构造函数，PHP会自动生成一个没有参数的构造函数，并且内部没有任何操作。
2.析构方法
在对象被销毁时调用，作用是释放内存。
void __destruct(void)
PHP使用垃圾回收机制，自动清除不再使用的对象，释放内存。即使不调用unset()方法，析构方法也会自动调用。
# 继承和多态的实现
1.继承
子类继承父类所有的成员变量和方法，包括构造函数，当子类创建时，PHP会先在子类中查找构造方法，如果子类有自己的构造方法，PHP会先调用子类的构造方法，没有则调用父类的构造方法。
class SubClass extends SuperClass {

}
2.多态
存在两种形式 重写和重载
1)重写就是子类中重写父类的方法，不同子类调用同名的方法得到的结果是不同的
2)重载就是通过参数数量或类型来将同名的函数区分开，调用不产生混淆,好处是可实现代码重用
# $this->和::的使用
PHP通过伪变量$this->和作用域操作符::来实现
1.$this->
在定义类是，想要调用类中的方法或变量，用伪变量$this-> $this的意思就是本身 所以只能在类的内部使用
get_class()函数返回对象所属类的名字，如果不是对象则返回false
2.操作符::
可以在没有声明任何实例的情况下访问类中的成员方法或成员变量
关键字::变量名/常量名/方法名
关键字分为
parent::  可以调用父类中的成员变量、成员方法和常量
self::	  可以调用当前类中的静态成员和常量
类名::		可以调用本类中的变量、常量和方法
# 数据隐藏
1.public （默认的 没有显式声明就是public的）
公开，没有隐藏的数据信息。可以在程序的任何位置被其他的类和对象调用。子类可以继承和使用父类中的所有公共成员。
2.private
只能在所属类的内部被调用和修改，不可以在类外被访问。在子类中也不可以
3.protected
对本类和子类可见，在类外不可见。
# 静态变量/方法
不是所有的变量方法都要通过创建对象来调用，可以通过给变量方法加上static关键字来直接调用，调用静态成员的格式为
关键字::静态成员
关键字
self::	类内部调用静态成员时使用
类名::	在类外调用类内部的静态成员使用
静态方法中，只能调用静态变量，不能调用普通变量，普通方法中可以调用静态变量
还有一个好处就是对象销毁之后，静态成员依然存在，可以下次继续使用
## 面向对象高级应用
# final关键字
final class class_name {

}
表示这个类不能被继承 也不能有子类
如果有一个方法被final修饰
final function func_name()
表示这个方法不能被子类重写 也不能被覆盖
# 抽象类
abstract class AbstractClass {

}
抽象类是一个不能被实例化的类，只能作为其他类的父类来使用，抽象类使用abstract关键字来声明
抽象类和普通类相似，包含成员变量，成员方法，区别在于抽象类至少包含一个抽象方法，抽象方法没有方法体，其功能的实现只能在子类中完成。抽象方法也是使用abstract关键字声明的
abstract function func_name(); // 分号不能少
# 接口的使用
interface inter_name {

}
PHP只支持单继承，想要实现多重继承需要使用接口
不能用public以外的关键字来修饰接口中的类成员，对于方法，不写关键字也可以。
子类通过implements关键字来实现接口，如果需要实现多个接口，需要使用逗号分隔，并且所有未实现的方法需要在实现类中实现。
# 克隆对象
1.关键字clone
PHP4之前对象赋值是复制一个备份，PHP5之后则是传递引用。如果想要得到一个备份 可以使用clone关键字来实现
2.__clone方法
除了单纯的克隆对象外，还需要克隆出的对象可以拥有自己的属性和行为。需要使用__clone方法来实现。作用是在克隆过程中，调用__clone方法。
# 对象比较
== 比较对象内容
=== 比较对象地址
# 对象类型检测
ObjectName instanceof ClassName
# 魔术方法
以 __ 开头的方法
__construct
__destruct
__clone
1.__set和__get方法
当程序视图写入一个不存在或不可见的成员变量时，PHP就会执行__set方法，__set方法包含两个参数，分表表示变量名称和变量值，参数不可省略。
当程序试图调用一个未定义或不可见的成员变量时，可以通过__get方法来获取变量，有一个参数，表示要调用的变量名
2.__call方法
当程序试图调用不存在或不可见的成员方法时，会先调用__call来存储方法名及其参数，包含两个参数，方法名和参数数组
3.__sleep和__wakeup方法
使用serialize()函数可以实现序列化对象，将对象中的变量全部保存下来。如果包含__sleep()方法则先执行__sleep 目的是关闭对象可能具有的数据库连接等类似的善后工作 return array("field_name") 只有在这个数组中的成员变量会被序列化
unserialize()函数反序列化对象，__wakeup方法则是在恢复可能丢失的工作












