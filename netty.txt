******************************* Netty ********************************
------------------------- Netty实战 -------------------------

### Netty的概念及体系结构
## Netty——异步和事件驱动
# Java网络编程
1.Java NIO
2.选择器
java.nio.channels.Selector是Java的非阻塞I/O实现的关键。使用事件通知API已确定一组非阻塞套接字中有哪些已经就绪可以进行I/O相关操作。因为可以在任何时间检查任意的读操作或者写操作的完成状态。
总体而言，与阻塞I/O模型相比，这种模型提供了更好的资源管理。
1)使用较少的线程便可以处理许多连接，因此也减少了内存管理和上下文切换带来的开销
2)当没有I/O操作需要处理的时候，线程也可以被用于其他任务
# Netty简介
设计 			统一的 API，支持多种传输类型，阻塞的和非阻塞的
				简单而强大的线程模型
				真正的无连接数据报套接字支持
				链接逻辑组件以支持复用
				易于使用 详实的Javadoc和大量的示例集
				不需要超过JDK 1.6+③的依赖。（一些可选的特性可能需要Java 1.7+和/或额外的依赖）
性能 			拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟
				得益于池化和复用， 拥有更低的资源消耗
				最少的内存复制
健壮性 			不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError
				消除在高速网络中 NIO 应用程序常见的不公平读/写比率
安全性 			完整的 SSL/TLS 以及 StartTLS 支持
				可用于受限环境下，如 Applet 和 OSGI
社区驱动 		发布快速而且频繁
1.使用方
2.异步和事件驱动
异步和可伸缩性之间的联系
1)非阻塞网络调用使得可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，并且更进一步：异步方法会立即返回，并且在完成时，会直接或在之后的某个时间点通知用户
2)选择器使得能够通过较少的线程便可监视许多连接上的事件
3.Netty的核心组件
1)Channel
2)回调
3)Future
4)事件和ChannelHandler
A.Channel
Channel是Java NIO的一个基本构造
代表一个到实体（如邮件设备、文件、网络套接字或者执行I/O操作的程序组）的开放连接，如读操作和写操作
暂时可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，连接或者断开连接
B.回调
一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。使得后者可以在适当的时候调用前者。
Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interfaceChannelHandler的实现处理。
C.Future
Future提供了另一种在操作完成时通知应用程序的方法。这个对象可以看作是一个异步操作的结果的占位符，在未来的某个时刻完成，并提供对其结果的访问。
JDK预置了接口Future，但是默认提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞知道完成。因此Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用
ChannelFuture提供了几种额外的方法，能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应操作完成时被调用。然后监听器可以判断操作成功还是失败。出错则可以检索产生的Throwable。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。
每个Netty的出站I/O操作都将返回一个ChannelFuture，也就是说不会阻塞。
对错误的处理完全取决于开发者
可以在ChannelFutureListener看做是回调的一个更加精细的版本，回调和Future是相互补充的机制，相互结合构成Netty本身的关键构建快之一
4.事件和ChannelHandler
Netty使用不同的事件来通知状态或者操作的状态。动作可能是
1)记录日志
2)数据转换
3)流控制
4)应用程序逻辑
Netty是一个网络编程框架，所以事件是按照入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而出发的事件包括
1)连接已被激活或者连接失活
2)数据读取
3)用户事件
4)错误事件
出站事件是未来将会触发的某个动作的操作结果
1)打开或者关闭到远程节点的连接
2)将数据写到或者冲刷到套接字
每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法。
Netty的ChannelHandler为处理器提供了基本的抽象，暂时可以认为ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。
Netty提供了大量预定义的可以开箱即用的ChannelHandler实现，包括用于各种协议（如HTTP和SSL/TLS）的ChannelHandler。内部，ChannelHandler自己也使用了事件和Future，使得他们也成为了应用程序将使用的相同抽象的消费者。
5.将组建组合使用
1)Future、回调和ChannelHandler
Netty的异步编程模型是建立在Future和回调的概念之上的，而将事件派发到ChannelHandler的方法则发生在更深的层次上。
拦截操作以及高速地转换入站数据和出站数据，都只需要提供回调或者利用操作锁返回的Future。这使得链接操作变得既简单又高效，并且促进了可重用的通用代码的编写。
2)选择器、事件和EventLoop
Netty通过触发事件将Selector从应用程序中抽象出来，消除了所有本来将需要手动编写的派发代码。内部，为每个Channel分配一个EventLoop，用于处理所有时间，包括
a)注册感兴趣的事件
b)将事件派发给ChannelHandler
c)安排进一步的动作
EventLoop本身只由一个线程驱动，其处理一个Channel的所有I/O时间，并在该EventLoop的整个生命周期内都不会改变。

### 第一款Netty应用程序
## 设置开发环境
# 安装Java开发工具包
# 安装IDE
# 安装Apache Maven
# 配置工具集
## Netty客户端/服务器概览
## 编写Echo服务器
所有Netty服务器都需要一下两部分
1.至少一个ChannelHandler——该组件实现了服务器对从客户端接受的出局的处理
2.引导，配置服务器的启动代码，至少将服务器绑定到要监听连接请求的端口上
# ChannelHandler和业务逻辑
ChannelHandler是一个接口族的父接口，实现负责接受并响应时间通知。在Netty应用程序中，所有的数据处理都包含在这些核心抽象的实现中。
响应传入的消息，需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法。简单程序只需要少量方法，继承InboundHanlderAdapter,提供了ChannelInboundHandler的默认实现
此应用感兴趣的方法
1)channelRead()——对于每个传入的消息都要调用
2)channelReadComplate()——通知ChannelInboundHandler最后一次对channelRead()的调用时当前批量读取中的最后一条消息
3)在读取操作期间，有异常抛出时会调用
public class EchoServerHandler extends ChannelInboundHandlerAdapter {
	public void channelRead(ChannelHandlerContext ctx, Object msg) {
		ByteBuf in = (ByteBuf) msg;
		System.out.println("Server receive: " + msg.toString(CharsetUtil.UTF_8));
		ctx.write(msg);
	}
	
	public void channelReadComplete(ChannelHandlerContext ctx) {
		ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelHandlerListener.CLOSE);
	}
}
除了ChannelInboundHandlerAdapter，还有很多ChannelHandler的子类型和实现需要学习，暂时需要记住
1)针对不同类型的事件来调用ChannelHandler
2)应用程序通过实现或者扩展ChannelHandler来挂钩到事件的声明周期中，并且提供自定义的应用程序逻辑
3)在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的分离。简化了开发过程。
# 引导服务器
1)绑定到服务器将在其上监听并接受传入连接请求的端口
2)配置Channel，以将有关的入站消息通知给EchoServerHandler实例
public void start() {
	final EchoServerHandler = new EchoServerHandler();
	NioEventLoopGroup group = new NioEventLoopGroup();
	try {
		ServerBootstrap b = new ServerBootstrap();
		b.group(group)
			.channel(NioServerSocketChannel.class)
			.localAddress(new InetSocketAddress(port))
			.childHandler(new ChannelInitializer<SocketChannel>() {
				public void initChannel(SocketChannel ch) {
					ch.pipeline().addLast(serverHandler);
				}
			});
		ChannelFuture f = b.bind().sync();
		f.channel().closeFuture().sync();
	} catch (Exception e) {
	
	} finally {
		group.shutdownGracefully().sync();
	}
}
























