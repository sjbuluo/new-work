******************************* Netty ********************************
------------------------- Netty实战 -------------------------

### Netty的概念及体系结构
## Netty——异步和事件驱动
# Java网络编程
1.Java NIO
2.选择器
java.nio.channels.Selector是Java的非阻塞I/O实现的关键。使用事件通知API已确定一组非阻塞套接字中有哪些已经就绪可以进行I/O相关操作。因为可以在任何时间检查任意的读操作或者写操作的完成状态。
总体而言，与阻塞I/O模型相比，这种模型提供了更好的资源管理。
1)使用较少的线程便可以处理许多连接，因此也减少了内存管理和上下文切换带来的开销
2)当没有I/O操作需要处理的时候，线程也可以被用于其他任务
# Netty简介
设计 			统一的 API，支持多种传输类型，阻塞的和非阻塞的
				简单而强大的线程模型
				真正的无连接数据报套接字支持
				链接逻辑组件以支持复用
				易于使用 详实的Javadoc和大量的示例集
				不需要超过JDK 1.6+③的依赖。（一些可选的特性可能需要Java 1.7+和/或额外的依赖）
性能 			拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟
				得益于池化和复用， 拥有更低的资源消耗
				最少的内存复制
健壮性 			不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError
				消除在高速网络中 NIO 应用程序常见的不公平读/写比率
安全性 			完整的 SSL/TLS 以及 StartTLS 支持
				可用于受限环境下，如 Applet 和 OSGI
社区驱动 		发布快速而且频繁
1.使用方
2.异步和事件驱动
异步和可伸缩性之间的联系
1)非阻塞网络调用使得可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，并且更进一步：异步方法会立即返回，并且在完成时，会直接或在之后的某个时间点通知用户
2)选择器使得能够通过较少的线程便可监视许多连接上的事件
3.Netty的核心组件
1)Channel
2)回调
3)Future
4)事件和ChannelHandler
A.Channel
Channel是Java NIO的一个基本构造
代表一个到实体（如邮件设备、文件、网络套接字或者执行I/O操作的程序组）的开放连接，如读操作和写操作
暂时可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，连接或者断开连接
B.回调
一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。使得后者可以在适当的时候调用前者。
Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interfaceChannelHandler的实现处理。
C.Future
Future提供了另一种在操作完成时通知应用程序的方法。这个对象可以看作是一个异步操作的结果的占位符，在未来的某个时刻完成，并提供对其结果的访问。
JDK预置了接口Future，但是默认提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞知道完成。因此Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用
ChannelFuture提供了几种额外的方法，能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应操作完成时被调用。然后监听器可以判断操作成功还是失败。出错则可以检索产生的Throwable。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。
每个Netty的出站I/O操作都将返回一个ChannelFuture，也就是说不会阻塞。
对错误的处理完全取决于开发者
可以在ChannelFutureListener看做是回调的一个更加精细的版本，回调和Future是相互补充的机制，相互结合构成Netty本身的关键构建快之一
4.事件和ChannelHandler
Netty使用不同的事件来通知状态或者操作的状态。动作可能是
1)记录日志
2)数据转换
3)流控制
4)应用程序逻辑
Netty是一个网络编程框架，所以事件是按照入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而出发的事件包括
1)连接已被激活或者连接失活
2)数据读取
3)用户事件
4)错误事件
出站事件是未来将会触发的某个动作的操作结果
1)打开或者关闭到远程节点的连接
2)将数据写到或者冲刷到套接字
每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法。
Netty的ChannelHandler为处理器提供了基本的抽象，暂时可以认为ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。
Netty提供了大量预定义的可以开箱即用的ChannelHandler实现，包括用于各种协议（如HTTP和SSL/TLS）的ChannelHandler。内部，ChannelHandler自己也使用了事件和Future，使得他们也成为了应用程序将使用的相同抽象的消费者。
5.将组建组合使用
1)Future、回调和ChannelHandler
Netty的异步编程模型是建立在Future和回调的概念之上的，而将事件派发到ChannelHandler的方法则发生在更深的层次上。
拦截操作以及高速地转换入站数据和出站数据，都只需要提供回调或者利用操作锁返回的Future。这使得链接操作变得既简单又高效，并且促进了可重用的通用代码的编写。
2)选择器、事件和EventLoop
Netty通过触发事件将Selector从应用程序中抽象出来，消除了所有本来将需要手动编写的派发代码。内部，为每个Channel分配一个EventLoop，用于处理所有时间，包括
a)注册感兴趣的事件
b)将事件派发给ChannelHandler
c)安排进一步的动作
EventLoop本身只由一个线程驱动，其处理一个Channel的所有I/O时间，并在该EventLoop的整个生命周期内都不会改变。

### 第一款Netty应用程序
## 设置开发环境
# 安装Java开发工具包
# 安装IDE
# 安装Apache Maven
# 配置工具集
## Netty客户端/服务器概览
## 编写Echo服务器
所有Netty服务器都需要一下两部分
1.至少一个ChannelHandler——该组件实现了服务器对从客户端接受的出局的处理
2.引导，配置服务器的启动代码，至少将服务器绑定到要监听连接请求的端口上
# ChannelHandler和业务逻辑
ChannelHandler是一个接口族的父接口，实现负责接受并响应时间通知。在Netty应用程序中，所有的数据处理都包含在这些核心抽象的实现中。
响应传入的消息，需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法。简单程序只需要少量方法，继承InboundHanlderAdapter,提供了ChannelInboundHandler的默认实现
此应用感兴趣的方法
1)channelRead()——对于每个传入的消息都要调用
2)channelReadComplate()——通知ChannelInboundHandler最后一次对channelRead()的调用时当前批量读取中的最后一条消息
3)在读取操作期间，有异常抛出时会调用
public class EchoServerHandler extends ChannelInboundHandlerAdapter {
	public void channelRead(ChannelHandlerContext ctx, Object msg) {
		ByteBuf in = (ByteBuf) msg;
		System.out.println("Server receive: " + msg.toString(CharsetUtil.UTF_8));
		ctx.write(msg);
	}
	
	public void channelReadComplete(ChannelHandlerContext ctx) {
		ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelHandlerListener.CLOSE);
	}
}
除了ChannelInboundHandlerAdapter，还有很多ChannelHandler的子类型和实现需要学习，暂时需要记住
1)针对不同类型的事件来调用ChannelHandler
2)应用程序通过实现或者扩展ChannelHandler来挂钩到事件的声明周期中，并且提供自定义的应用程序逻辑
3)在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的分离。简化了开发过程。
# 引导服务器
1)绑定到服务器将在其上监听并接受传入连接请求的端口
2)配置Channel，以将有关的入站消息通知给EchoServerHandler实例
public void start() {
	final EchoServerHandler = new EchoServerHandler();
	NioEventLoopGroup group = new NioEventLoopGroup();
	try {
		ServerBootstrap b = new ServerBootstrap();
		b.group(group)
			.channel(NioServerSocketChannel.class)
			.localAddress(new InetSocketAddress(port))
			.childHandler(new ChannelInitializer<SocketChannel>() {
				public void initChannel(SocketChannel ch) {
					ch.pipeline().addLast(serverHandler);
				}
			});
		ChannelFuture f = b.bind().sync();
		f.channel().closeFuture().sync();
	} catch (Exception e) {
	
	} finally {
		group.shutdownGracefully().sync();
	}
}
## 编写Echo客户端
Echo客户端
1.连接到服务器
2.发送一个或者多个消息
3.对于每个消息，等待并接受从服务器发回的相同的消息
4.关闭连接
# 通过ChannelHandler实现客户端逻辑
和服务器一样，客户端拥有一个用来处理数据的ChannelInboundHandler，此应用将扩展SimpleChannelInboundHandler类以处理所有必须的任务。
重写一下方法
1)channelActive	在到服务器的连接已建立之后将被调用
2)channelRead0() 当从服务器接收到一条消息时被调用
3)exceptionCaugt()	在处理过程中引发异常时使用
channelRead0方法，每当接收数据时，都会调用这个方法。由服务器发送地消息可能被分块接收，也就是说如果服务器发送5字节，并不保证5字节一次性接收。即使少量数据也能会被调用两次。TCP保证按照顺序接受。

### Netty的组件和设计
## Channel、EventLoop和ChannelFuture
这些类合起来，可以被认为是Netty网络抽象的代表
1.Channel——Socket
2.EventLoop——控制流、多线程处理、并发
3.ChannelFuture——异步通知
# Channel接口
基本的I/O操作（bind()、connect()、read()he write()）依赖于底层网络传输所提供的原语。在基于Java的网络编程中，其基本构造时Socket类。Netty的Channel接口所提供的API，大大降低了直接使用Socket类的复杂性。Channel也拥有许多预定义的、专门化实现的广泛类层次结构的根。
1.EmbeddedChannel
2.LocalServerChannel
3.NioDatagramChannel
4.NioSctpChannel
5.NioSocketChannel
# EventLoop接口
EventLoop定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事情。
Channel、EventLoop、EventLoopGroup的关系
1.一个EventLoopGroup包含一个或者多个EventLoop
2.一个EventLoop在生命周期中只和一个Thread绑定
3.所有由EventLoop处理的I/O事件都将在专有的Thread上被处理
4.一个Channel在声明周期中只注册一个EventLoop
5.一个EventLoop可能会被分配给一个或多个Channel
注意，设计一个给定Channel的I/O操作都是由相同的Thread执行，实际上消除了对同步的需要。
# ChannelFuture接口
Netty中所有的I/O操作都是异步的。因此一个操作可能不会立即返回。为此，Netty提供了ChannelFuture接口，addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。
## ChannelHandler和ChannelPipeline
# ChannelHandler接口
从开发人员角度来看，Netty的主要组件是ChannelHandler。ChannelHandler充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandker的方法是由网络事件触发的。实际上，ChannelHandler可用于几乎任何类型的动作
# ChannelPipeline接口
提供了ChannelHandler链的容器，并定义了用于在该链接上传播入站和出站事件流的API。当Channel被创建时，会被自动分配到专属的ChannelPipeline。
ChannelHandler安装到ChannelPipeline中的过程
1.一个ChannelInitializer的实现被注册到BootStrap中
2.当ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler
3.ChannelInitializer将自己从ChannelPipeline中移除
ChannelHandler是专为支持广泛的用途而设计的。可将之作为处理往来ChannelPipeline事件（包括数据）的任何代码的通用容器。
使得事件流经ChannelPipeline是ChannelHandler的工作，在应用程序初始化或者引导阶段被安装。这些对象接收事件、执行实现的处理逻辑，并将数据传递给下一个ChannelHanlder。执行顺序按照添加顺序决定。实际上被称为编排顺序。
如果一个消息或者任何其他的入站事件被读取，那么会从ChannelPipeline的头部开始流动，并传递给第一个ChannelHandler的实例。ChannelHandler根据自己的处理逻辑执行，然后传递给下一个直到ChannelPipeline尾部，至此，处理全部结束。
数据的出栈运动在概念上也是一样的，但是从ChannelOutboundHandler链的尾部开始流动直到头部未知。之后，出站数据将会到达网络传输层，通常触发一个写操作。
通过使用坐船参数传递到每个方法的ChannelHandlerContext，事件可以被传递给当前ChannelHandler链中的下一个ChannelHandler，有时想忽略不敢兴趣的事件，提供了抽象基类ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter。通过调用ChannelHandlerContext上的对应方法，每个都提供了简单地将事件传递给下一个ChannelHanlder的方法的实现。
Netty能够区分ChannelInboundHandler和ChannelOutboundHandler，并确保数据只会在具有相同定向类型的两个ChannelHandler之间传递。
当ChannelHandler被添加到ChannelPipeline中，会被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定。虽然可以被用于获取底层的Channel，但主要用于写出站数据
Netty有两种发送消息的方式，可以直接写到Channel中，也可以写到ChannelHandler相关联的ChannelHandlerContext中。前一种方式将会导致消息从ChannelPipeline的尾端开始流动，而后者则导致消息从ChannelPipeline中的下一个ChannelHandler开始流动。
# 更加深入了解ChannelHandler
有许多不同类型的ChannelHandler，各自的功能主要取决于超类。Netty以适配器类的形式提供了大量默认的ChannelHandler实现，旨在简化处理逻辑的开发过程。ChannelPipeline中的每个ChannelHandler将负责把事件转发到链中的下一个ChannelHandler。这些适配器（及其子类）将自动执行这个操作，所以可以只重写想要特殊处理的方法和事件
经常使用的适配器
1.ChannelHandlerAdapte
2.ChannelInboundHandlerAdapter
3.ChanneloutboundHanlderAdapter
4.ChannelDuplexHandler
# 编码器和解码器
当通过Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：也就是说从字节转换为另一种格式，通常是一个Java对象。如果是出站消息，则会发生相反的转换，从当前格式转换为字节。原因很简单：网络数据总是一系列的字节
对应于特定的需要，Netty为编码器和解码器提供了不同类型的抽象类。
严格地说，其他处理器也可以完成编码器和解码器的功能。但是，正如有用来简化ChannelHandler的创建的适配器类一样，所有由Netty提供的编码器/解码器适配器类都实现了ChannelOutboundHandler或者ChannelInboundHandler接口。
对于入站数据而言，channelRead方法/事件已经被重写了。对于从入站Channel读取的消息，这个方法都将会被调用。随后，将调用由预置解码器所提供的decode()方法，并将已解码的字节转发给ChannelPipeline中下一个ChannelInboundHandler
出站消息的模式是相反方向的：编码器将消息转换为字节，并将之转发给下一个ChanneloutboundHandler
# 抽象类 SimpleChannelInboundHandler
最常见的情况，应用程序会利用一个ChannelHandler来接受解码消息，并对该数据应用业务逻辑。要创建这样一个ChannelHandler，只需要扩展基类SimpleChannelInboundHandler<T>，T是想要处理的消息的Java类型。这个ChannelHandler中，需要重写基类的一个或者多个方法，并且获取一个ChannelHandlerContext的引用。
这种类型的ChannelHandler中，最重要的方法是channelRead0(ChannelHandlerContext, T)，除了要求不要阻塞当前I/O线程之外，并没有限制
## 引导
Netty的引导类为应用程序的网络层配置提供了容器，涉及将一个进程绑定到某个指定端口，或者将一个进程连接到另一个运行在某个指定主机的指定端口上的进程。
通常而言，把前面的用例称作引导一个服务器，后面的用例称作引导一个客户端。服务器和客户端实际上表示不同的网络行为：换句话说，是监听传入的连接还是建立到一个或多个进程的连接
有两种类型的引导：一种用于客户端（简单地称为Bootstrap），而另一种（ServerBootstrap）用于服务器。
						Bootstrap				ServerBootstrap
网络编程中的作用		连接到远程主机和端口	绑定到本地端口
EventLoopGroup的数目	1						2（实际使用一个EventLoopGroup，在两种场景下公用同一个EventLoopGroup）
为什么Bootstrap只需要一组Group，而Server则需要两组
因为服务器需要两组不同的Channel，第一组只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接的Chanenl。
与ServerChannel相关联的EventLoopGroup将分配一个负责为传入连接请求创建Channel的EventLoop。一旦连接被接受，第二个EventLoopGroup就会给它的Channel分配一个EventLoop

### 传输
1.OIO 阻塞传输
2.NIO 异步传输
3.Local JVM内部的异步通信
## 案例研究：传输迁移
# 不通过Netty使用OIO和NIO
# 通过Netty使用OIO和NIO
## 传输API




















