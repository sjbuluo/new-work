************** Java网络编程 ****************

### 基本网络概念
# 网络
通常通过线缆连接，数据位转换为电磁波，通过线缆移动。无线网络会通过无线电波传输数据，长距离传输会通过玻璃纤维发送可见光传输数据
网络中的媚态机器称为一个节点（node），大多数节点是计算机，但是打印机、路由器、网桥、网关、哑终端和可口可乐机都是节点。具有完备功能的计算机节点称为主机（host）。
每个网络节点都有地址(address),用于唯一标识节点的一个字节序列，可以将这一字节序列视为数字，每个地址中的字节越多，可用的地址就越多，就能有更多的设备同时连入网络。
不同的网络会以不同的方式分配地址，以太网（Ethernet）地址与物理以太网硬件关联。
有些网络中，节点还有进行标识的名字，例如"www.google.com"，某一时刻一个特定的名字通常就指示一个地址，但是名字和地址并不锁定，名字可以改变，但是地址不变。类似的，地址可以改变而名字不变。一个地址可以有多个名字，名字也可以有多个地址。
所有现代计算机网络都是包交换（分组交换）网络，流经网络的数据分割成小块，称为包（packet，也称分组），每个包都单独加以处理。每个包都包含了由谁发送和将发往何处的信息。将数据分成单独的带有地址的包，最重要的优点是，多个即将交换的包可以在一条线缆上传输，这使得建立网络的成本更低，多个计算机可以互不干扰得共用同一条线缆。还有一个好处是，可以进行校验，用来检测包在传输中是否遭到破坏。
协议（protocol）是定义计算机如何通信的一组明确的规则：包括地址格式、数据如何分包等。针对网络通信的不同方面，定义有很多不同的协议。如：超文本传输协议（Hypertext Transfer Protocol， Http），定义了Web浏览器如何与服务通信，等等
# 网络的分层
通过网络发送数据时一项复杂的操作，必须仔细地协调网络的物理特性和所发送数据模拟信号，检测和修正错误。
网络通信的不同方面给分解为多个层，每一层表示为物理硬件（即线缆和电流）与所传输信息之间的不同抽象层次。理论上，每一层只与紧挨的上下两层对象。分层可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响其他层。
Internet标准的TCP/IP四层模型
应用层 < --------------------> 应用层     # 逻辑上是应用层相互交换数据 实际上则是通过了4层模型
    |                           |
传输层TCP/UDP                  传输层TCP/IP
    |                           |
网际层IP                       网际层IP
    |   ------->物理路径-------->|
        主机网络层(以太网、WIFI、LTE等）
主机网络层
基于IP的Internet的标准参考模型中，网络中隐藏的部分属于主机网络层（host-work layer），也称为链路层、数据链路层或网络接口层。
主机网络层中，由连接不同计算机的硬件（线缆、光纤电缆、无线电波或烟信号）组成的部分有时称为物理层，Java网络编程中无需考虑
网际层
需要考虑的第一层，OSI模型中，也称为网络层（network-layer）。网络层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制，不同计算机按照这个寻址机制查找对方。网际协议（IP）是世界上使用最广泛的网络层协议，也是Java唯一理解的网络层协议
IP分为两个协议IPv4和IPv6，IPv4使用32位地址、IPv6使用128位地址，另外增加了一些技术特性帮助完成路由。
IPv4和IPv6中，数据按包在网际层上传输，称为数据报（datagram），每个IPv4数据报包含一个长度为20到60字节的首部，以及一个包含多达65515字节数据的有效载荷（payload），实际上，大多数IPb4的数据报小很多，从几十字节到稍大于8k字节不等。IPv6包含一个更大的首部，数据可以多达4G
除了路由和寻址，网际层第二个作用是支持不同类型的主机网络层相互对话。
传输层
原始数据报有一些缺点，最显著的是不能保证可靠传送，即使能传送也可能在传输中遭到破坏，首部校验和只能校验首部中的破坏情况，而不能检测数据报中的数据部分。即使数据报能未糟破坏的到达目的地，也不一定是按照发送的顺序到达，各个数据报可能会经过不同路由从源到达目的地。
传输层（transport layer）负责确保各包以发送顺序接受，并保证没有数据丢失或破坏，如果丢包则要求发送方重传。IP网络会给每个数据报添加一个附加首部，其中包含更多信息。这一层上主要有两个协议，一个是传输控制协议（Transmission Control Protocol TCP)，这是一个开销很高的协议，支持对丢失或破坏的数据进行重传，并按照发送时的顺序进行传送。第二个是用户数据报协议（User Datagram Protocol UDP），允许接受放检测被破坏的包，但不保证这些包以正确的顺序传送（或者包有可能根本未传送），但是UDP通常比TCP块。
应用层
向用户传送数据的层称为应用层。应用层协议有很多。比如HTTP FTP SMTP POP等
IP、TCP和UDP
IP允许任意两点之间有多个路由器，开放、与平台无关的，可以将TCP置于IP之上，使得连接的两端可以确认收到IP包，以及请求重传丢失或被破坏的包。TCP允许接收端的包按照发送时的顺序重新组合到一起。
TCP开销很大，如果顺序不太重要，而且单个包丢失不会完全破坏数据流，就可以使用UDP发送数据包。
可以在IP协议上运行的还有很多其他协议，比如ICMP，主要用于PING。Java不支持ICMP，也不支持原始IP数据报。Java只支持TCP/UDP和建立在之上的应用层协议。
IP地址和域名
IPv4网络中的每台计算机都又一个四字节的数字标识，一般写为点分四段（dotted quad）格式，比如127.0.0.1.每段都是一个无符号字节，范围从0到255，IPv4网络中的每台计算机都又唯一的四字节地址，当数据通过网络传输时，包的首部会包括要发往的机器地址和发送包的及其地址。沿路的路由器通过检查目的地址来选择发送数据包的最佳路由。
IPv4的地址优先，现在已经所剩无几，逐渐向IPv6过度。IPv6分为8段，每段由:分隔，每段是4个16进制的数字组成。前导的0不用写，Java1.4版本之后才支持IPv6
域名系统用于将易于以及的主机名转换为主机地址。
有一些地址区块和模式很特殊，以10.、172.16.、172.31.、192.168.开头的所有IPv4地址都为分配，可以在内部网使用，不允许加入全球Internet。127开头的地址（常见的是127.0.0.1）总表示本地会送地址，也就是说这些地址总指向本地计算机，而无论在哪个计算机上运行，这个地址的主机名通常是localhost。IPv6中则是0:0:0:0:0:0:0:1 也就是::1.而地址0.0.0.0总指示其实主机，但只能用于源地址，而不能用于目标地址。
4字节都使用相同数字的IPv4地址（如255.255.255.255）是一个广播地址，发送到这个地址的包将由本地网络上的所有节点接受。
端口
同时需要处理多个网络流，通过端口实现。每台有IP地址的计算机都又几千个逻辑端口（每个传输层协议都有65535个端口），这些只是内存中的抽象，不表示任何物理实物，与USB端口不同，每个端口由1到65535之间的一个数字标识，可以分配给一个指定的任务。
1到1023端口号保留给已知的服务，如finger、FTP、HTTP和IMAP。UNIX和LINUX中只有root可以接受，任何用户可以发送，Windows中所有程序都可以使用，无需额外的授权。
已知端口分配
echo                7           TCP/UDP             测试协议，通过回显另一台机器的输入来验证能否连接
discard             9           TCP/UDP             用处不大的协议，将忽视服务器接收到的所有数据
daytime             13          TCP/UDP             提供服务器当前时间的ASCII表示
FTP                 20          TCP                 使用两个已知端口，这个用于传输文件
FTP                 21          TCP                 这个用来发送FTP命令，比如put和get
SSH                 22          TCP                 用于加密的远程登录
Telnet              23          TCP                 用于交互式远程命令行会话
smtp                25          TCP                 简单邮件传输协议
time                37          TCP/UDP             时间服务器返回服务器从1990-01-01后过去的描述，这是一个4字节带有符号的big-endian整数
whois               43          TCP                 用于Internet网络管理的简单目录服务
finger              79          TCP                 返回本地系统中用户（或多个用户）有关信息的服务
HTTP                80          TCP                 国际互联网的底层协议
POP3                110         TCP                 邮局协议版本3
NNTP                119         TCP                 新闻传输
IMAP                143         TCP                 Internet消息访问协议是访问存储在服务器上的邮箱的协议
HTTPS               443         TCP                 SSH的HTTP
Internet
是世界上最大的基于IP的网络。Internet中每台计算机都至少有一个标识此计算机的IP地址，大多数还有至少一个主机名映射到这个IP地址。
Internet不是唯一的基于IP的网络，但却是最大的一个，其他IP网络称为internet
Internet地址分块
区域Internet注册机构会为Internet服务提供商（ISP）分配IPv4地址块，当需要连接基于IP的网络连接时，ISP会分配给一个地址。如果前缀216.254.85，那么可以使用216.254.85.0-216.265.85.255的地址，由于固定了前24位，称为/24。/23则说明固定了23位，有512个地址可以使用，
网络地址转换
网络地址转换(Net Address Transaction, NTA)，基于NAT网络中，大多数节点只有不可路由的本地地址，从10.x.x.x/172.16.x.x/172.31.x.x或192.168.x.x选择，将本地网络连接到ISP的路由器会把这些本地地址转换为更小的一组可路由的地址。路由器会监视出站和入栈连接，调整IP包中的地址。出站的包，将源地址改为路由器的外部地址，对入站的包，将目的地地址改为一个本地地址。IPv6中大部分内容会过时，NAT会毫无意义，但是对于防火墙还是有用的。
防火墙
检查所有出入站的数据，保证其合法性。防火墙可以是单独机器。过滤通常是基于网络地址和端口的。Java与防火墙没有太大关系。
代理服务器
proxy server与防火墙有关，如果防火墙会组织一个网络上的主机和外界直接建立连接，那么代理服务器就起到中间人的作用。安全优势是外部只能看到代理服务器，而不知道内部机器的主机名和IP地址。
IP地址一般作用域传输层或网际层，而代理服务器通常工作于应用层。对应用层协议非常了解（例如是SOCKS代理服务器，工作于传输层，可以代理所有TCP和UDP连接）。可以检查通过代理服务器的包，确保其中包含适当类型的数据。
代理服务器可以用来实现本地缓存（load caching），当请求Web服务器的文件时，代理服务器首先查看此文件是否已在缓存中，如果在则直接提供，不在则先获取再转发给请求放并存储在缓存中。
代理服务器最大问题在于无法应对所有协议。

## 流
网络程序所做的很大一部分工作都是简单的输入和输出，将数据字节从一个系统移动到另一个系统。
Java的I/O建立于流之上。输入流读取数据，输出流写入数据。不同的流类，会读写某个特定的数据源。但是所有输出流都有相同的基本方法来写入数据，所有输入流都有相同的基本方法来读取数据。
过滤流可以串链到输入流或输出流上，读写数据是，过滤器可以修改数据或者提供额外的方法，将读写的数据转换为其他格式。如DataOutputStream类就提供一个方法，将int转换为4字节，并把这些字节写入底层的输出流。
阅读器（reader）和书写器（writer）可以串链到输入流和输出流上，允许程序读写文本（即字符）而不是字节，只要正确使用，阅读器和书写器可以处理很多字符编码。
流是同步的，也就是说，当程序（确切的是线程）请求一个流读写一端数据时，在做任何其他操作前，需要等待所读写的数据。Java支持使用通道和缓冲区的非阻塞I/O。非阻塞I/O稍有些复杂，，但在某些高吞吐量的应用程序中，非阻塞I/O要快的多。
# 输出流
基本输出流类为java.io.OutputStream
提供写入数据所需的基本方法
public abstract void write(int b) throws IOException;
public void write(byte[] data) throws IOException;
public void write(byte[] data, int offset, int length) throws IOException;
public void flush() throws IOException;
public void close() throws IOException;
OutputStream的子类使用这些方法向某种特定介质写入数据。如FileOutputStream写入数据，TelnetOutputStream写入网络连接，ByteArrayOutputStream写入可扩展字节数据。
OutputStream的基本方法write(int b)，接受一个0-255之间的整数作为参数，将对应的字节写入输出流。这个方法是抽象的，需要各个子类修改这个方法来处理特定的介质。
虽然write方法接受一个int参数，但实际会写入一个无符号字节。Java没有无符号字节数据类型，所以使用int类型代替。write写入int类型时，只会写入最低4字节（右边4位），其他3个字节将被忽略。大多数TCP/IP实现都会在某种程度上缓存数据，在内存中积累数据字节，到一定数据后，一起发送数据到最终目的地。
网络硬件中的缓存一样，流还可以在软件中得到缓存，即直接用Java代码缓存，可以通过BufferedOutputStream或BufferedWriter串链到底层留上来实现。flush刷新输出流非常重要。
不管是否有必要，刷新输出流都很重要。这是个低成本的操作，在关闭前需要刷新输出流。
最后当结束一个流的操作时，通过调用close()方法将其关闭。这会释放这个流关联的所有资源，如文件句柄或端口。如果流来自一个网络连接，则关闭这个流也会终止这个连接。不过有些流仍然允许对这个对象做一些处理，例如关闭的ByteArrayOutputStream可以转换为实际的字节数组。
在一个长时间运行的程序中，如果未能关闭一个流，则可能泄漏文件句柄、网络端口和其他资源。JAVA6之前明智的做法是放在finally中关闭流。
Java7引入带资源的try构造，
try (OutputStream out = new FileOutputStream("")) {

} catch (IOException e) {

}
无需finally块，Java会对try块参数表中声明的所有AutoCloseable对象自动调用close()
# 输入流
基本类是java.io.InputStream
基本方法
public abstract int read() throws IOException;
public int read(byte[] input) throws IOException;
public int read(byte[] input, int offset, int length) throws IOException;
public long skip(long n) throws IOException;
public int variable() throws IOException;
public void close() throws IOException;
InputStream的具体子类使用方法从某种特定介质中读取数据。
read()方法从输入流中读取1字节数据，作为一个0-255的int返回，结束通过返回-1来表示。read()方法会等待并阻塞其后任何代码的执行，直到有1字节的数据可供读取。输入和输出可能很慢，所以如果程序在做其他重要的工作，要尽量将I/O放在单独的线程中。
read()方法声明为抽象方法，各个子类需要实现方法来处理特定介质。
虽然read()只读取1字节，但会返回1个int，把结果存储到字节数组之前就必须进行类型转换。会产生一个-128到127的有符号字节。需要清除返回则需要转换为无符号字符。
一次读取1字节效率不高，可以使用重载的read()方法，
read(byte[] input) 尝试填充数组，但不一定成功。如果需要则放到一个循环中进行操作
int bytesRead = 0;
int bytesToRead = 1024;
bytes[] input = new byte[bytesToRead];
while (bytesRead < bytesToRead) {
    int result = in.read(input, bytesRead, bytesToRead - bytesRead);
    if (result == -1)
        break;
    bytesRead += result;
}
这个方法对于网络流尤为重要。
available()方法返回在不阻塞的情况下至少可以读取的字节数
skip()跳过数据不进行读取 （可能用于端点续传等情况）
close()关闭
# 标记和重置
InputStream还有3个不太常用的方法，允许程序备份和重新读取已经读取的数据
public void mark(int readAheadLimit)
public void reset() throws IOException
public boolean markSupported()
为了重新读取数据，要用mark()方法标记流的当前位置。可以用reset()方法把流重置到之前标记的位置。接下来的读取操作会返回从编辑位置开始的位置。不过，不能随心所欲的向前重置任意远的位置。从标记处读取和重置的字节数由mark的readAheadLimit参数确定。
此外，一个流在任何时刻只能有一个标记。
标记和重置通过将标记位置之后的所有字节存储在一个内部缓冲区中来实现。不过，不是所有输入流都支持这一点。在尝试使用标记和重置之前，使用markSupported判断。
*
支持的流比较少，不用特别了解
*
# 过滤器流
InputStream和OutputStream可以单个或成组的读写字节。Java提供了很多过滤器类，可以附加到原始流上，在原始字节和各种格式之间来回转换。
过滤器有两个版本：过滤器流和阅读器、书写器。过滤器流仍然主要将原始数据作为字节处理，阅读器、书写器则处理多种编码文本的特殊情况。
过滤器以链的形式进行组织。
# 将过滤器串链在一起
过滤器通过其构造函数与流连接。
FileInputStream fis = new FileInputStream("test.txt");
BufferedInputStream bis = new BufferedInputStream(fis);
除了链中的最后一个过滤器之外，无论如何都不应该从其他过滤器读取或写入任何内容。
# 缓冲流
BufferedOutputStream类将写入的数据存储在缓冲区中（一个名为buf的保护字节数组字段），直到缓冲区满或刷新输出流。然后将数据一次性写入底层输出流。
BufferedInputStream类也有一个作为缓冲区的保护字节数组，名为buf。调用read()方法时，首先尝试从缓冲区获得请求的数据，只有当缓冲区没有数据时，流才从底层的源中读取数据。会从源中读取尽可能多的数据存入缓冲区，而不管是否需要。文件读取缓冲区可以得到相当大的提升，而网络流则不明显。
public BufferedInputStream(InputStream in, int bufferSize)
public BufferedOutputStream(OutputStream out, int bufferSize)
一个是底层流，从中读取未缓冲的数据，写入缓冲的数据。第二个参数则指定缓冲区的字节数。否则输入流大小为2048字节，输出流为512字节。
BufferedInputStream没有声明自己的任何新方法，只覆盖InputStream的方法。多次从底层输入流中读取数据，从而完全填充指定的数组或子数组，只有数组或子数组填满或到达流的尾部或底层流阻塞而无法进一步读取时，才返回。
BufferedOuputStream也没有声明自己的新方法，每次写入会把数据放到缓冲区，当缓冲区满或刷新时写入底层流中。
# PrintStream
System.out就是一个PrintStream
默认情况下，打印流应当显式刷新输出，如果autoFlush参数为true，每次写入1字节数组或者换行，或者调用print()方法时，都会刷新输出流。
有9个重载的print()方法和10个println()方法
print()方法都将其参数以可预见的方式转换为一个字符串，再用默认的编码方式把字符串写入底层输出流。println()方法也完成相同的操作，但会在缩写的行末追加一个与平台有关的行分隔符UNIX \n(LF) WINDOWS \r\n (CRLF)
PrintStream吞掉所有异常，标准方法没有throws IOException声明
使用public boolean checkError()来检查内部错误标识
# 数据流
DataInputStream和DataOutputStream类提供了一些方法，可以用二进制格式读写Java的基本数据类型和字符串。
11种write方法
void writeXXX(xxx xxx)
9种read方法 (writeChars(String chs) writeBytes(String bs) 没有对应的读取方法，使用读取1字符和1字节的方法读取)
xxx readXXX()
还有两个读取无符号字符和无符号整数的方法,读取C程序写入的二进制数据时会遇到
int readUnsignedByte()
int readUnsignedShort()
还有多字节read方法,多字节readFully方法(此方法一次读取指定数量的字节，不够则报错)
read(byte[] input)
read(byte[] input, int offset, int length)
readFully(byte[] input)
readFully(byte[] input, int offset, int length)
还有readLine()方法 不过不应该使用
# 阅读器和书写器
Reader类指定读取字符的API
Writer类指定写入字符的API
对应输入和输出使用字节的地方，阅读器和书写器会使用Unicode字符，过滤器阅读器、书写器可以附加到其他阅读器和书写器上，以提供额外的服务或接口
最重要的具体子类是InputStreamReader和OutputStreamWriter类，InputStreamReader从底层输入流中读取原始字符然后根据指定的编码方式，将字节转换为Unicode字符。OutputStreamWriter则接受Unicode字符，转为为指定编码的字节写入底层输出流。
java.io包还提供几个原始阅读器和书写器类
FileReader/FileWriter
StringReader/StringWriter
CharArrayReader/CharArrayWriter
# 书写器
Writer是OutputStream类的映射，是抽象类。
write(char[] text, int offset, int length)基础方法，其他4个write()方法都根据它实现的。
write(int c)
write(char[] text)
write(String s)
write(String s, int offset, int length)
# OutputStreamWriter
将字符转为指定编码的字节写入底层输出流中。
public OutputStreamWriter(OutputStream out, String encoding)
出了通常的Writer方法，还有一个返回对象编码的方法
public String getEncoding()
# 阅读器
Reader类是java.io.InputStream类的镜像，抽象类。3个read()方法
int read(char[] text, int offset, int length) 基础方法，其他2个都根据它实现
int read()
int read(char[] text)
从底层输入流中读取字节，从指定的编码转为unicode字符并返回。
public InputStreamReader(InputStream in, String encoding)
# 过滤器阅读器和书写器
InputStreamReader和OutputStreamWriter类相当于输入和输出流之上的装饰器，把面向字节的接口改为面向字符的接口，之后可以将其他面向字符的过滤器放在使用java.io.FilterReader和java.io.FilterWriter类的阅读器或书写器上。
BufferedReader/BufferedWriter 使用字符数组缓冲区而不是字节数组,默认8192字符
LineNumberReader
PushbackReader
PrintWriter
# PrintWriter
取代Java1.0的PrintStream类，能正确处理多字节字符集和国际化文本。
print() println()方法类似于PrintStream类
write()方法则写入字符而不是字节。

### 线程
## 运行线程
如果以t开头，表示虚拟机中的一个单独、独立的执行路径。如果以T开头，则是java.lang.Thread类的一个实例。
启动一个新的线程，构建一个Thread类的实例，调用start()方法
需要线程完成一些操作，可以通过继承重写run()方法，或者实现Runnable接口的run()方法并作为参数在构造Thread类实例是传入，通常采用Runnable接口方式
当run()方法执行完毕后，线程就消失，run()方法对于线程就像main()方法对于非线程化传统程序的作用一样。
## 派生Thread
应当只覆盖run()方法 而不要覆盖其他方法
## 实现Runnable接口
new Thread(new Runnable() {
	@Override
	public void run() {
		// 线程逻辑
	}
});
## 从线程返回信息
## 轮询
让获取方法返回一个标志值，直到设置了结果字段为止。然后主线程定期询问获取方法，查看是否返回了标志之外的值。
这个方法可以解决一部分问题，但存在不确定性，不推荐使用
## 回调
相比于轮询机制，回调机制的第一个优点是不会浪费那么多CPU周期，但更重要的优点是回调灵活，可以处理涉及更多线程、对象和类的更复杂的情况。
## Future、Callable和Executor
ExecutorService帮助创建线程，提交Callable任务，会得到一个Future。之后可以向Future请求得到任务的结果，如果结果已经准备就绪，就会立即得到这个结果，如果还没有准备好，则轮询线程会阻塞，知道结果准备就绪。
Fututre是一种非常方便的做法，可以启动多个线程来处理一个问题的不同部分，然后等待全部结束之后再继续。Executor和ExecutorService服务允许使用不同策略将任务分配给不同的线程。
## 同步
指定一个共享资源只能由一个线程独占访问来执行一个特定的语句序列。
## 同步块
synchronzied (object) {

}
在某个对象上同步执行，在同一时间内，只有一个线程能执行，其他的线程将阻塞知道获得同步锁。
## 同步方法
public synronzied void method_name() {

}
同一时间内同一个对象只有一个方法能被调用，其他调用此方法的线程将阻塞直到获得同步锁
## 同步的替代方式
1.尽量使用局部变量而不是字段
2.基本类型的方法参数也可以在单独的线程中安全修改，因为传递的是值而不是引用。String参数是安全的，因为它是不可变的。构造函数一般不需要担心线程安全问题。
3.将非线程安全的类用作为线程安全的类中的一个私有字段。
4.利用java.util.concurrent.atomic包中特意设计为保证线程安全但可变的类（如AtomicInteger,AtomicLong,AtomicIntegerArray,AtomicReference等)
5.利用java.util.Collections类将线程不安全的容器类包装到线程安全的容器类中
## 死锁
1.互斥条件
2.至少有一个任务必须持有一个资源且等待获取一个当前被其他任务持有的资源
3.资源不能任务抢占
4.必须有循环等待
## 线程调度
多线程同时运行时，必须考虑线程调度问题，需要确保所有重要的线程至少要得到一些时间运行，更重要的线程要得到更多的时间
## 优先级
Thread::setPriority()
由于不同平台定义的线程优先级不同，一般使用Java定义的3个优先级
MIN_PRIORITY 1
NORM_PRIORITY 5
MAX_PRIORITY 10
## 抢占
每个虚拟机都有一个线程调度器，确定在给定时刻运行哪个线程。主要有两种线程调度器：抢占式和协作式。抢占式确定一个线程正常轮到其CPU时间时，会暂停并将CPU控制权交给其他线程。协作式则将CPU控制权交给其他线程前，会等待正在运行的线程自己暂停。
所有Java虚拟机都确保在不同优先级之间使用抢占式线程调度，也就是说，当一个优先级第的线程正在运行，而一个优先级高的线程准备运行时，虚拟机会或早或晚暂停低优先级线程，让高优先级线程先运行。而协作式则在运行线程达到暂停点时才会让出CPU运行时间
线程有10种方式暂停或者指示准备暂停
1.IO阻塞
2.同步对象阻塞
3.放弃
4.休眠
5.连接到另一个线程
6.等待一个对象
7.结束
8.被更高优先级线程抢占
9.挂起
10.停止
## 则色
线程必须停下来等待没有的资源时，会发生阻塞 最常见的是IO阻塞，进入同步块或同步方法也会阻塞
## 放弃
Thread.yield() 通知虚拟机，如果有另一个线程准备运行可以让出CPU运行时间（并不保证一定让出）
## 休眠
sleep()
TimeUnit.<unit>.sleep()
interrupt() 中断线程
## 连接线程
join() 等待另一个线程的执行结果
## 等待一个对象
需要在同步块中才能起作用
synchronzied(lock) {

}
wait
notify
notifyAll
wait()方法在以下3种情况被唤醒
时间到期
线程被中断
对象得到通知
## 结束
run()方法正常返回
## 线程池和Executor
Executors类


### Internet地址
连接到Internet的设备称为节点（node），计算机节点称为主机（host）。每个节点或主机都由一个唯一的数来标识，这称为Internet地址或IP地址。
IPv4地址一般写为四个无符号字节，每个字节范围0-255，最高字节在前。为了方便查看，字节间用点号分隔。
IPv6地址通常写为冒号分隔的8个区块，每个区块4个十六进制数字，
域名系统（Domain Name System， DNS）将可以记忆的主机名与计算机可以记忆的IP地址关联到一起。服务器通常至少有一个主机名。
有时 一个名会映射多个IP地址，此时DNS服务器负责随机选择一台机器来响应各个请求。
每台连接到Internet的计算机都应当能访问一个称为域名服务器的机器，了解不同主机名和IP地址之间的映射。大多数域名服务器只知道本地网络上主机的域名，以及其他网站中的域名服务器的地址。如果请求本地域之外的一个机器的地址，本地域名服务器将会询问远程位置的域名服务器，再将结果转发给请求者。
## InetAddress类
java.net.InetAddress类是Java对IP地址的高层表示。大多数其他网络类都需要使用这个类，包括Socket、ServerSocket、URL、DatagramSocket、DatagramPacket等。一般而言，这个类包含一个主机名和一个IP地址。
# 创建新的InetAddress对象
InetAddress类没有公共构造函数，实际上含有的是一些静态工厂方法。可以连接DNS服务器来解析主机名。最常用的InetAddress.getByName()。
InetAddress inetAddress = InetAddress.getByName("<host_name>");
以上方法不仅仅设置一个私有的String字段，实际上会建立与本地DNS服务器的一个连接，来查找名字和数字地址（如果已经查找过则会从缓存中获取而不会连接DNS服务器）。如果DNS服务器无法找到地址，则会抛出一个UnknownHostException。
还可以通过传入点分四段地址来查找对应的Host名称，如果没有找到则会将这个点分四段地址作为HostName返回
如果需要获得一个HostName对应的所有IP地址 则使用InetAddress.getAllByName("<host_name>")会返回一个InetAdrees[]数组
InetAddress.getLocalHost()会获取本地主机的InetAddress对象 尝试从DNS服务器中获取HostName和IP地址 如果获取不到则返回localhost和127.0.0.1

InetAddress.getByAddress()通过IP地址创建一个InetAddress对象。
# 缓存
DNS查找的开销箱单大（如果请求需要经过多个中间服务器，或者尝试解析一个不可达的主机，大约需要几秒时间），所以InetAddress会缓存查找的结果，一旦得到一个给定主机的地址，就不会再次查询。
对不成功的DNS查询只缓存短暂的时间 系统属性networkaddress.cache.ttl和networkaddress.cache.negative.ttl控制
除了InetAddress类的本地缓存，本地主机、本地域名服务器和Internet上其他的DNS服务器都会缓存各种查询结果，对此，Java没有提供有关的控制方法。
# 按IP查找
调用InetAddress.getByName并传入IP地址作为参数，会为请求的IP地址创建InetAddress对象，而不检查DNS服务器。只有当调用getHostName()方法时才会真正完成DNS查找。
# 安全性问题
# 获取方法
public String getHostName() 主机名或者IP地址
public String getCanonicalHostName() 与DNS联系更积极一些，在指导主机名的情况下也会联系DNS，可能会替换原来缓存的主机名
public String getAddress()
public String getHostAddress()
InetAddress是不可变的，因此是线程安全的
# 地址类型
有些IP地址和地址模式有特殊的含义
127.0.0.1       本地回送地址
224.0.0.0到239.255.255.255都是IPv4地址的组播地址
Java提供了10个方法来测试InetAddress对象是否符合某个标准
public boolean isAnyLocalAddress() # 判断是否是通配地址
public boolean isLoopbackAddress() # 判断是否是回送地址
public boolean isLinkLocalAddress() # 判断是否是IPv6本地连接地址
public boolean isSiteLocalAddress() # 判断是否是IPv6本地网站地址
public boolean isMulticastAddress() # 判断是否是组播地址
public boolean isMCGlobal() # 判断是否是全球组播地址
public boolean isMCNodeLocal() # 判断是否是本地接口组播地址
public boolean isMCLinkLocal() # 判断是否是子网范围组播地址
public boolean isMcSiteLocal() #判断是否是网站范围组播地址
public boolean isMcOrgLocal() #判断是否是组织范围组播地址
# 测试可达性
isReachable()方法
测试一个特定节点对当前主机是否可达
# Object方法
InetAddress继承于Object类
## Inet4Address和Inet6Address
用于区分IPv4和IPv6
## NetworkInterface类
表示一个本地IP地址，可以是一个物理接口也可以是一个虚拟接口
由于NetworkInterface对象表示物理硬件和虚拟地址，所以不能任意构造，使用一些静态工厂方法可以返回与某个网络接口关联的NetworkInterface对象。可以通过IP地址、名字或枚举来请求一个NetworkInterface
public static NetworkInterface getByName(String name)
返回一个NetworkInterface对象，表示又指定名字的网络接口。如果没有这么一个接口则返回null
名字的格式与平台有关，UNIX系统上，以太网接口名形式为eth0,eth1... 本地回送地址类似1o Windows上名字则类似CE31和ELX100的字符串 取决于特定网络接口的厂商名和硬件模型名
public static NetworkInterface getByInetAddress()
返回与指定IP地址绑定的网络接口，如果没有则返回null
pubic static Enumeration getNetworkInterfaces()
返回本地主机上的所有网络接口
# 获取方法
有了NetworkInterface独享，就可以查询其IP地址和名字
public Enumeration getInetAddress()
一个网络接口可以绑定多个IP地址，
public String getName()
返回某个特定NetworkInterface对象的名
public String getDisplayName()
号称可以返回特定NetworkInterface的一个更友好的名字
## 一些有用的程序
1.SpamCheck
很多服务会监视垃圾邮件发送者，并通知客户端试图与之连接的主机是否是一个已知的垃圾邮件发送者。
响应需要快，理想情况下，应该可以缓存，另外，负载应当分布到多个服务器上。


### URL和URI
## URI
统一资源标识符 采用一种特定语法标识一个资源的字符串。标识的资源可能是服务器上的一个文件、也可能是邮件地址等任何其他内容
资源是URI标识的内容，URI则是标识一个资源的字符串。
URI的语法有一个模式和一个模式特定部分组成。之间用一个冒号分隔
模式:模式特定部分
模式特定部分由模式决定 包括的模式有
data        链接中直接包含的Base64编码数据
file        本地磁盘上的文件
ftp         FTP服务器
http        使用超文本传输协议的国际互联网服务器
mailto      电子邮件地址
magnet      可以通过对等网络下载的资源
telnet      基于Telnet服务的连接
urn         统一资源名
Java还使用一些非标准的定制模式如rmi、jar、jndi和doc来实现各种不同用途
模式特定部分并没有特定的语法，很多都采用一种层次结构形式
//authority/path?query
还可以在authority前使用username:password@来校验身份
模式特定部分由ASCII字母数字符号组成，还可以使用-、_、.、!、~,定界符(如/、?、&和=可以有其预定义的用途)。所有其他字符，包括非ASCII字母数字，应该使用百分号%转义，其后是该字符按照UTF-8编码的十六进制码。如果定界符没有用作为定界符则也需要使用%转义
## URLs
URL是一个URI，除了标识一个资源，还会为资源提供一个特定网络位置，客户端可以用来获取这个资源的一个表示。与URI的区别在于，URI定义一个资源，形容它是什么，而URL则告诉这个资源怎么获取。
URL语法
protocol://userInfo@host:port/path?query#fragment
protocol是URI中模式的另一种称呼
host可以是主机名也可以是IP地址
userInfo是服务器登录信息 是可选的
port是端口号
path指向指定服务器上一个特定目录
query则是向服务器提供的附加参数
fragment指向远程资源的某个特定部分，如果是HTML则指定该文档中的一个锚，如果是XML则是一个XPointer
## 相对URL
并不要求完整指定每个URL，URL可以继承其符文当（即这个URL所在的文档）的协议、主机名和路径。如果继承了父文档的部分信息，这种不完整的URL称为相对URL。
如果以/开头，则相对于文档根目录，而不是当前文件
如果不以/开头，则相对于当前文件
最重要的一点，相对URL允许将整个文档书从一个网站移动或复制到另一个网站，而不会破坏所有的内部链接。
## URL类
java.net.URL类是统一资源定位符的抽象，是一个final类，不能派生子类。也是不可变的，构造之后字段不变，因此是线程安全的。不依赖与继承来配置不同类型URL的实例，而是基于策略设计模式，协议处理器就是策略，URL类构成上下文，通过它来选择不同策略
# 创建URL
使用构造函数
public URL(String url);
public URL(String protocol, String hostname, String file);
public URL(String protocol, String host, int port, String file);
public URL(URL base, String relative)
常用支持的协议有http https jar和ftp
Java除了验证protocol可是识别外，不会对构造的URL完成其他任何的正确性检查。需要自行确保合法性。
# 从字符串构造URL
public URL(String url)
支持的协议由运行的虚拟机和版本决定
# 有组成部分构造URL
public URL(String protocol, String hostname, String file)
这个构造函数会使用协议的默认端口 file参数应该以斜线开头
public URL(String protocol, String hostname, int port, String file)
# 构造相对URL
public URL(URL base, String relative)
# 其他URL对象来源
除了构造函数，还有Java类库中的一些方法也返回URL对象。java.io.File类有一个toURL()方法，返回指定文件匹配的file URL,这方法返回的URL依赖于平台，因此不可跨平台使用不推荐使用
类加载器不仅用于加载类，也能加载资源，如图片和音频文件。静态方法ClassLoader.getSystemResource(String name)返回一个URL，通过它可以读取一个资源ClassLoader.getSystemResources(String name)返回一个Enumeration 包含一个URL列表 最后实例方法getResource(String name)会在所引用的类加载器使用的路径中搜索指定资源的URL。
# 从URL中获取数据
public InputStream openStream()
public URLConnection openConnection()
public URLConnection openConnection(Proxy proxy)
public Object getContent()
public Object getContent(Class[] classes)
最基本也最常用的是openStream() 返回一个InputStream，可以从流中读取数据。如果需要更多控制下载过程，应当调用openConnect(),会提供一个可以配置的URLConnection，再由它得到InputStream。getContent()向URL请求内容，会提供一个更完整的对象，也会给出一个InputStream
1.openStream()
连接到URL所引用的资源，在客户端和服务器之间完成必要的握手，返回一个InputStream，由此读取数据。是URL引用的原始内容，读取到什么内容就返回什么内容。不包括其他任何信息。
2.openConnect()
为指定URL打开一个socket，并返回一个URLConnection对象。
如果希望与服务器直接通信，应该使用这个方法，通过URLConnection，可以访问服务器发送的所有数据，除了原始的文档之外，还可以访问这个协议指定的所有元数据。
有一个重载版本，使用代理服务器传递连接
3.getContent()
获取URL引用的数据，尝试由它建立某种类型的对象，如果URL指示某种文本，返回对象通常是InputStream，如果是图像则是java.awt.ImageProducer。本身不是数据对象，而是一种途径，程序可以利用它构造数据对象
做法是在从服务器获取的数据首部中查找Content-type字段，如果没有或者不熟悉，则返回某种InputStream.如果无法获取则抛出异常
主要的问题在于很难预测将获得哪种对象。
4.getContent(Class[] classes)
选择希望将内容作为哪种类型返回
# 分解URL
有以下5部分组成
1.模式 也成为协议
2.授权机构
3.路径
4.片段标识符 也成为段或ref
5.查询字符串
提供了9个公共方法对URL部分进行只读访问
1.getFile()
2.getHost()
3.getPort()
4.getProtocol()
5.getRef()
6.getQuery()
7.getPath()
8.getUserInfo()
9.getAuthority()
# 相等性和比较
equals()和hashCode()方法
equals()方法会解析DNS服务器来判断是否相同
没有实现Comparable接口
# 比较
toString
toExternalForm
toURI
判断
## URI类
URI是URL的抽象，不仅包括统一资源定位符，还包含统一资源名。java.net.URI
1.URI类完全有关于资源的标识和URI的解析，没有提供方法来获取URI所标识资源的表示
2.URI类与相关的规范更一致
3.URI对象可以表示相对URI　URL类在存储URI之前会将其绝对化
简而言之，URL对象是对应网络获取的应用层协议的一个表示，而URI对象纯粹用于解析和处理字符串。
# 构造一个URI
public URI(String uri)
public URI(String scheme, String schemeSpecificPart, String fragment)
public URI(String scheme, String host, String path, String fragment)
public URI(String scheme, String authority, String path, String query, String fragment)
public URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)
URI不依赖于底层协议处理器，只要URI语法正确，Java就不需要为了创建URI对象而理解其协议
# URI各部分
URI引用包括最多三个部分：模式、模式特定部分和片段标识符 一般格式为
模式:模式特定部分:片段
如果省略模式，则URI引用是相对的。
public String getScheme()
public String getSchemeSpecificPart()
public String getRawSchemeSpecificPart()
public String getFragment()
public String getRawFragment()
如果没有对应部分，则方法返回null
public boolean isAbsolute() // 有模式是绝对URI返回true 否则返回false
模式特定部分的细节根据模式类型不同有所差别。
public boolean isOpaque() // 如果URI是一个层次URI（比如file或http)返回false 否则返回true
public String getAuthority()
public String getFragment()
public String getHost()
public String getPath() 
public String getPort() 	// 忽略端口情况下返回-1
public String getQuery()
public String getUserInfo()
# 解析相对URI
public URI resolve(URI uri)  // 一个URI加上相对URI 
public URI resolve(String url) 
public URI relativize(URI uri) // 一个URI和另一个URI比较 得到相对的URI
# 相等性和比较
相等的URI必须
1.都是层次或者不透明的
2.比较模式和授权机构时不考虑大小写
3.URI其余部分需要区别大小写
4.转义字符在比较前不解码
URI实现了Comparable，因此可以排序
1.模式不同就比较模式，不考虑大小写
2.模式相同则相同模式下，层次URI小于不透明URI
3.都是不透明URI则按照模式特定部分比较
4.再比较片段
5.如果URI都是层次的，则更具授权机构部分排序。授权机构依次根据用户信息、主机和端口排序。主机不区别大小写
6.如果模式和授权机构都相等，就使用路径来区分
7.路径也相同则比较查询字符串
8.最后比较片段
# 字符串表示
toString() // 未编码的字符串 不用百分号转义
toASCIIString()  // 编码字符串 百分号转义
# x-www-form-urlencoded
URL使用的字符必须是ASCII的一个固定子集
大写字母
小写字母
数字
标点符号 -_.!~*'(和,)
字符/&@?#;$+=和%也可以使用 但只用于特定的用途 
除了指定的子集 其他所有字符都要转换为字节，每个字节要写为百分号加两个十六进制数字。空格是一种特殊情况，非常普遍，因此可以使用+编码。而+本身则被编码为%2B /#=&?字符作为分隔符时无需编码 其余时间需要编码
URL类不自动编码或解码，需要使用Java提供的URLEncoder和URLDecoder来对URL字符串编解码
# URLEncoder
String encodedUrl = URLEncoder.encode(String unencodedUrl, String charset)
此方法会对所有可以编码的字符进行编码，而不去判断如何使用。因此应该分部分进行编码，而不是一次性。
# URLDecoder
String decode(String s, String charset)
# 代理
发送请求先到代理再转发到真正目的地 收到请求先到代理再转发到用户 可能出于安全考虑 可能出于过滤请求考虑等
基于URL的Java程序可以使用大多数常见的代理服务器和协议。
# 系统属性
对于基本操作，需要设置一些系统属性，指示本地代理服务器的地址。 System.setProperty()或 -D<property>=<value>
http.proxyHost
http.porxyPort
如果特定主机访问不需要代理
http.nonProxyHosts // 不同主机之间用|分隔
FTP:
ftp:proxyHost
ftp:proxyPort
ftp:nonProxyHosts
Sockets
socketProxyHost
socketProxyPort
# Proxy类
允许Java程序中对代理服务器进行更细粒度的控制
允许为不同的远程主机指定不同的代理服务器。
java.net.Proxy
支持3种代理
Proxy.Type.DIRECT // 直连 不适用代理
Proxy.Type.HTTP // HTTP代理
Proxy.Type.SOCKET // Socket代理
# ProxySelector类
用于确定不同连接的代理服务器
默认只检查系统属性和协议来决定如何连接到不同主机 可以安装自己的ProxySelector来代替默认的选择器
关键是
public abstract List<Proxy> select(URI uri)
public void connectFailed(URI uri, SocketAddress address, IOException ex)
# 通过GET与服务器端程序通信
new URL(<encoded_url>)
然后获取InputStream或URLConnection或contents都可以
## 访问口令保护的网站
标准HTTP认证保护的网站比较容易 也可以访问由Cookie保护的网站
java.net.Authenticator类
这是一个抽象类，必须派生子类，不同子类采用不同的方式获取信息。
使用Authenticator.setDefault()设置认证类
子类必须覆盖getPasswordAuthentication()方法
五次重试机会 然后抛出异常
# PasswordAuthentication类
非常简单的final类，支持两个只读属性，用户名和口令。用户名是一个string，口令是一个char数组。
public PasswordAuthentication(String userName, char[] password)

### HTTP
## HTTP协议
HTTP是Web浏览器和web服务器之间通信的标准协议。HTTP指定客户端与服务器如果建立连接、客户端如何从服务器请求数据，服务器如何响应请求，以及最后如何关闭连接。HTTP连接使用TCP/IP来传输数据，对于从客户端到服务器的每一个请求，都4个步骤
1.默认情况下，客户端在端口80打开与服务器的一个TCP连接，URL中还可以指定其他端口
2.客户端向服务器发送消息，请求指定路径上的资源。请求包括一个首部，可选地（取决于请求的性质）还可以有一个空行，后面是这个请求的数据。
3.服务器向客户端发送响应，响应以响应码开头，后面是包含元数据的的首部，一个空行以及请求的文档或错误信息
4.服务器关闭连接
上面是HTTP1.0过程
HTTP1.1之后，可以通过一次TCP连接连续发送多次请求和响应。
第一行为请求航，包括一个方法、资源以及HTTP的版本。方法指定所请求的操作(GET/POST等)
接着是首部，采用格式key: value
关键字不区分大小写，如果值太长可以在下一行最前面加一个空格或制表符接续上一行
首部的行以一个回车换行结束
首部以一个空行结束
服务器在接受完成后返回响应，以状态行开始，然后是首部，也是key:vale的格式，然后是空行，最后是资源
状态行 先是HTTP的版本 然后是响应码 然是是响应状态
# Keep-Alive
HTTP1.1之后 服务器不必在发送响应后就关闭连接，可以保持连接打开。在同一个Socket上等待来自客户端的新请求。
Connection: Keep-Alive
除非显式关闭，则连接到同一个服务器，会重用socket
Java使用HTTP Keep-alive
1.设置http.keepAlive true或false
2.设置http.maxConnections希望打卡的socket数 默认5
3.http.keeyAlive.remainingData true在丢弃连接前清理 Java6之后的版本 默认false
4.sun.net.http.errorstream.enableBuffering true 
5.sun.net.http.errorstream.bufferSize 缓冲错误流使用的字节数
*
未看完
*
# HTTP方法
与服务器的通信遵循请求-响应模式,先是一个无状态的请求，后面是一个无状态的响应,每个HTTP请求包括两个或三个部分
1.起始行 包含HTTP方法和要执行这个方法的资源的路径
2.一个包含名-值字段的首部 可以提供元信息，如认证凭证和请求中首选使用的格式
3.一个请求主体，包含资源的一个表示
主要有4个HTTP方法
GET
POST
PUT
DELETE
应用程序应该遵循语义，GET方法可以获取一个资源的表示，没有副作用，如果失败也可以重复执行GET。GET的输出通常会缓存。
PUT将资源上传到URL的服务器
DELETE删除资源
POST方法是最通用的方法，将资源的一个表示上传到已知的URL服务器。但是没有指定服务器如何处理这个新提供的资源。POST要用于不能重复的不安全操作。
由于GET请求在URL中包括了所有必要的信息，所以可以对GET请求加书签，或者进行链接和搜索等。
不完成提交的所有安全操作都应当使用GET而不是POST，只有真正提交的操作才应当使用POST
# 请求主体
1.起始行 方法、路径和查询字符串，以及HTTP版本
2.HTTP首部
3.空行
4.主体
HTTP首部要包括两个字段来指定主体的性质
1.Content-length字段，指定主体中有多少字节
2.Content-type字段，指定类型MIME媒体类型
# Cookie
cookie在请求和响应的HTTP首部，服务器用cookie来指示会话ID等 也可能是无意义字符串 
只要服务器不重用cookie，就会让它在多个HTTP连接上跟踪各个用户和会话
Cookie的作用域还收到路径限制。path 指定子路径 domain 指定域名
有过期时间 expire 指定过期时间 maxAge 指定存活时间
# CookieManager
java5 java.net.CookieHandler 定义存储和获取cookie的一个API 但不包括这个抽象类的实现 java6进行补充，增加了一个可以使用的具体类java.net.CookieManager 默认情况cookie并不打开，在Java存储和返回之前，需要先开启
CookieManager manager = new CookieManager();
CookieHandler.setDefault(manager);
接受Cookie的来源使用CookiePolicy
CookiePolicy.ACCEPT_ALL 接受所有
CookiePolicy.ACCEPT_NONE 所有不接受
CookiePolicy.ACCEPT_ORIGINAL_SERVER 只接受第一方cookie
更细粒度的控制则覆盖CookiePolicy的
public boolean shouldAccept(URI uri, HttpCookie cookie)
# CookieStore
有时需要在本地存放和获取Cookie，用getCookieStore()方法来获取这个cookie库，CookieStore保存
CookieStore store = manager.getCookieStore()
允许增加、删除和列出cookie，能控制在正常HTTP请求和响应流外发送的cookie


### URLConnection
抽象类，表示指向URL指定资源的活动连接。URLConnection有两个不同但有关的用途。首先，与URL类相比，对服务器（特别是HTTP服务器）的交互提供了更多的控制。URLConnection可以检查服务器发送的首部，并相应地做出响应。可以设置客户端请求中使用的首部字段。最后，URLConnection可以用POST、PUT和其他HTTP请求方法向服务器发回数据。
其次，URLConnection类是Java的协议处理器机制的一部分，这个机制还包括URLStreamHandler类，协议处理器的思想很简单：将处理协议的细节与处理特定数据类型分开，提供相应的用户接口，并完成整个Web浏览器锁完成的其他操作。
java.net包中只有抽象URLConnection类，具体子类都隐藏在sun.net包中。URLConnection的许多方法和字段以及一个构造函数都是保护的。只能由URLConnection类或其子类的实例访问。很少会在源代码中直接实例化一个URLConnection对象。
## 打开URLConnection
1.构造一个URL对象
2.调用这个URL对象的openConnection()获取一个对应该URL的URLConnection对象
3.配置URLConnection
4.读取首部字段
5.获得输入流并读取数据
6.获得输出流并读取数据
7.关闭连接
只有一个方法未实现 connect方法，建立与服务器的连接，因而依赖于服务类型（HTTP、FTP等）。
## 读取服务器数据
1.构造URL对象
2.调用URL对象的openConnection()方法，获取对应该URL的URLConnection对象
3.调用getInputStream()
4.使用通常的流API读取输入流
URL和URLConnection的区别
1.URLConnection提供了对HTTP首部的访问
2.URLConnection可以配置发送给服务器的请求参数
3.URLConnection除了可以读取之外，还可以向服务器写入数据
## 读取首部
编写自己的URLConnection子类时，必须覆盖这些方法，才能返回有意义的值
## 获取指定的首部字段
特定的常用字段
1.Content-type
public String getContentType()
返回响应主体的MIME类型，依赖于Web服务器发送一个有效的内容类型，如果没有不会抛出异常而是返回null。
常见text/html text/plain image/gif application/json
如果内容类型是某种形式的文本，首部还可能包含一个字符集部分，标识文档的字符编码方法。
Content-type: text/html; charset= UTF-8
此情况下，返回Content-type字段的完整值，包括字符编码方式。如果没有指定则默认是ISO-8859-1。如果遇到非文本类型则会抛出一个异常。
2.Content-length
public int getContentLength()
告知内容中有多少字节，没有则返回-1，不抛出异常。如果需要准确知道要读取的字节数，或者预创建缓冲区来保存数据，可以使用
Java7添加了getContentLengthLong()方法。
3.Content-encoding
public String getContentEncoding()
内容是如何编码的。发送内容没有编码就返回null。比较常用的可能是x-gzip使用GZipInputStream解码
4.Date
public long getDate()
返回一个long，指出资源发送的时间戳。 没有包含Date字段则返回0
5.Expiration
public long Expiration
基于服务器的过期时间，指示应当何时从缓存中删除文档，并从服务器重新下载 没有包含则返回0 不表示永不过期
6.LastModified
public long getLastModified()
返回文档最后修改日期。没有返回0
## 获取任意首部字段
public String getHeaderField(Strigg name) // 获取指定名称的首部字段的值
public String getHeaderFieldKey(int n) // 获取第n个首部字段的键
public String getHeaderField(int n) // 获取第n个首部字段的值
public long getHeaderFieldDate(String name, long default) // 首先获得首部字段的值 再尝试转换为一个long
public int getHeaderFieldInt(String name, int default) // 转换为int
## 缓存
一般认为使用GET通过HTTP访问的页面可以缓存也应当缓存。其他的则不应该缓存
Cache-control （HTTP1.1）提供了细粒度的缓存策略
1.max-age=[seconds]			从现在到缓存项过期的秒数
2.s-maxage=[seconds]		从现在到缓存项在共享缓存中过期之前的秒数 私有缓存可以缓存更长时间
3.public 					可以缓存一个经过认证的想要
4.private					仅单个用户缓存可以保存响应
5.no-cache					缓存项仍然可以缓存，不过客户端在每次访问时都要用一个Etag或Last-modified首部重新验证响应装填
6.no-store					不管怎么样都不缓存
## Java中的Web缓存
默认并不缓存 使用缓存需要
ResponseCache的一个具体子类
CacheRequest的一个具体子类
CacheResponse的一个具体子类
ResponseCache.setDefault来设置ResponseCache。
ResponseCache提供了两个抽象方法 可以存储和获取系统缓存中的数据
public abstract CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders)
public abstract CacheRequst put(URI uri, URLConnection connection)
put()方法返回一个CacheRequest对象，包装了一个OutputStream，把读取的可缓存数据写入这个输出流
CacheRequest包含两个方法
public abstract OutputStream getBody()  	// 指向缓存的数据库，协议处理器将读取的数据复制到这个Outpustream中
public abstract void abort() 				// 如果复制失败，协议处理器将调用abort()方法，应当从缓存删除这个请求存储的所有数据
get()方法从缓存中获取数据和首部，包装在CacheResponse对象中返回。如果不存在返回null，然后正常从远程服务器加载URI。
public abstract Map<String, List<String>> getHeaders()
public abstract InputStream getBody()
## 配置连接
URLConnection中有7个保护的实例字段 定义了客户端如何向服务器做出请求
protected URL url
protected boolean doInput = ture
protected boolean doOutput = true
protected boolean allowUserInteraction = defaultAllowUserInteraction
protected boolean useCaches = defaultUseCaches
protected long ifModifiedSince = 0
protected boolean connected = false
只能使用相应的设置和获取放来来访问和修改
只能在URLConnection连接之前修改（试图读取内容或首部之前）
1.protected URL url
指定了这个URLConnection连接的URL，在创建URLConnection时设置这个字段 之后不能改变。
2.protected boolean connected
如果连接打开 true 否则false。
任何导致连接的方法都将这个变量设置为true，包括connect()、getIn/OutputStream()，任何断开连接的方法都将置为false。
自定义派生子类需要自行维护这个boolean变量
3.protected boolean allowUserInteraction
需要需要与用户交互 默认false
只能在URLConnection连接之前修改
4.protected boolean doInput
默认true 是否可用于读取
只能在链接之前修改
5.protected boolean doOutput
默认false  是否可用于写入
只能在连接前设置
6.protected boolean ifModifiedSince
是否想服务器发送本地缓存的时间作为请求的首部字段
If-Modified-Since
如果修改则服务器返回新的文档 否则不返回
7.protected boolean useCaches
是否可以使用缓存 默认true
## 超时
有4个方法可以查询和修改连接的超时值。
public void setConnectTimeout(int timeout)
public int getConnectTimetout()
public void setReadTimeout(int timeout)
public void getReadTimeout()
前两个控制socket等待建立连接的时间 后两个则控制输入流等到数据到达的时间
## 配置客户端请求HTTP首部
每个URLConnection会在首部默认设置一些不同的名-值对。
在打开连接前，可以使用
public void setRequestProperty(String name, String value)
为HTTP首部修改或增加新的字段
HTTP允许为一个指定名字的属性设置多个值，这种情况下，各个值用逗号隔开。
public void addRequestProperty(String name, String value) // 为字段增加一个新值 而不是覆盖
public String getRequestProperty(String name)
public Map<String, List<String>> getRequestProperties()
## 向服务器写入数据
public OutputStream getOutputStream()
由于URLConnection在默认情况下不允许输出，所以需要在请求输出流之前设置setOutput(true)。请求方法将从GET变为POST。
## URLConnection的安全考虑
public Permission getPermission()
指出连接URL所需的权限。如果不需要返回null，需要则返回不同子类
## 猜测MIME媒体类型
public static String guessContentTypeFromName(String name)
public static String guessContentTypeFromStream(Inpustream in)
## HttpURLConnection
java.net.HttpURLConnection类是URLConnection的抽象子类。提供了另外一些方法，在处理httpURL时尤为有效。包含的方法可以获得和设置请求方法，确定是否重定向，获得响应码和消息，以及确定是否使用了代理服务器。是抽象类，不能直接创建实例
在使用http URL openConnection时，返回的URLConnection是HttpURLConnection，可以强制转型。
## 请求方法
public void setRequestMethod(String method)
参数可选 GET POST PUT DELETE HEAD OPTIONS TRACE
1.HEAD
值返回响应首部
2.DELETE
删除指定资源 由于存在安全风险 不是所有服务器都支持 通常需要身份验证
3.PUT
希望存储文件，通常需要身份验证
4.OPTIONS
询问URL支持哪些选项
返回的HTTP首部的Allow字段
5.TRACE
查看服务器和客户端之间的代理服务器做了哪些修改
## 断开与服务器的连接
public abstract void disconnet()
## 处理服务器响应
public int getResponseCode()
返回响应码
public String getResponseMessage()
返回响应信息
# 错误条件
public InputStream getErrorStream()
返回错误的输入流
# 重定向
public static boolean getFollowRedirects()
public static void setFollowRedirects(boolean follow)
默认情况下,HttpURLConnection会跟随重定向。
# 代理
public abstract Boolean usingProxy()
# 流模式
每个发送给HTTP服务器的请求都有一个HTTP首部，有一个Content-length字段，即请求主题中的字节数。
如果知道数据大小，可以将大小告诉HttpURLConnection对象。预先不知道则可以使用分块传输编码方式，请求主题以多个部分发送，每个部分都有自己单独的内容长度
public void setChunkedStreamingMode(int chunkLength) // 设置分块大小
如果预先知道请求数据大小，可以告诉HttpURLConnection对象，从而优化连接。
public void setFixedLengthStreamingMode(int contentLength)
public void setFixedLengthStreamingMode(long contentLength)
Java会在HTTP首部使用这个数，接下来写入的数据大于或小于这个数都将抛出异常。

### 客户端Socket
## 使用Socket
1.连接远程主机
2.发送数据
3.接受数据
4.关闭连接
5.绑定端口
6.监听入站数据
7.在绑定端口上接收来自远程机器的连接
Java的Socket类提供了对应前4个操作的方法，后面3个仅服务器使用，即等待客户端连接。这些操作有ServerSocket类实现。Java程序通常采用以下方式使用客户端Socket
1.用构造函数创建一个新的Socket
2.Socket尝试连接远程主机
一旦建立了连接，本地和远程主机就从这个Socket中得到输入流和输出流，使用流发送数据。
## 用Telnet研究协议
## 用Socket从服务器读取
Socket socket = new Socket(<host>, <port>)
socket.getInputStream()
## 用Socket写入服务器
向Socket请求一个输出流以及一个输入流。使用输出流在socket上发送数据，使用输入流在socket上读取数据。
## 半关闭Socket
close()方法同时关闭socket的输入流和输出流，只想关闭其中一个使用shutdownInput()和shutdownOutput()
这并不关闭socket，会调整与Socket连接的流，使他认为已经到了流的末尾，关闭输入之后再读取将返回-1，输出则抛出异常
即使关闭了输出和输入流 也需要手动调用socket.close()关闭 shutdown方法只影响socket的流，并不释放与socket关联的资源。
isInputShutdown()和isOutputShutdown()方法分别指出输入流和输出流是打开的还是关闭的。
## 构造和连接Socket
# 基本构造函数
public Socket(String host, int port)
public SOcket(InetAddress host, int port)
尝试连接socket，失败则抛出异常。
这两个构造方法创建连接的socket，以下则是创建未连接的socket
public Socket()
public Socket(Proxy proxy)
protected Socket(SocketImpl impl)
# 选择从哪个本地接口连接
public Socket(String host, int port, InetAddress interface, int localPort)
public Socket(InetAddress host, int port, InetAddress interface, int localPort)
前两个参数指定服务器的主机和端口，后两个指定本地网络的接口和端口 本地端口传入0则会选择1024到65535之间的一个可用端口
# 构造但不链接
new Socket()
此时socket并不连接
再使用connet()方法连接
public void connect(SocketAddress endpoint, int timeout)
# Socekt地址
SocketAddress类表示一个连接端点，空的抽象类。实际使用的Socket地址都是InetSocketAddress的实例
主要用途是为暂时的socket连接信息提供方便的存储，即使socket断开被垃圾回收，这些信息也可以重用。
public SocketAddress getRemoteSocketAddress() // 连接到的系统的地址
public SocketAddress getLocalSocketAddress() // 发起连接的系统的地址
InetSocketAddress是SocketAddress的子类
public InetSocketAddress(InetAddress address, int port)
public InetSocketAddress(String host, int port)
public InetSocketAddress(int port)
# 代理服务器

# 获取Socket的信息
1.远程地址 getInetAddress()
2.远程端口 getPort()
3.本地地址 getLocalAddress()
4.本地端口 getLocalPort()
远程端口一般是选定的，而本地端口则是从空闲端口随机选择的。
# 关闭还是连接
isClose()	// 是否关闭
isConnected // 是否从未连接过远程主机 可以连接包括已经连接过的就返回true
isBound()	// 是否成功绑定到本地系统上的出栈端口
# toString()
# 设置Socket选项
支持9个选项
1.TCP_NODELAY
public void setTcpNoDelay(boolean on)
public boolean getTcpNoDelay()
true时会确保包尽可能快速发送，无论包的大小。小数据包在发送前会组合为更大的包。在发送另一个包前，本地主机等待远程系统对前一个包的确认。
true时关闭缓冲，一旦包就绪就发送
2.SO_BINDADDR
Socket关闭可能不会立即释放本地端口。会等待一段时间，确保接受到所有要发送到这个端口的延迟数据包。不会做任何处理，只是希望确保这些数据不会意外传入绑定到同一端口的新进程。
这可能阻止新进程绑定到这个端口，如果开启SO_REUSEADDR(默认关闭)，就允许另一个Socket绑定到这个端口，即使此时仍然可能存在前一个Socket未接受的数据
public void setReuseAddress(boolean on)
public void getReuseAddress()
3.SO_TIMEOUT
public void setSoTimeout(int milliseconds)
正常情况下，尝试从Socket读取数据时，read()调用会阻塞尽可能长的时间来得到足够的字节数，设置参数确保阻塞时间不会超过固定的毫秒数。
public int getSoTimeout()
4.SO_LINGER
public void setSoLinger(boolean on, in seconds)
指定Socket关闭时如何处理尚未发送的数据报 默认情况下close()方法将立即返回，但系统仍会尝试发送剩余的数据。如果延迟时间设置为0，那么当关闭时，所有未发送的数据包将被丢弃。如果打开并设置延迟时间则close()方法会阻塞，等待发送数据和接收确认。
最大时间为65535秒
public int getSoLinger()
5.SO_SNDBUF
TCP使用缓冲区提升网络性能，较大的缓冲区会提升快速连接的性能。一般而言，传输连续的大数据块时，可以从大缓冲区中收益，而对于交互式会话的小数据量传输（如telnet和很多游戏），大缓冲区则没有多大帮助。
想要得到最大带宽，将缓冲区大小与连接的延迟匹配，使其稍小于网络的带宽。
public void setReceiveBufferSize(int size)
public int getReceiveBufferSize(
public void setSendBufferSize(int size)
public int getSendBufferSize()
尽管看起来可以独立设置发送或接受缓冲区，但实际上缓冲区通常会设置为两者中较小的一个。
如果没有必要，不用设置
6.SO_REVBUF
7.SO_KEEPALIVE
如果开启SO_KEEPALIVE，偶尔会通过一个空闲连接发送一个数据包，以确保服务器未崩溃。如果没有SO_KEEPALIVE，不活动的客户端可能会永远存在下去。
public void setKeepAlive(boolean on)
public boolean getKeepAlive() 
默认false
8.OOBINLINE
TCP包括一个可以发送单字节带外紧急数据的特性。这个数据立即发送，接收方优先处理这个数据
public void sendUrgentData(int data)
默认情况下Java会忽略从Socket接受的紧急数据，如果需要接受则
public void setOOBInline(boolean on)
public void getOOBInline()
9.IP_TOS
不同类型的Internet服务有不同的性能需求。服务类型存储在IP首部的一个名为IP_TOS的8位字段中，Java允许使用下面方法检查和设置Socket放在这个字段中的值
public int getTrafficClass()
public void setTrafficeClass(int trafficeClass)
业务流程以0-255之间的int给出。由于这个值要复制到TCP首部的一个8位字段中，因此使用int的低字节。

## Socket异常
大多数方法都声明抛出IOException或其子类java.net.SocketException
BindException 
ConnectException
NoRouteToHostException
ProtocolException


### 服务器Socket
## 使用ServerSocket
包含了Java编写服务器所需的全部内容 包括创建新ServerSocket对象的构造函数，在指定端口监听连接的方法、配置各个服务器Socket选项的方法。
服务器程序的基本生命周期
1.使用ServerSocket构造函数在一个特定端口创建一个新的ServerSocket
2.ServerSocket使用accept()方法监听这个端口的入站连接。accept()会一直阻塞知道客户端尝试连接，accept将返回一个连接客户端和服务器的Socket对象
3.根据服务的类型，会调用Socket的getInputStream()方法或getOutputStream()方法，或者两者都调用，以获得与客户端通信的输入和输出流
4.服务器和客户端根据以协商的协议交互，直到要关闭连接
5.服务器或客户端（或二者）关闭连接
6.返回步骤2，等待下次连接
## 提供二进制数据
使用InputStream而不是Writer
## 多线程服务器


## Socket选项
# SO_TIME
是accept()在抛出java.io.InterruptedException异常前等待入站连接的时间，以毫秒计。如果为0则表示永不超时，默认永不超时。
很少会直接设置SO_TIMEOUT，如果要实现一个复杂的安全协议，客户端和服务器之间需要有多个连接，响应会在一定的时间内出现，这种情况下可能会需要这个选项。
public void setSoTimeout(int timeout)
public int getSoTimeout()
# SO_REUSEADDR
是否允许新的Socket绑定到之前使用过的一个端口，可能还有数据发送到原Socket。
public boolean getReuseAddr()
public void setReuseAddr(boolean on)
默认值依赖于具体平台。
# SO_RCVBUF
设置了服务器Socket接受的客户端默认接收缓冲区大小。
public void setReceiveBufferSize(int size)
public int getReceiveBufferSize()
Socekt在接受之后不能修改缓冲区大小。
# 服务类型
不同的Internet服务类型有不同的性能需求。
为TCP定义了4个通用业务流类型
1.低成本
2.高可靠性
3.最大吞吐量
4.最小延迟
对于服务器所接受的Socket，setPerformancePreferences()方法描述了为其连接时间、延迟和带宽给定的相对优先级
public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)
connectionTime 代表 连接时间
latency 最小延迟
bandwidth 最大带宽
数值越大 优先级越高
具体实现依赖于底层Socket，很多（包括Andriod）会忽略这个提示。
## HTTP服务器
# 单文件服务器
public class SimpleSingleFileServer {
	// 详见network 相关java文件
}
# 重定向器
详见相关java文件

### 安全Socket
为了让Internet连接从根本上更加安全，可以对Socket加密。
Java安全Socket扩展可以使用安全Socket层（SSL）和传输层安全（TLS）协议及相关算法来保护网络通信的安全。SSL是一种安全协议，允许Web浏览器和其他TCP客户端基于各种级别的机密性和认证与HTTP和其他TCP服务对话
## 保护通信
经过开放通道的私密通信绝对需要对数据加密。适合计算机实现的大多数加密机制都是基于密钥思想的，密钥是一种更加一般化的口令，并不限于文本。明文消息根据一种数学算法与密钥的各个位组合，生成加密的密文。使用的密钥位数越多，通过强力猜测密钥的方法来解密消息时就会越困难。
在传统的私密密钥（或对称密钥）加密中，加密和解密数据都使用相同的密钥。发送方和接收方必须知道这个密钥
在公开密钥（或非对称密钥）加密中，加密和解密数据使用不同的密钥。一个密钥称为公开密钥，用于加密数据。这个密钥可以提供给任何人。另一个密钥称为私密密钥，用于解密数据，必须秘密保存。
非对称加密也可用于身份认证和消息完整性检查。数据可以用自己的公钥加密一次，再用接收方的公钥加密一次。
在实际中，公开密钥加密是比较CPU密集型的操作，比秘密密钥加密慢的多。因此，不用公开密钥加密整个传输内容，而是用来加密传统的秘密密钥，再将加密后的私密密钥发送给对方。对方解密秘密密钥用于解密全部内容。
攻击方式在发送过程中，攻击方将公开密钥替换为自己的密钥，数据就可以被攻击方以自己的密钥解密而获得数据内容。
Java安全Socket扩展（JSSE）分为4个包
javax.net.ssl
	定义Java安全网络通信API的抽象类
javax.net
	替代构造函数创建安全Socket的抽象Socket工厂类
java.security.cert
	处理SSL所需公开密钥证书的类
com.sun.net.ssl
	Sun的JSSE参考实现中实现加密算法和协议的具体类
## 创建安全客户端Socket
如果不太关心底层的细节，使用加密SSL Socket与现有的安全服务器通信确实非常简单。不用构造函数构建一个java.net.Socket对象实例，而是使用javax.net.ssl.SSLSocketFactory的createSocket()方法得到一个Socket对象。SSLSocketFactory是一个遵循抽象工厂设计模式的抽象类。通过调用SSLSocketFactory.getDefault()获取一个SSLSocketFactory对象的实例
SocketFactroy socketFactory = SSLSocketFactory.getDefault();
Socket socket = socketFactroy.createSocket(host, port);
createSocket有5个重载版本
两个用于创建连接到指定主机和端口的Socket
两个用于创建从指定本地网络接口和端口连接到指定主机和端口的Socket
一个用于连接到代理服务器现有Socket对象作为起点，返回一个经由这个代理服务器到指定主机和端口的Socket autoClose参数确定当这个Socket关闭时，底层proxy Socket是否应当关闭。
createSocket方法返回的Socket实际上是javax.net.ssl.SSLSocket，这个java.net.Socket的一个子类。无需关心实现，可以像使用普通Socket一样使用。
## 选择密码组
JSSE的不同实现支持认证和加密算法的不同组合
String[] getSupportedCipherSuites() // 支持的密码组 有些强度太弱 因而禁止使用
String[] getEnabledCipherSuites() // 允许使用的密码组
每个密码组的名称中的算法分为4个部分：协议、密钥交换算法、加密算法和校验和。
## 事件处理器
网络通信相对于大多数计算机速度而言都很慢。认证的网络通信设置更慢。可能希望异步处理，得到握手结束事件的通知，需要实现HandshakeCompletedListener接口
其中的
public void handshakeCompleted(HandshakeCompletedEvent event)方法
接受一个HandshakeCompletedEvent作为参数
这个事件类提供了获取事件有关信息的方法
public SSLSession getSession()
public String getCripherSuite()
public SSLSocket getSocket()
## 会话管理
SSL常用于Web服务器。
作为使用JSSE的程序员，利用会话时不需要任何额外的工作。短时间对一台主机的一个端口打开多个安全Socket，JSSE会自动重用这个会话的密钥。不过在高安全性的应用程序中，可能需要禁止Socket之间的会话共享，或者强制重新认证。
SSLSocket::getSession() 获取所属的Session
避免Socket创建会话，要向setEnableSessionCreation()传入false
很少见的情况下，可能希望重新认证一个连接。startHandshake()可以做到这一点
## 客户端模式
大多数安全通信中，服务器需要使用适当的证书认证自己。不过客户端并非如此。
setUserClientMode()方法确定Socket是否需要在第一次握手时使用认证。客户端和服务端都可以使用这个方法，不过，出入true时，表示Socket处于客户端模式，因此不会提供自行认证。传入false则会尝试自行认证。
这个属性对于任何指定Socket只能设置一次，试图第二次设置时会抛出一个异常
getUserClientMode()返回是否处于客户端模式
服务器端的安全socket可以使用setNeedClientAuth()方法，要求与它连接的所有客户端都要自行认证
如果socket不在服务器端则会抛出异常
getNeedClientAuth()方法返回是否需要验证
## 创建安全服务器Socket
javax.net.SSLServerSocket类的实例
与SSLSocket相似，这个类的所有构造函数都是保护类型的，而且SSLServerSocket实例由抽象工厂类javax.net.SSLServerSocketFactory创建
public static ServerSokcetFactory getDefault()
SSLServerSocketFactory有3个重载的createServerSocket()方法，可以返回SSLServerSocket实例。
SSLServerSocketFactory.getDefault()返回的工厂模式一般只支持服务器认证，不支持加密。为了同时进行加密，服务器端安全socket需要更多的初始化和设置。在Sun的参考实现中，要由一个com.sun.net.ssl.SSLContext对象负责创建已经充分配置和初始化的安全服务器Socket
参考实现中必须完成以下步骤
1)使用keytool生成公开密钥和证书
2)请第三方认证证书
3)为使用的算法创建一个SSLContext
4)为要使用的证书源创建一个TrustManagerFactory
5)为要使用的密钥类型创建一个KeyManagerFactory
6)为密钥和证书数据库创建一个KeyStore对象（Oracle默认是JKS）
7)用密钥和证书填充KeyStore对象
8)用KeyStore及其口令短语初始化KeyManagerFactory
9)用KeyManagerFactory中的密钥管理器（必要）、TrustManagerFactory中的信任管理器和一个随机源来初始化上下文。
## 配置SSLServerSocket
# 选择密码组
getSupportedCipherSuites()
getEnabledCipherSuites()
setEnabledCipherSuites(String[] suites)




### 非阻塞IO
## 示例客户端
SocketChannel.open()创建java.nio.channels.SocketChannel对象，方法参数接受一个java.net.SocketAddress对象，指示要连接的主机和端口。
通道以阻塞模式打开，在真正连接之前不会执行，如果不能连接则会抛出异常
传统的Socket，需要获取输入和输出流，而利用通道则可以直接写入通道本身，不是字节数组，而是要写入ByteBuffer对象。
ByteBuffer buffer = ByteBuffer.allocate(74);
将ByteBuffer对象传递给通道的read方法，通道就会从Socket中读取的数据来填充这个缓冲区。返回成功读取并存储在缓冲区的字节数。
int bytesRead = client.read(buffer)
默认至少读取一个字节，或者返回-1指示数据结束。
假定缓冲区中有一些数据，将要被读取并复制到System.out。一般方法是读取一个字节数组，然后写入传统的OutputStream。不过，坚持采用一种完全基于通道的解决方法会更有好处。需要利用Channels工具类。将OutputStream封装到一个通道中 
WritableByteChannel output = Channels.newChannel(System.out)
然后就可以将读取的数据写入输出通道中。
buffer.flip()
buffer.clear()

## 缓冲区
除了boolean，Java的所有基本数据类型都有特定的Buffer子类，ByteBuffer，CharBuffer，ShortBuffer,IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer，每个子类中的方法都有相应类型的返回值和参数列表。
除了数据列表之外，每个缓冲区都记录了信息的4个关键部分
1.位置 position
缓冲区中将读取或写入的下一个位置。从0开始，最大值等于缓冲区的大小
public finai int postion()
public final Buffer position(int newPosition)
2.容量 capacity
可以保存的元素的最大数目，容量值在创建缓冲区时设置，此后不能改变
public final int capacity()
3.限度 limit
缓冲区中可以访问数据的末尾位置，只要不改变限度，就无法读/写超过这个位置的数据，即使缓冲区有更大的容量也没用。
public final int limit()
public final Buffer limit(int newLimit)
4.标记 mark
客户端指定的索引，通过调用mark()方法可以将标记位置设置为当前位置 reset()方法将当前位置设置为标记位置
public final Buffer mark()
public final Buffer reset()
如果将当前位置设置为低于标记位置，则丢弃这个标记
与读取InputStream不同，读取缓冲区实际上不会以任何方式改变缓冲区的数据。只可能向前或向后设置位置，从而可以从缓冲区中某个特定位置开始读取。类似的，程序可以调整限度，从而控制将要读取的数据的末尾。只有容量是固定的。
公共Buffer超类还提供另外几个方法
clear()将位置设置为0，将限度设置为容量，从而将缓冲区清空，可以重新填充缓冲区。
public final Buffer clear()
clear()方法并没有删除缓冲区的老数据，还可以使用决定get方法或者改变限度和位置来读取
rewind()将位置设置为0，单不改变限度
public final Buffer rewind()
允许重新读取缓冲区
flip()方法将限度设置为当前位置，位置设置为0
public final Buffer flip()
希望排空填充的缓冲区时调用（输出）
remainging()方法返回缓冲区中当前位置和限度之间的元素数
public final int remaining()
如果剩余元素大于0hasRemaining()返回true
public final boolean hasRemaining()
## 创建缓冲区
缓冲区类的层次是基于继承的，而不是基于多态。
每个缓冲区类都有几个工厂方法，以各种方式创建这个类型的特定于实现的子类。空的缓冲区一般由分配allocate方法创建，预填充数据的缓冲区有包装(wrap)方法创建。分配方法通常用于输入，包装方法一般用于输出。
1.分配
基本allocate()方法只返回一个有指定固定容量的新缓冲区。这是一个空的缓冲区
游标位于缓冲区开始位置（0），创建的缓冲区基于Java数组实现，可以通过array()和arrayOffset()方法来访问。
array()方法实际暴露了缓冲区的私有数据，不推荐使用。
2.直接分配
ByteBuffer（但不包括其他缓冲区类）有另外一个allocateDirect()方法，不为缓冲区创建后备数组。虚拟机会对以太网卡、核心内存或其他位置上的缓冲区使用直接内存访问，以此实现直接分配的ByteBuffer。不是必需的，但确实是允许的，可以提升I/O操作的性能。从API角度allocateDirect()的使用和allocate()完全相同。
在直接缓冲区上使用array()和arrayOffset()会抛出异常。直接缓冲区块，但代价更高，只在缓冲区短时间分配时才分配这种直接缓冲区。不推荐使用
3.包装
如果已经有了要输出的数据数组，一般要用缓冲区进行包装。而不是分配一个新缓冲区，然后一部分一部分复制。
4.填充和排空
缓冲区时为顺序访问而设计的。每个缓冲区都有一个当前位置，有position()方法标识，从0到缓冲区元素个数之间的某个数。从缓冲区中读取或写入元素时，缓冲区位置将增1.
缓冲区至多只能填充到其容量大小，如果视图填充的数据超出了初始设置的容量，put()方法会抛出异常。
如果在写入后直接使用get()从缓冲区中获取数据会得到null字符。Java初始化字符缓冲区时当前位置就是null字符。再次读取写入的数据之前，需要回绕缓冲区。
buffer.flip()
会把缓冲区的的限度设置为其位置，将位置重新设置为0，然后就可以排空一个缓冲区
现在调用get()会将位置前移一个元素，位置达到限度时，hasRemaining返回false，这就被称为排空缓冲区。
缓冲区还有一些绝对方法，可以在缓冲区指定位置填充和排空，无需更新位置。
ByteBuffer有以下两个方法
public abstract byte get(int index)
public abstract ByteBuffer put(int index, byte b)
# 批量方法
即使是使用缓冲区，操作数据块通常也比一次填充和排空一个元素要快。不同缓冲区类都有一些批量方法来填充和排空相应元素类型的数组
public ByteBuffer get(byte[] dst, int offset, int length)
public ByteBuffer put(byte[] array, int offset, int length)
# 数据转换
Java的所有数据最终都解析为字节，所有基本数据类型 int、double、float等都可以写为字节。任何适当长度的字节序列都可解释为基本类型数据。
# 视图缓冲区
如果知道从SocketChannel读取的ByteBuffer只包含一种特定基本数据类型的元素，就有必要创建一个视图缓冲区（view buffer)。
从当前位置开始由底层ByteBuffer提取数据，修改视图缓冲区会反映到底层缓冲区，返回亦然。不过每个缓冲区都有自己独立的限度、容量、标记和位置。
public abstract ShortBuffer asShortBuffer()
...
虽然可以完全使用IntBuffer类的方法来填充和排空缓冲区，但数据必须使用ByteBuffer对通道进行读写，SocketChannel类只有读/写ByteBuffer的方法，无法读写任何其他类型的缓冲区。
# 压缩缓冲
大多数可写缓冲区都支持compact方法
public abstract ByteBuffer compart()
压缩时将缓冲区所有剩余数据移到缓冲区的开头，为元素释放更多空间缓冲区的位置设置为数据末尾，从而可以写入更多数据
使用非IO进行复制时，压缩时一个特别有用的操作。可以将一些数据读入缓冲区，再写出缓冲区，然后压缩数据。这样没写的数据就在缓冲区开头，位置则在剩余数据末尾，从而准备接受更多数据。只利用一个缓冲区就能完成比较随机的交替读写。
# 复制缓冲区
经常需要建立缓冲区的副本，从而将相同的信息分发到两个或多个通道中。
public abstract ByteBuffer duplicate()
返回值并不是克隆，复制的缓冲区共享相同的数据，如果原来是一个间接缓冲区，那么复制缓冲区会包含相同的后备数据。修改一个缓冲区的数据会反映到另一个缓冲区中。
尽管共享相同的数据，但初始和复制的缓冲区都有独立的标记、限度好位置。
# 分片缓冲区
分片缓冲区时复制的一个变形，分片也会创建一个新缓冲区，与元缓冲区共享数据。不过，分片的起始位置是元缓冲区的当前位置，而且其容量不超过元缓冲区的限度。也就是说，分片是原缓冲区的一个子序列。只包含从当前位置到限度的所有元素。
public abstract ByteBuffer slice()
很长的缓冲区时分为多个分片很有帮助
# 标记和重置
希望重读某些数据，可以标记和重置缓冲区

## Object方法
缓冲区类都提供了一般的equals、hashCode和toString方法，还是先了Comparable接口，但不是Serializable或Cloneable的
当满足以下条件时，会认为两个缓冲区时相等的
1.具有相同类型
2.缓冲区剩余的元素个数相同
3.相同相对位置上的剩余元素彼此相同

## 通道
通道将缓冲区的数据块移入或移出各种IO源。如文件、socket、数据报等。通道类的层次结构相当复杂，有多个接口和许多可选操作。不过，对于网络编程而言，实际上只有3个重要的通道类
1.SocketChannel
2.ServerSocketChannel
3.DatagramChannel
# SocketChannel
用于读写TCP Socket，必须编码到ByteBuffer对象中来完成读、写。每个SocketChannel都与一个对等端Socket对象相关联，可以用于高级配置
1.连接
SocketChannel类没有任何公共构造函数，实际上需要使用两个静态open方法来创建新的SocketChannel对象
有参数的open方法会建立连接，会阻塞知道连接成功或抛出异常
无参数的open方法则不立即连接，创建一个未连接的socket，以后必须使用connect方法进行连接。
非阻塞通道，connect方法会立即返回，在等待建立连接时可以做其他操作。在实际使用连接之前，必须调用finishConnect方法
SocketChannel socketChannel = SocektChannel.open()
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(''));
if (socketChannel.finishConenct) {

}
isConnected()
isConnectPending()
2.读取
public abstract int read(ByteBuffer dst)
通道会尽可能多的数据填充缓冲区，然后返回放入的字节数。如果遇到流末尾，通道会用所有剩余的字节填充缓冲区，而且在下一次调用read()时返回-1
因为数据将存储在缓冲区的当前位置，而这个位置会随着增加更多数据而自动更新，所以可以一直向read()方法传入同一个缓冲区，知道缓冲区被填满。
也可以从一个源填充多个缓冲区。称为散布
public abstract long read(ByteBuffer[] dsts, int offset, int length)
只要列表中的最后一个缓冲区还有剩余空间，就可以继续循环填充
3.写入
想要写入，只需填充一个ByteBuffer，将其回绕，然后传给某个写入方法，这个方法在把数据复制到输出时将缓冲区排空
public abstract int write(ByteBuffer src)
将多个缓冲区写入一个socket通常也很有用。称为聚集
public final long write(ByteBuffer[] dsts)
4.关闭
像正常Socket一样，在用完通道后应当将其关闭，释放可能使用的端口和其他任何资源。
public void close()
如果已经关闭，再进行关闭没有任何效果。isOpen方法检查
public boolean isOpen() 

## ServerSocketChannel
只有一个目的，接受入站连接。
1.创建服务器Socket通道
ServerSocketFactory.open()
此方法只创建新的ServerSocketChannel对象，并不打开一个新的服务器Socket。需要使用socket方法获取相应的对等端ServerSocket，然后配置服务器选项，最后绑定端口打开Socket
2.接受连接
public absract SocketChannel accept()
可以在阻塞和非阻塞模式下操作。
阻塞模式阻塞知道有入站连接
非阻塞模式在没有入站连接时直接返回null，一般配合Selector使用

## Channels类
是一个简单的工具类，可以将传统的基于I/O的流、阅读器和书写器包装在通道中，也可以从通道转换为基于I/O流、阅读器和书写器。


## 异步通道
Java7引入AsynchronousSocketChannel和AsynchronousServerSocketChannel类，与SocketChannel和ServerSocketChannel不同的是，读写会立即返回甚至在IO完成之前。数据会有一个Future或CompletionHandler进一步处理。

## 就绪准备
# Selector类
唯一的构造函数时保护方法，一般情况下需要使用Selector.open()来创建新的选择器。
public static Selector open()
然后是向选择器增加通道，需要使用SelectableChannel类中的register方法，
public final SelectionKey register(Selector sel, int ops)
public final SelectionKey register(Selector sel, int ops, Object att)
SelectionKey中定义了4个命名位常量，用于选择操作类型。
SelectionKey.OP_ACCEPT
SelectionKey.OP_CONNECT
SelectionKey.OP_READ
SelectionKey.OP_WRITE
同时关注多个操作，使用或|操作符即可
不同的通道注册到选择器后，就可以随时查询选择器，找出那些通道已经准备好可以进行处理。
3个方法
selectNow 会完成非阻塞选择，如果没有准备好要处理的连接，会立即返回
另外两个则是阻塞的
select()
select(long timeout)
当知道有通道已经准备好处理时，可以使用selectionKeys方法获取就绪通道
Set<SelectionKey> selectKeys()
要依次处理各个SelectionKey，还可以从迭代器中删除键，告诉选择器这个键已经处理，否则选择器在之后的循环中一直通知有这个键。
最后当准备关闭服务器或不需要选择器后，应当将其关闭
会释放与选择器关联的所有资源，取消向选择器注册的所有键，并中断被这个选择器的某个选择方法所阻塞的线程。
# SelectionKey类
相当于通道的指针，还可以保存一个对象附件，一般会存储这个通道上的连接的状态。
将一个通道注册到一个选择器时，register()方法会返回SelectionKey对象，不过，通常不需要保留这个引用。selectKeys方法可以在Set中再次返回相同的对象。
获取一个SelectionKey时，通常需要测试这些键能进行哪些操作
public fianl boolean isAccpet()
public fianl boolean isConnectable()
public fianl boolean isReadable()
public fianl boolean isWritable()
public abstract SelectableChannel channel()
public final Object attachment()
public abstract void cancel() // 撤销SelectionKey对象的注册，选择器就不会浪费资源去查询是否准备就绪

### UDP
***** 未看完


### IP组播
***** 未看完
































